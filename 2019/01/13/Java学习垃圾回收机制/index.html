<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo_miccall.png">
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Frewen.Wong'Program World!
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="miccall">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>Java垃圾回收机制的学习</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <p>文章参考：<a href="https://blog.csdn.net/pi9nc/article/details/12374049" target="_blank" rel="noopener">https://blog.csdn.net/pi9nc/article/details/12374049</a></p>
<h3 id="1-垃圾回收的意义"><a href="#1-垃圾回收的意义" class="headerlink" title="1. 垃圾回收的意义"></a>1. 垃圾回收的意义</h3><p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。</p>
<p>垃圾回收能自动释放内存空间，减轻编程的负担。这使Java虚拟机具有一些优点。</p>
<p>首先，它能使编程效率提高。在没有垃圾回收机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾回收机制可大大缩短时间。</p>
<p>其次是它保护程序的完整性， 垃圾回收是Java语言安全性策略的一个重要部份。垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收算法的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</p>
<h3 id="2-垃圾收集的算法分析"><a href="#2-垃圾收集的算法分析" class="headerlink" title="2. 垃圾收集的算法分析"></a>2. 垃圾收集的算法分析</h3><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：</p>
<ul>
<li>（1）发现无用信息对象；</li>
<li>（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。</li>
</ul>
<h3 id="3、垃圾是否回收的依据算法"><a href="#3、垃圾是否回收的依据算法" class="headerlink" title="3、垃圾是否回收的依据算法"></a>3、垃圾是否回收的依据算法</h3><h4 id="3-1-引用计数法-Reference-Counting-Collector"><a href="#3-1-引用计数法-Reference-Counting-Collector" class="headerlink" title="3.1. 引用计数法(Reference Counting Collector)"></a>3.1. 引用计数法(Reference Counting Collector)</h4><p>引用计数法是唯一没有使用根集的垃圾回收的法，该算法使用引用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。</p>
<p>基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。但引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域，计数器减1。 </p>
<p>但这种方法有一个问题，比方说有两个对象 A 和 B，A 引用了 B，B 又引用了 A，除此之外没有别的对象引用 A 和 B，那么 A 和 B 在我们看来已经是垃圾对象，需要被回收，但它们的引用计数不为 0，没有达到回收的条件。正因为这个循环引用的问题，Java 并没有采用引用计数法。</p>
<p>引用计数法优点：实现简单，判定效率也很高；</p>
<p>引用计数法缺点：难以解决对象之间相互循环引用导致计数器值不等于0的问题。</p>
<h4 id="3-2-可达性分析法-Reference-Counting-Collector"><a href="#3-2-可达性分析法-Reference-Counting-Collector" class="headerlink" title="3.2. 可达性分析法(Reference Counting Collector)"></a>3.2. 可达性分析法(Reference Counting Collector)</h4><p>大多数垃圾回收算法使用了根集(root set)这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。可达性分析法首先需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。</p>
<p><img src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731153706.png" alt></p>
<p>从图中我们可以看出：通过可达性分析法，从GC Roots开发进行对象可达性分析，可以看出obj5、obj6、obj7的对象都是不可达的，尽管他们之间存在引用关系（这种情况使用引用计数法就会存在问题）</p>
<h3 id="4-垃圾回收的算法分析"><a href="#4-垃圾回收的算法分析" class="headerlink" title="4. 垃圾回收的算法分析"></a>4. 垃圾回收的算法分析</h3><h4 id="4-1-tracing算法-Tracing-Collector-跟踪收集器"><a href="#4-1-tracing算法-Tracing-Collector-跟踪收集器" class="headerlink" title="4.1 tracing算法(Tracing Collector 跟踪收集器)"></a>4.1 tracing算法(Tracing Collector 跟踪收集器)</h4><p>tracing(跟踪算法)算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。<br>在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.<br>标记清除算法： 顾名思义分为两步，标记和清除。首先标记到需要回收的垃圾对象，然后回收掉这些垃圾对象。</p>
<p>下面这张图是从网上抠的。大家可以看一下。<br><img src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731153750.png" alt><br>标记清除算法的缺点：</p>
<ul>
<li>1、空间问题：清除垃圾对象后会造成内存的碎片化，导致会产生大量的不连续的内存碎片。</li>
<li>2、效率问题：标记和清除两个过程的效率都不高。</li>
</ul>
<h4 id="4-2-compacting算法-Compacting-Collector-压缩算法，较常用是基于压缩算法的整理标记算法"><a href="#4-2-compacting算法-Compacting-Collector-压缩算法，较常用是基于压缩算法的整理标记算法" class="headerlink" title="4.2 compacting算法(Compacting Collector 压缩算法，较常用是基于压缩算法的整理标记算法)"></a>4.2 compacting算法(Compacting Collector 压缩算法，较常用是基于压缩算法的整理标记算法)</h4><p>为了解决堆碎片问题，==基于压缩算法的标记整理算法==。主要是分为两步：先标记后整理。首先标记可以回收的垃圾对象。然后进行压缩。基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>
<p><img src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731202739.png" alt></p>
<p>基于compacting算法的标记整理算法的优点：</p>
<ul>
<li>1、避免了内存碎片；</li>
<li>2、避免了“复制”算法50%的空间浪费；</li>
<li>3、主要针对对象存活率高的老年代。</li>
</ul>
<h4 id="4-3-copying算法-Coping-Collector-复制算法"><a href="#4-3-copying算法-Coping-Collector-复制算法" class="headerlink" title="4.3 copying算法(Coping Collector 复制算法)"></a>4.3 copying算法(Coping Collector 复制算法)</h4><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。</p>
<p>一种典型的基于coping算法(复制算法)的垃圾回收是stop-and-copy算法，它将堆内存按容量划分为大小相等的两块：对象区和空闲区域区，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。在对象区与空闲区域的切换过程中，程序暂停执行。 </p>
<p><img src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731203019.png" alt></p>
<p>复制算法的优点</p>
<ul>
<li>1、可以有效避免内存的碎片化问题，实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可；</li>
</ul>
<p>复制算法缺点：</p>
<ul>
<li>1、因为需要将提前预留出空闲区。他需要两倍的内存，造成内存浪费。</li>
<li>2、stop-and-copy算法就是复制算法收集器要复制所有的活动对象，增加了程序等待时间，算法效率很低。</li>
</ul>
<h4 id="4-4-generation算法-Generational-Collector-分代算法"><a href="#4-4-generation算法-Generational-Collector-分代算法" class="headerlink" title="4.4 generation算法(Generational Collector 分代算法)"></a>4.4 generation算法(Generational Collector 分代算法)</h4><p>stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。</p>
<p>新生代对象分为三个区域：Eden 区和两个 Survivor 区。新创建的对象都放在 Eden区，当 Eden区的内存达到阈值之后会触发 Minor GC，这时会将存活的对象复制到一个 Survivor 区中，这些存活对象的生命存活计数会加一。这时 Eden 区会闲置，当再一次达到阈值触发 Minor GC 时，会将Eden区和之前一个 Survivor 区中存活的对象复制到另一个 Survivor 区中，采用的是我之前提到的复制算法，同时它们的生命存活计数也会加一。</p>
<p>这个过程会持续很多遍，直到对象的存活计数达到一定的阈值后会触发一个叫做晋升的现象：新生代的这个对象会被放置到老年代中。</p>
<p>老年代中的对象都是经过多次 GC 依然存活的生命周期很长的 Java 对象。当老年代的内存达到阈值后会触发 Major GC，采用的是标记整理算法。</p>
<h4 id="4-5-adaptive算法-Adaptive-Collector-自适应算法"><a href="#4-5-adaptive算法-Adaptive-Collector-自适应算法" class="headerlink" title="4.5 adaptive算法(Adaptive Collector 自适应算法)"></a>4.5 adaptive算法(Adaptive Collector 自适应算法)</h4><p>　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p>
<p>　　</p>
<h3 id="5-System-gc-方法"><a href="#5-System-gc-方法" class="headerlink" title="5. System.gc()方法"></a>5. System.gc()方法</h3><p>命令行参数透视垃圾收集器的运行<br>使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：
　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -verbosegc classfile</span><br></pre></td></tr></table></figure>

<p>可以看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TestGC  </span><br><span class="line">&#123;  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">　　    new TestGC();  </span><br><span class="line">　　    System.gc();  </span><br><span class="line">　　    System.runFinalization();  </span><br><span class="line">　　 &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为不可达，程序编译后，执行命令：<br>java -verbosegc TestGC 后结果为：
　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 168K-&gt;97K(1984K)， 0.0253873 secs]</span><br></pre></td></tr></table></figure>


<p>需要注意的是，调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p>
<h3 id="6-finalize-方法"><a href="#6-finalize-方法" class="headerlink" title="6. finalize()方法"></a>6. finalize()方法</h3><p>在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。<br>它的原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() throws Throwable</span><br></pre></td></tr></table></figure>

<p>在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。</p>
<p>finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</p>
<p>另外，假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p>
<p>特殊的区域例如：</p>
<h5 id="1）由于在分配内存的时候可能采用了类似-C语言的做法，而非JAVA的通常new做法。"><a href="#1）由于在分配内存的时候可能采用了类似-C语言的做法，而非JAVA的通常new做法。" class="headerlink" title="1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。"></a>1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。</h5><p>这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。</p>
<h5 id="2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。"><a href="#2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。" class="headerlink" title="2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。"></a>2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。</h5><p>换言之，finalize()的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。因为在JAVA中并没有提够像“析构”函数或者类似概念的函数，要做一些类似清理工作的时候，必须自己动手创建一个执行清理工作的普通方法，也就是override Object这个类中的finalize()方法。例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远都不会被清理。如果在finalize()加入某一种擦除功能，当GC工作时，finalize()得到了调用，图像就会被擦除。要是GC没有发生，那么这个图像就会<br>被一直保存下来。</p>
<p>所以，我们建议finalize()用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。</p>
<h4 id="6-1、finalize的执行过程-生命周期"><a href="#6-1、finalize的执行过程-生命周期" class="headerlink" title="6.1、finalize的执行过程(生命周期)"></a>6.1、finalize的执行过程(生命周期)</h4><p>1、首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p>
<p>2、具体的finalize流程：</p>
<p>对象存在两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：</p>
<ul>
<li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li>
<li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li>
<li>finalized: 表示GC已经对该对象执行过finalize方法</li>
<li>reachable: 表示GC Roots引用可达</li>
<li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li>
<li>unreachable：对象不可通过上面两种途径可达</li>
</ul>
<p>具体的状态切换看下面的图：</p>
<p><img src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/finalize.png" alt></p>
<p>变迁说明：<br>1、新建对象首先处于[reachable, unfinalized]状态(A)</p>
<p>2、随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</p>
<p>3、若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</p>
<p>4、在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</p>
<p>5、处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</p>
<p>6、程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</p>
<p>7、若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</p>
<p>8、若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2019/01/13/Java学习垃圾回收机制/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2019/01/13/Java学习垃圾回收机制/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
