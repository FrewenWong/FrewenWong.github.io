<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ReactNative的渲染流程(基于ReacNative0.61.5)</title>
      <link href="/2020/04/07/ReactNative%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B(%E5%9F%BA%E4%BA%8EReacNative0.61.5)/"/>
      <url>/2020/04/07/ReactNative%E7%9A%84%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B(%E5%9F%BA%E4%BA%8EReacNative0.61.5)/</url>
      
        <content type="html"><![CDATA[<p>文章参考：<a href="https://www.jianshu.com/p/4e0217b8f8aa" target="_blank" rel="noopener">https://www.jianshu.com/p/4e0217b8f8aa</a></p><p>Scheduler<br><a href="https://zhuanlan.zhihu.com/p/84952196" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/84952196</a></p><p>React Scheduler 源码详解<br><a href="https://juejin.im/post/5c32c0c86fb9a049b7808665" target="_blank" rel="noopener">https://juejin.im/post/5c32c0c86fb9a049b7808665</a></p><p>React Fiber源码理解<br><a href="https://juejin.im/post/5d4d2641f265da03ee6a45b6" target="_blank" rel="noopener">https://juejin.im/post/5d4d2641f265da03ee6a45b6</a></p><p>Fiber<br><a href="https://stackblitz.com/edit/js-ntqfil?file=index.js" target="_blank" rel="noopener">https://stackblitz.com/edit/js-ntqfil?file=index.js</a></p><p>effect-list fiber链表构建过程<br><a href="https://www.bilibili.com/video/av48384879/" target="_blank" rel="noopener">https://www.bilibili.com/video/av48384879/</a></p><p>View创建过程浅析<br><a href="https://juejin.im/post/5bfbaaf1f265da615a417f69" target="_blank" rel="noopener">https://juejin.im/post/5bfbaaf1f265da615a417f69</a></p><p>React Native源码分析——Virtual DOM<br><a href="https://www.jianshu.com/p/98ef4ce18bb3" target="_blank" rel="noopener">https://www.jianshu.com/p/98ef4ce18bb3</a></p><p>一致性比较（Reconciliation）<br><a href="http://react.html.cn/docs/reconciliation.html" target="_blank" rel="noopener">http://react.html.cn/docs/reconciliation.html</a></p><p>完全理解React Fiber<br><a href="http://www.ayqy.net/blog/dive-into-react-fiber/" target="_blank" rel="noopener">http://www.ayqy.net/blog/dive-into-react-fiber/</a></p><p>React Native组件渲染<br><a href="https://www.jianshu.com/p/c5418720e9f0" target="_blank" rel="noopener">https://www.jianshu.com/p/c5418720e9f0</a></p><p>React的首次渲染流程逻辑：<br><a href="https://juejin.im/post/5b9a45fc5188255c402af11f" target="_blank" rel="noopener">https://juejin.im/post/5b9a45fc5188255c402af11f</a></p><p>我们先来分析 JS 端的渲染流程是怎样的。</p><h3 id="JSX-的转码"><a href="#JSX-的转码" class="headerlink" title="JSX 的转码"></a>JSX 的转码</h3><p>我们写 React 组件的时候，通常会使用JSX来描述组件。JSX 语法是对 JS语法的一种扩展，为了方便开发者在 JS 中编写 UI，在运行期间会通过BABEL转码，我们通过一个比较简单的示例来做转码，原始的 ReactNative 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default class Sample extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;你好，渲染流程&lt;/Text&gt;</span><br><span class="line">        &lt;Text&gt;Hello Render&lt;/Text&gt;</span><br><span class="line">      &lt;/View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过<a href="https://babeljs.io/repl/#?browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=KYDwDg9gTgLgBAE2AMwIYFcA28DGnUDOBcAyqgLZibBygzAB2CxAwhJRA4_AN4BQcOFEZIoACgCUcfoMHCY6KAzhiBswQB4AagEtgAdwB8a9ZoAqdQ4AN5QL6agGH_ATHaBl80CCtoGgvDQHoLIGMdOyGj5-ABLAmJgQcABKIsBQXsH-pl66BsmCEgDcagC-fLlAA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=false&fileSize=false&timeTravel=false&sourceType=module&lineWrap=true&presets=react&prettier=false&targets=&version=7.9.0&externalPlugins=babel-plugin-syntax-jsx%406.18.0" target="_blank" rel="noopener">BABEL</a>转码后：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export default class Sample extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return </span><br><span class="line">        React.createElement(View, null, </span><br><span class="line">            React.createElement(Text, null, &quot;你好，渲染流程&quot;), </span><br><span class="line">            React.createElement(Text, null, &quot;Hello Render&quot;)</span><br><span class="line">        );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，原先 JSX 的元素都被 React.createElement 转化为 ReactElement。在 ReactElement 中使用 type字段存放原始对象（在此处就是ReactNative.View/ReactNative.Text），使用props存放 childrens、其他传入属性等。</p><h3 id="AppRegistry-registerComponent"><a href="#AppRegistry-registerComponent" class="headerlink" title="AppRegistry.registerComponent"></a>AppRegistry.registerComponent</h3><p>首先，ReactNative的js代码都需要通过 AppRegistry.registerComponent注册对应appkey的Component才能被启动。</p><p>我们可以在 AppRegistry.js 中看到它注册了一个对应的回调，在 Native 启动过程中会通过jsbridge调用AppRegistry.runApplication启动js 渲染流程，在js中会调用对应runnable。即后面的renderApplication。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">registerComponent(</span><br><span class="line">  appKey: string,</span><br><span class="line">  componentProvider: ComponentProvider,</span><br><span class="line">  section?: boolean,</span><br><span class="line">): string &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;AppRegistry.js&apos;,</span><br><span class="line">    &apos;FMsg:第二步：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;AppRegistry.registerComponent&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  let scopedPerformanceLogger = createPerformanceLogger();</span><br><span class="line">  // 实例化一个runables对象</span><br><span class="line">  runnables[appKey] = &#123;</span><br><span class="line">    componentProvider,</span><br><span class="line">    run: appParameters =&gt; &#123;</span><br><span class="line">      renderApplication(</span><br><span class="line">        componentProviderInstrumentationHook(</span><br><span class="line">          componentProvider,</span><br><span class="line">          scopedPerformanceLogger,</span><br><span class="line">        ),</span><br><span class="line">        appParameters.initialProps,</span><br><span class="line">        appParameters.rootTag,</span><br><span class="line">        wrapperComponentProvider &amp;&amp; wrapperComponentProvider(appParameters),</span><br><span class="line">        appParameters.fabric,</span><br><span class="line">        showFabricIndicator,</span><br><span class="line">        scopedPerformanceLogger,</span><br><span class="line">      );</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  if (section) &#123;</span><br><span class="line">    sections[appKey] = runnables[appKey];</span><br><span class="line">  &#125;</span><br><span class="line">  return appKey;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在 renderApplication 时会将传入的 Component 变成 ReactElement，包裹在 AppContainer 中，这个 AppContainer 主要用于外面包围一些 Debug 用的工具（如红盒）。</p><p>run方法接收一个参数，叫做appParameters。由上面的分析可知，appParameters就是Android端传递进来的WritableNativeMap对象，其代表的是一些初始化参数。run方法中没有做过多的逻辑，而是直接调用了renderApplication.js中的renderApplication方法。</p><h3 id="renderApplication-js的的renderApplication"><a href="#renderApplication-js的的renderApplication" class="headerlink" title="renderApplication.js的的renderApplication"></a>renderApplication.js的的renderApplication</h3><p>我们按照代码流程进行追溯，发下他调用了renderApplication.js的的renderApplication方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * </span><br><span class="line"> * @param &#123;Root组件，就是index.js里面注册App组件 RootComponent </span><br><span class="line"> * @param &#123;*&#125; initialProps </span><br><span class="line"> * @param &#123;*&#125; rootTag </span><br><span class="line"> * @param &#123;*&#125; WrapperComponent </span><br><span class="line"> * @param &#123;*&#125; fabric </span><br><span class="line"> * @param &#123;*&#125; showFabricIndicator </span><br><span class="line"> * @param &#123;*&#125; scopedPerformanceLogger </span><br><span class="line"> */</span><br><span class="line">function renderApplication&lt;Props: Object&gt;(</span><br><span class="line">  RootComponent: React.ComponentType&lt;Props&gt;,</span><br><span class="line">  initialProps: Props,</span><br><span class="line">  rootTag: any,</span><br><span class="line">  WrapperComponent?: ?React.ComponentType&lt;*&gt;,</span><br><span class="line">  fabric?: boolean,</span><br><span class="line">  showFabricIndicator?: boolean,</span><br><span class="line">  scopedPerformanceLogger?: IPerformanceLogger,</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;renderApplication.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;renderApplication&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;,rootTag</span><br><span class="line">  );</span><br><span class="line">  invariant(rootTag, &apos;Expect to have a valid rootTag, instead got &apos;, rootTag);</span><br><span class="line">  // 使用AppContainer进行包括起来</span><br><span class="line">  //这个 AppContainer 主要用于外面包围一些 Debug 用的工具（如红盒）。</span><br><span class="line">  const renderable = (</span><br><span class="line">    &lt;PerformanceLoggerContext.Provider</span><br><span class="line">      value=&#123;scopedPerformanceLogger ?? GlobalPerformanceLogger&#125;&gt;</span><br><span class="line">      &lt;AppContainer rootTag=&#123;rootTag&#125; WrapperComponent=&#123;WrapperComponent&#125;&gt;</span><br><span class="line">        &lt;RootComponent &#123;...initialProps&#125; rootTag=&#123;rootTag&#125; /&gt;</span><br><span class="line">        &#123;fabric === true &amp;&amp; showFabricIndicator === true ? (</span><br><span class="line">          &lt;ReactFabricIndicator /&gt;</span><br><span class="line">        ) : null&#125;</span><br><span class="line">      &lt;/AppContainer&gt;</span><br><span class="line">    &lt;/PerformanceLoggerContext.Provider&gt;</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  GlobalPerformanceLogger.startTimespan(&apos;renderApplication_React_render&apos;);</span><br><span class="line">  if (fabric) &#123;</span><br><span class="line">    require(&apos;../Renderer/shims/ReactFabric&apos;).render(renderable, rootTag);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    require(&apos;../Renderer/shims/ReactNative&apos;).render(renderable, rootTag);</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;renderApplication.js&apos;,</span><br><span class="line">    &apos;FMsg:最后一步：&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;renderApplication&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;,rootTag</span><br><span class="line">  );</span><br><span class="line">  GlobalPerformanceLogger.stopTimespan(&apos;renderApplication_React_render&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderApplication方法没有过多复杂的逻辑，而是直接调用了ReactNative的render方法。</p><p>调用栈可以看出，renderApplication.js的renderApplication方法调用了ReactNativeRenderer-dev.js的render方法。</p><p>这个就是JS层比较重要的渲染的流程的。</p><h3 id="ReactNativeRenderer-dev-js的render方法"><a href="#ReactNativeRenderer-dev-js的render方法" class="headerlink" title="ReactNativeRenderer-dev.js的render方法"></a>ReactNativeRenderer-dev.js的render方法</h3><p>我们来分析调试过程中的渲染流程<br><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/07/mucjBQe92iZXk5z.jpg"  alt="-w533"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 渲染流储能</span><br><span class="line"> * @param &#123;渲染的组件&#125; element </span><br><span class="line"> * @param &#123;*&#125; containerTag </span><br><span class="line"> * @param &#123;*&#125; callback </span><br><span class="line"> */</span><br><span class="line">render: function(element, containerTag, callback) &#123;</span><br><span class="line">  // 获取root根组件</span><br><span class="line">  var root = roots.get(containerTag);</span><br><span class="line">  // 如果root根组件为空，则进行创建根组件容器。</span><br><span class="line">  if (!root) &#123;</span><br><span class="line">    // TODO (bvaughn): If we decide to keep the wrapper component,</span><br><span class="line">    // We could create a wrapper for containerTag as well to reduce special casing.</span><br><span class="line">    root = createContainer(containerTag, LegacyRoot, false, null);</span><br><span class="line">    roots.set(containerTag, root);</span><br><span class="line">  &#125;</span><br><span class="line">  // 获取到根组件只会进行更新容器组件</span><br><span class="line">  updateContainer(element, root, null, callback);</span><br><span class="line">  return getPublicRootInstance(root);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>当我在应用刚开始启动的时候，我们首先渲染root组件。但我们还没有进行registComponent的时候。这个时候Root组件肯定是为null .所以这个时候，先调用createContainer</p><h3 id="createContainer方案调用"><a href="#createContainer方案调用" class="headerlink" title="createContainer方案调用"></a>createContainer方案调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function createContainer(containerInfo, tag, hydrate, hydrationCallbacks) &#123;</span><br><span class="line">  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks) &#123;</span><br><span class="line">  var root = new FiberRootNode(containerInfo, tag, hydrate);</span><br><span class="line"></span><br><span class="line">  if (enableSuspenseCallback) &#123;</span><br><span class="line">    root.hydrationCallbacks = hydrationCallbacks;</span><br><span class="line">  &#125; // Cyclic construction. This cheats the type system right now because</span><br><span class="line">  // stateNode is any.</span><br><span class="line"></span><br><span class="line">  var uninitializedFiber = createHostRootFiber(tag);</span><br><span class="line">  root.current = uninitializedFiber;</span><br><span class="line">  uninitializedFiber.stateNode = root;</span><br><span class="line">  return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只有第一个选择根组件的时候才会执行。所以我们我们来看updateContainer的逻辑实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function updateContainerAtExpirationTime(</span><br><span class="line">  element,</span><br><span class="line">  container,</span><br><span class="line">  parentComponent,</span><br><span class="line">  expirationTime,</span><br><span class="line">  suspenseConfig,</span><br><span class="line">  callback</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRenader-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;updateContainerAtExpirationTime&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  // TODO: If this is a nested container, this won&apos;t be the root.</span><br><span class="line">  var current$$1 = container.current;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    if (ReactFiberInstrumentation_1.debugTool) &#123;</span><br><span class="line">      if (current$$1.alternate === null) &#123;</span><br><span class="line">        ReactFiberInstrumentation_1.debugTool.onMountContainer(container);</span><br><span class="line">      &#125; else if (element === null) &#123;</span><br><span class="line">        ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var context = getContextForSubtree(parentComponent);</span><br><span class="line">  if (container.context === null) &#123;</span><br><span class="line">    container.context = context;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    container.pendingContext = context;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return scheduleRootUpdate(</span><br><span class="line">    current$$1,</span><br><span class="line">    element,</span><br><span class="line">    expirationTime,</span><br><span class="line">    suspenseConfig,</span><br><span class="line">    callback</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个地方，如果是根节点的话，则需要</p><h3 id="scheduleRootUpdate调用"><a href="#scheduleRootUpdate调用" class="headerlink" title="scheduleRootUpdate调用"></a>scheduleRootUpdate调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function scheduleRootUpdate(</span><br><span class="line">  current$$1,</span><br><span class="line">  element,</span><br><span class="line">  expirationTime,</span><br><span class="line">  suspenseConfig,</span><br><span class="line">  callback</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRenader-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;scheduleRootUpdate&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  &#123;</span><br><span class="line">    if (phase === &quot;render&quot; &amp;&amp; current !== null &amp;&amp; !didWarnAboutNestedUpdates) &#123;</span><br><span class="line">      didWarnAboutNestedUpdates = true;</span><br><span class="line">      warningWithoutStack$1(</span><br><span class="line">        false,</span><br><span class="line">        &quot;Render methods should be a pure function of props and state; &quot; +</span><br><span class="line">          &quot;triggering nested component updates from render is not allowed. &quot; +</span><br><span class="line">          &quot;If necessary, trigger nested updates in componentDidUpdate.\n\n&quot; +</span><br><span class="line">          &quot;Check the render method of %s.&quot;,</span><br><span class="line">        getComponentName(current.type) || &quot;Unknown&quot;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //创建一个更新队列.重点看我们下面给这个更新队列设置的几个属性</span><br><span class="line">  var update = createUpdate(expirationTime, suspenseConfig);</span><br><span class="line">  // Caution: React DevTools currently depends on this property</span><br><span class="line">  // being called &quot;element&quot;.</span><br><span class="line">  // 表示这个更新对应的数据内容。这个主意，这个就把我们设置的各种组件ReactElement的赋值给update</span><br><span class="line">  update.payload = &#123; element: element &#125;;</span><br><span class="line"></span><br><span class="line">  callback = callback === undefined ? null : callback;</span><br><span class="line">  if (callback !== null) &#123;</span><br><span class="line">    !(typeof callback === &quot;function&quot;)</span><br><span class="line">      ? warningWithoutStack$1(</span><br><span class="line">          false,</span><br><span class="line">          &quot;render(...): Expected the last optional `callback` argument to be a &quot; +</span><br><span class="line">            &quot;function. Instead received: %s.&quot;,</span><br><span class="line">          callback</span><br><span class="line">        )</span><br><span class="line">      : void 0;</span><br><span class="line">    // 设置这个组件每个节点更新完成之后的回调。很重要</span><br><span class="line">    update.callback = callback;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (revertPassiveEffectsChange) &#123;</span><br><span class="line">    flushPassiveEffects();</span><br><span class="line">  &#125;</span><br><span class="line">  // 加入到更新队列中</span><br><span class="line">  enqueueUpdate(current$$1, update);</span><br><span class="line">  // 进度调度工作</span><br><span class="line">  scheduleWork(current$$1, expirationTime);</span><br><span class="line"></span><br><span class="line">  return expirationTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中创建了一个更新队列。默认的更新队列属性参数的如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 在调度算法执行过程中，会将需要进行变更的动作以一个Update数据来表示。同一个队列中的Update，会通过next属性串联起来，实际上也就是一个单链表。</span><br><span class="line"> * @param &#123;*&#125; expirationTime </span><br><span class="line"> * @param &#123;*&#125; suspenseConfig </span><br><span class="line"> */</span><br><span class="line">function createUpdate(expirationTime, suspenseConfig) &#123;</span><br><span class="line">  var update = &#123;</span><br><span class="line">    expirationTime: expirationTime,</span><br><span class="line">    suspenseConfig: suspenseConfig,</span><br><span class="line">    // 当前有0~3，分别是UpdateState、ReplaceState、ForceUpdate、CaptureUpdate</span><br><span class="line">    // var UpdateState = 0;</span><br><span class="line">    // var ReplaceState = 1;</span><br><span class="line">    // var ForceUpdate = 2;</span><br><span class="line">    // var CaptureUpdate = 3;</span><br><span class="line">    tag: UpdateState,</span><br><span class="line">    // 表示这个更新对应的数据内容</span><br><span class="line">    payload: null,</span><br><span class="line">    // 表示更新后的回调函数，如果这个回调有值，就会在UpdateQueue的副作用链表中挂在当前Update对象</span><br><span class="line">    callback: null,</span><br><span class="line">    // UpdateQueue中的Update之间通过next来串联，表示下一个Update对象</span><br><span class="line">    next: null,</span><br><span class="line">    nextEffect: null</span><br><span class="line">  &#125;;</span><br><span class="line">  &#123;</span><br><span class="line">    update.priority = getCurrentPriorityLevel();</span><br><span class="line">  &#125;</span><br><span class="line">  return update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在看一下，这个给这个更新队列的设置的update.payload属性的参数：<br><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/07/IqxTZkUXwBA7hsE.jpg"  alt="-w530"></p><p>从上面这个截图我们就可以看出，我们自己定义的组件。已经添加到更新队列中</p><h3 id="enqueueUpdate"><a href="#enqueueUpdate" class="headerlink" title="enqueueUpdate"></a>enqueueUpdate</h3><p>然后，这个执行完毕之后，调用的函数： enqueueUpdate(current$$1, update)</p><p>下面，我们来看一下这个方法。添加到更新队列中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(fiber, update) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRenader-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;enqueueUpdate&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  // Update queues are created lazily.</span><br><span class="line">  var alternate = fiber.alternate;</span><br><span class="line">  var queue1 = void 0;</span><br><span class="line">  var queue2 = void 0;</span><br><span class="line">  if (alternate === null) &#123;</span><br><span class="line">    // There&apos;s only one fiber.  给fiber的updateQueue赋值给queue1</span><br><span class="line">    // Root节点的时候updateQueue应该是个Null</span><br><span class="line">    queue1 = fiber.updateQueue;</span><br><span class="line">    queue2 = null;</span><br><span class="line">    // 这个地方进行创建更新的队列</span><br><span class="line">    if (queue1 === null) &#123;</span><br><span class="line">      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // There are two owners.</span><br><span class="line">    queue1 = fiber.updateQueue;</span><br><span class="line">    queue2 = alternate.updateQueue;</span><br><span class="line">    if (queue1 === null) &#123;</span><br><span class="line">      if (queue2 === null) &#123;</span><br><span class="line">        // Neither fiber has an update queue. Create new ones.</span><br><span class="line">        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);</span><br><span class="line">        queue2 = alternate.updateQueue = createUpdateQueue(</span><br><span class="line">          alternate.memoizedState</span><br><span class="line">        );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Only one fiber has an update queue. Clone to create a new one.</span><br><span class="line">        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (queue2 === null) &#123;</span><br><span class="line">        // Only one fiber has an update queue. Clone to create a new one.</span><br><span class="line">        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // Both owners have an update queue.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 当队列为空的时候，我们进行队列尾部填充我们这个需要更新</span><br><span class="line">  if (queue2 === null || queue1 === queue2) &#123;</span><br><span class="line">    // There&apos;s only a single queue.</span><br><span class="line">    // 这个地方，我们看到queue2为null  或者queue1 === queue2。我们是将update添加到queue1的队列尾部</span><br><span class="line">    appendUpdateToQueue(queue1, update);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // There are two queues. We need to append the update to both queues,</span><br><span class="line">    // while accounting for the persistent structure of the list — we don&apos;t</span><br><span class="line">    // want the same update to be added multiple times.</span><br><span class="line">    if (queue1.lastUpdate === null || queue2.lastUpdate === null) &#123;</span><br><span class="line">      // One of the queues is not empty. We must add the update to both queues.</span><br><span class="line">      appendUpdateToQueue(queue1, update);</span><br><span class="line">      appendUpdateToQueue(queue2, update);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Both queues are non-empty. The last update is the same in both lists,</span><br><span class="line">      // because of structural sharing. So, only append to one of the lists.</span><br><span class="line">      appendUpdateToQueue(queue1, update);</span><br><span class="line">      // But we still need to update the `lastUpdate` pointer of queue2.</span><br><span class="line">      queue2.lastUpdate = update;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    if (</span><br><span class="line">      fiber.tag === ClassComponent &amp;&amp;</span><br><span class="line">      (currentlyProcessingQueue === queue1 ||</span><br><span class="line">        (queue2 !== null &amp;&amp; currentlyProcessingQueue === queue2)) &amp;&amp;</span><br><span class="line">      !didWarnUpdateInsideUpdate</span><br><span class="line">    ) &#123;</span><br><span class="line">      warningWithoutStack$1(</span><br><span class="line">        false,</span><br><span class="line">        &quot;An update (setState, replaceState, or forceUpdate) was scheduled &quot; +</span><br><span class="line">          &quot;from inside an update function. Update functions should be pure, &quot; +</span><br><span class="line">          &quot;with zero side-effects. Consider using componentDidUpdate or a &quot; +</span><br><span class="line">          &quot;callback.&quot;</span><br><span class="line">      );</span><br><span class="line">      didWarnUpdateInsideUpdate = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function appendUpdateToQueue(queue, update) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRenader-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;appendUpdateToQueue&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  // Append the update to the end of the list.</span><br><span class="line">  if (queue.lastUpdate === null) &#123;</span><br><span class="line">    // Queue is empty。如果队列是空的，则添加到更新的firstUpdate、lastUpdate</span><br><span class="line">    queue.firstUpdate = queue.lastUpdate = update;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    queue.lastUpdate.next = update;</span><br><span class="line">    queue.lastUpdate = update;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法执行完毕之后，我们的update.payload就加入到我们的更新队列。</p><h3 id="scheduleWork"><a href="#scheduleWork" class="headerlink" title="scheduleWork"></a>scheduleWork</h3><p>下面我们调用scheduleWork的方法的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var scheduleWork = scheduleUpdateOnFiber;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 进行Fiber调度更新。这个方法是比较重要</span><br><span class="line">     */</span><br><span class="line">    function scheduleUpdateOnFiber(fiber, expirationTime) &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">        &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;scheduleUpdateOnFiber&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">      );</span><br><span class="line">      checkForNestedUpdates();</span><br><span class="line">      warnAboutInvalidUpdatesOnClassComponentsInDEV(fiber);</span><br><span class="line"></span><br><span class="line">      var root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);</span><br><span class="line">      if (root === null) &#123;</span><br><span class="line">        warnAboutUpdateOnUnmountedFiberInDEV(fiber);</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      root.pingTime = NoWork;</span><br><span class="line"></span><br><span class="line">      checkForInterruption(fiber, expirationTime);</span><br><span class="line">      recordScheduleUpdate();</span><br><span class="line"></span><br><span class="line">      // TODO: computeExpirationForFiber also reads the priority. Pass the</span><br><span class="line">      // priority as an argument to that function and this one.</span><br><span class="line">      var priorityLevel = getCurrentPriorityLevel();</span><br><span class="line">      // 如果有效时间，是同步处理的逻辑。</span><br><span class="line">      if (expirationTime === Sync) &#123;</span><br><span class="line">        if (</span><br><span class="line">          // Check if we&apos;re inside unbatchedUpdates</span><br><span class="line">          (executionContext &amp; LegacyUnbatchedContext) !== NoContext &amp;&amp;</span><br><span class="line">          // Check if we&apos;re not already rendering</span><br><span class="line">          (executionContext &amp; (RenderContext | CommitContext)) === NoContext</span><br><span class="line">        ) &#123;</span><br><span class="line">          // Register pending interactions on the root to avoid losing traced interaction data.</span><br><span class="line">          schedulePendingInteractions(root, expirationTime);</span><br><span class="line"></span><br><span class="line">          // This is a legacy edge case. The initial mount of a ReactDOM.render-ed</span><br><span class="line">          // root inside of batchedUpdates should be synchronous, but layout updates</span><br><span class="line">          // should be deferred until the end of the batch.</span><br><span class="line">          var callback = renderRoot(root, Sync, true);</span><br><span class="line">          while (callback !== null) &#123;</span><br><span class="line">            callback = callback(true);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 如果是ROOT节点的话，我们先来处理一下现在的逻辑。</span><br><span class="line">          scheduleCallbackForRoot(root, ImmediatePriority, Sync);</span><br><span class="line">          if (executionContext === NoContext) &#123;</span><br><span class="line">            // Flush the synchronous work now, wnless we&apos;re already working or inside</span><br><span class="line">            // a batch. This is intentionally inside scheduleUpdateOnFiber instead of</span><br><span class="line">            // scheduleCallbackForFiber to preserve the ability to schedule a callback</span><br><span class="line">            // without immediately flushing it. We only do this for user-initiated</span><br><span class="line">            // updates, to preserve historical behavior of sync mode.</span><br><span class="line">            // 这个方法就是进行同步回调队列的取用处理</span><br><span class="line">            flushSyncCallbackQueue();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 进行Root节点的调度处理</span><br><span class="line">        scheduleCallbackForRoot(root, priorityLevel, expirationTime);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (</span><br><span class="line">        (executionContext &amp; DiscreteEventContext) !== NoContext &amp;&amp;</span><br><span class="line">        // Only updates at user-blocking priority or greater are considered</span><br><span class="line">        // discrete, even inside a discrete event.</span><br><span class="line">        (priorityLevel === UserBlockingPriority ||</span><br><span class="line">          priorityLevel === ImmediatePriority)</span><br><span class="line">      ) &#123;</span><br><span class="line">        // This is the result of a discrete event. Track the lowest priority</span><br><span class="line">        // discrete update per root so we can flush them early, if needed.</span><br><span class="line">        if (rootsWithPendingDiscreteUpdates === null) &#123;</span><br><span class="line">          rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          var lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);</span><br><span class="line">          if (lastDiscreteTime === undefined || lastDiscreteTime &gt; expirationTime) &#123;</span><br><span class="line">            rootsWithPendingDiscreteUpdates.set(root, expirationTime);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="scheduleCallbackForRoot方法调用"><a href="#scheduleCallbackForRoot方法调用" class="headerlink" title="scheduleCallbackForRoot方法调用"></a>scheduleCallbackForRoot方法调用</h3><p>进行ROOT的调度工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">function scheduleCallbackForRoot(root, priorityLevel, expirationTime) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;scheduleCallbackForRoot&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  var existingCallbackExpirationTime = root.callbackExpirationTime;</span><br><span class="line">  if (existingCallbackExpirationTime &lt; expirationTime) &#123;</span><br><span class="line">    // New callback has higher priority than the existing one.</span><br><span class="line">    var existingCallbackNode = root.callbackNode;</span><br><span class="line">    if (existingCallbackNode !== null) &#123;</span><br><span class="line">      cancelCallback(existingCallbackNode);</span><br><span class="line">    &#125;</span><br><span class="line">    root.callbackExpirationTime = expirationTime;</span><br><span class="line">    // 添加到的同步消息队列</span><br><span class="line">    if (expirationTime === Sync) &#123;</span><br><span class="line">      // Sync React callbacks are scheduled on a special internal queue</span><br><span class="line">      root.callbackNode = scheduleSyncCallback(</span><br><span class="line">        runRootCallback.bind(</span><br><span class="line">          null,</span><br><span class="line">          root,</span><br><span class="line">          renderRoot.bind(null, root, expirationTime)</span><br><span class="line">        )</span><br><span class="line">      );</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      var options = null;</span><br><span class="line">      if (</span><br><span class="line">        !disableSchedulerTimeoutBasedOnReactExpirationTime &amp;&amp;</span><br><span class="line">        expirationTime !== Never</span><br><span class="line">      ) &#123;</span><br><span class="line">        var timeout = expirationTimeToMs(expirationTime) - now();</span><br><span class="line">        options = &#123; timeout: timeout &#125;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      root.callbackNode = scheduleCallback(</span><br><span class="line">        priorityLevel,</span><br><span class="line">        runRootCallback.bind(</span><br><span class="line">          null,</span><br><span class="line">          root,</span><br><span class="line">          renderRoot.bind(null, root, expirationTime)</span><br><span class="line">        ),</span><br><span class="line">        options</span><br><span class="line">      );</span><br><span class="line">      if (</span><br><span class="line">        enableUserTimingAPI &amp;&amp;</span><br><span class="line">        expirationTime !== Sync &amp;&amp;</span><br><span class="line">        (executionContext &amp; (RenderContext | CommitContext)) === NoContext</span><br><span class="line">      ) &#123;</span><br><span class="line">        // Scheduled an async callback, and we&apos;re not already working. Add an</span><br><span class="line">        // entry to the flamegraph that shows we&apos;re waiting for a callback</span><br><span class="line">        // to fire.</span><br><span class="line">        startRequestCallbackTimer();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Associate the current interactions with this new root+priority.</span><br><span class="line">  schedulePendingInteractions(root, expirationTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>schedulePendingInteractions 调度处理等待的队列中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function schedulePendingInteractions(root, expirationTime) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;scheduler.develpment.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;schedulePendingInteractions&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  // This is called when work is scheduled on a root.</span><br><span class="line">  // It associates the current interactions with the newly-scheduled expiration.</span><br><span class="line">  // They will be restored when that expiration is later committed.</span><br><span class="line">  if (!enableSchedulerTracing) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  scheduleInteractions(root, expirationTime, tracing.__interactionsRef.current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们来回到scheduleUpdateOnFiber的方法中。在执行完scheduleCallbackForRoot之后。下面调用的flushSyncCallbackQueue。<br>这个方法是同步回调队列的却用处理。我们来看一下这个方法的实现flushSyncCallbackQueue();</p><h3 id="flushSyncCallbackQueue"><a href="#flushSyncCallbackQueue" class="headerlink" title="flushSyncCallbackQueue"></a>flushSyncCallbackQueue</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 进行同步队列里面的更新</span><br><span class="line"> */</span><br><span class="line">function flushSyncCallbackQueue() &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;flushSyncCallbackQueue&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  if (immediateQueueCallbackNode !== null) &#123;</span><br><span class="line">    Scheduler_cancelCallback(immediateQueueCallbackNode);</span><br><span class="line">  &#125;</span><br><span class="line">  flushSyncCallbackQueueImpl();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flushSyncCallbackQueueImpl"><a href="#flushSyncCallbackQueueImpl" class="headerlink" title="flushSyncCallbackQueueImpl"></a>flushSyncCallbackQueueImpl</h3><p>这个方法调用了flushSyncCallbackQueueImpl()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">function flushSyncCallbackQueueImpl() &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;flushSyncCallbackQueueImpl&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  if (!isFlushingSyncQueue &amp;&amp; syncQueue !== null) &#123;</span><br><span class="line">    // Prevent re-entrancy.</span><br><span class="line">    isFlushingSyncQueue = true;</span><br><span class="line">    var i = 0;</span><br><span class="line">    try &#123;</span><br><span class="line">      var _isSync = true;</span><br><span class="line">      var queue = syncQueue;</span><br><span class="line">      // 从所有的同步队列中取出</span><br><span class="line">      runWithPriority(ImmediatePriority, function () &#123;</span><br><span class="line">        for (; i &lt; queue.length; i++) &#123;</span><br><span class="line">          var callback = queue[i];</span><br><span class="line">          do &#123;</span><br><span class="line">            callback = callback(_isSync);</span><br><span class="line">          &#125; while (callback !== null);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      syncQueue = null;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      // If something throws, leave the remaining callbacks on the queue.</span><br><span class="line">      if (syncQueue !== null) &#123;</span><br><span class="line">        syncQueue = syncQueue.slice(i + 1);</span><br><span class="line">      &#125;</span><br><span class="line">      // Resume flushing in the next tick</span><br><span class="line">      Scheduler_scheduleCallback(</span><br><span class="line">        Scheduler_ImmediatePriority,</span><br><span class="line">        flushSyncCallbackQueue</span><br><span class="line">      );</span><br><span class="line">      throw error;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      isFlushingSyncQueue = false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这个方法的时候，我们重点关注一下里面的这个代码块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var _isSync = true;</span><br><span class="line">          var queue = syncQueue;</span><br><span class="line">          // 从所有的同步队列中取出</span><br><span class="line">          runWithPriority(ImmediatePriority, function () &#123;</span><br><span class="line">            for (; i &lt; queue.length; i++) &#123;</span><br><span class="line">              var callback = queue[i];</span><br><span class="line">              do &#123;</span><br><span class="line">                callback = callback(_isSync);</span><br><span class="line">              &#125; while (callback !== null);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">          syncQueue = null;</span><br></pre></td></tr></table></figure><p>这个方法就是从同步队列中取出CallBack的之后，来进行执行回到任务。那这个callBack到底是什么呢？？</p><p>我们可以回过去看scheduleUpdateOnFiber的里面的renderRoot方法。</p><h3 id="renderRoot的调用"><a href="#renderRoot的调用" class="headerlink" title="renderRoot的调用"></a>renderRoot的调用</h3><p>最主要的一个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line"> * 进行Root节点的渲染</span><br><span class="line"> * 真正算法需要需要调用的renderRoot方法，生成一棵完整的FiberNodeTree </span><br><span class="line"> * 这个方法里面有两个重要的调用。</span><br><span class="line"> * 一：commitRoot 进行ROOT节点的提交，这是下一个流程</span><br><span class="line"> * 二: prepareFreshStack.我们执行执行刷新操作</span><br><span class="line"> * 然后finishedWork。</span><br><span class="line"> * @param &#123;*&#125; root </span><br><span class="line"> * @param &#123;*&#125; expirationTime </span><br><span class="line"> * @param &#123;*&#125; isSync </span><br><span class="line"> */</span><br><span class="line">function renderRoot(root, expirationTime, isSync) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;renderRoot&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  (function () &#123;</span><br><span class="line">    if (!((executionContext &amp; (RenderContext | CommitContext)) === NoContext)) &#123;</span><br><span class="line">      throw ReactError(Error(&quot;Should not already be working.&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  if (enableUserTimingAPI &amp;&amp; expirationTime !== Sync) &#123;</span><br><span class="line">    var didExpire = isSync;</span><br><span class="line">    stopRequestCallbackTimer(didExpire);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (root.firstPendingTime &lt; expirationTime) &#123;</span><br><span class="line">    // If there&apos;s no work left at this expiration time, exit immediately. This</span><br><span class="line">    // happens when multiple callbacks are scheduled for a single root, but an</span><br><span class="line">    // earlier callback flushes the work of a later one.</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (isSync &amp;&amp; root.finishedExpirationTime === expirationTime) &#123;</span><br><span class="line">    // There&apos;s already a pending commit at this expiration time.</span><br><span class="line">    // TODO: This is poorly factored. This case only exists for the</span><br><span class="line">    // batch.commit() API.</span><br><span class="line">    return commitRoot.bind(null, root);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flushPassiveEffects();</span><br><span class="line"></span><br><span class="line">  // If we have a work-in-progress fiber, it means there&apos;s still work to do</span><br><span class="line">  // in this root.</span><br><span class="line">  if (workInProgress !== null) &#123;</span><br><span class="line">    var prevExecutionContext = executionContext;</span><br><span class="line">    executionContext |= RenderContext;</span><br><span class="line">    var prevDispatcher = ReactCurrentDispatcher.current;</span><br><span class="line">    if (prevDispatcher === null) &#123;</span><br><span class="line">      // The React isomorphic package does not include a default dispatcher.</span><br><span class="line">      // Instead the first renderer will lazily attach one, in order to give</span><br><span class="line">      // nicer error messages.</span><br><span class="line">      prevDispatcher = ContextOnlyDispatcher;</span><br><span class="line">    &#125;</span><br><span class="line">    ReactCurrentDispatcher.current = ContextOnlyDispatcher;</span><br><span class="line">    var prevInteractions = null;</span><br><span class="line">    if (enableSchedulerTracing) &#123;</span><br><span class="line">      prevInteractions = tracing.__interactionsRef.current;</span><br><span class="line">      tracing.__interactionsRef.current = root.memoizedInteractions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startWorkLoopTimer(workInProgress);</span><br><span class="line"></span><br><span class="line">    // TODO: Fork renderRoot into renderRootSync and renderRootAsync</span><br><span class="line">    if (isSync) &#123;</span><br><span class="line">      if (expirationTime !== Sync) &#123;</span><br><span class="line">        // An async update expired. There may be other expired updates on</span><br><span class="line">        // this root. We should render all the expired work in a</span><br><span class="line">        // single batch.</span><br><span class="line">        var currentTime = requestCurrentTime();</span><br><span class="line">        if (currentTime &lt; expirationTime) &#123;</span><br><span class="line">          // Restart at the current time.</span><br><span class="line">          executionContext = prevExecutionContext;</span><br><span class="line">          resetContextDependencies();</span><br><span class="line">          ReactCurrentDispatcher.current = prevDispatcher;</span><br><span class="line">          if (enableSchedulerTracing) &#123;</span><br><span class="line">            tracing.__interactionsRef.current = prevInteractions;</span><br><span class="line">          &#125;</span><br><span class="line">          return renderRoot.bind(null, root, currentTime);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Since we know we&apos;re in a React event, we can clear the current</span><br><span class="line">      // event time. The next update will compute a new event time.</span><br><span class="line">      currentEventTime = NoWork;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    do &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        console.log(</span><br><span class="line">          &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">          &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;workLoopSync&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos; +</span><br><span class="line">          &quot;isSync = &quot; + isSync</span><br><span class="line"></span><br><span class="line">        );</span><br><span class="line">        if (isSync) &#123;</span><br><span class="line">          workLoopSync();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          workLoop();</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">      &#125; catch (thrownValue) &#123;</span><br><span class="line">        // Reset module-level state that was set during the render phase.</span><br><span class="line">        resetContextDependencies();</span><br><span class="line">        resetHooks();</span><br><span class="line"></span><br><span class="line">        var sourceFiber = workInProgress;</span><br><span class="line">        if (sourceFiber === null || sourceFiber.return === null) &#123;</span><br><span class="line">          // Expected to be working on a non-root fiber. This is a fatal error</span><br><span class="line">          // because there&apos;s no ancestor that can handle it; the root is</span><br><span class="line">          // supposed to capture all errors that weren&apos;t caught by an error</span><br><span class="line">          // boundary.</span><br><span class="line">          prepareFreshStack(root, expirationTime);</span><br><span class="line">          executionContext = prevExecutionContext;</span><br><span class="line">          throw thrownValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (enableProfilerTimer &amp;&amp; sourceFiber.mode &amp; ProfileMode) &#123;</span><br><span class="line">          // Record the time spent rendering before an error was thrown. This</span><br><span class="line">          // avoids inaccurate Profiler durations in the case of a</span><br><span class="line">          // suspended render.</span><br><span class="line">          stopProfilerTimerIfRunningAndRecordDelta(sourceFiber, true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var returnFiber = sourceFiber.return;</span><br><span class="line">        throwException(</span><br><span class="line">          root,</span><br><span class="line">          returnFiber,</span><br><span class="line">          sourceFiber,</span><br><span class="line">          thrownValue,</span><br><span class="line">          renderExpirationTime</span><br><span class="line">        );</span><br><span class="line">        workInProgress = completeUnitOfWork(sourceFiber);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; while (true);</span><br><span class="line"></span><br><span class="line">    executionContext = prevExecutionContext;</span><br><span class="line">    resetContextDependencies();</span><br><span class="line">    ReactCurrentDispatcher.current = prevDispatcher;</span><br><span class="line">    if (enableSchedulerTracing) &#123;</span><br><span class="line">      tracing.__interactionsRef.current = prevInteractions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (workInProgress !== null) &#123;</span><br><span class="line">      // There&apos;s still work left over. Return a continuation.</span><br><span class="line">      stopInterruptedWorkLoopTimer();</span><br><span class="line">      if (expirationTime !== Sync) &#123;</span><br><span class="line">        startRequestCallbackTimer();</span><br><span class="line">      &#125;</span><br><span class="line">      return renderRoot.bind(null, root, expirationTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // We now have a consistent tree. The next step is either to commit it, or, if</span><br><span class="line">  // something suspended, wait to commit it after a timeout.</span><br><span class="line">  stopFinishedWorkLoopTimer();</span><br><span class="line"></span><br><span class="line">  root.finishedWork = root.current.alternate;</span><br><span class="line">  root.finishedExpirationTime = expirationTime;</span><br><span class="line"></span><br><span class="line">  var isLocked = resolveLocksOnRoot(root, expirationTime);</span><br><span class="line">  if (isLocked) &#123;</span><br><span class="line">    // This root has a lock that prevents it from committing. Exit. If we begin</span><br><span class="line">    // work on the root again, without any intervening updates, it will finish</span><br><span class="line">    // without doing additional work.</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Set this to null to indicate there&apos;s no in-progress render.</span><br><span class="line">  workInProgressRoot = null;</span><br><span class="line"></span><br><span class="line">  switch (workInProgressRootExitStatus) &#123;</span><br><span class="line">    case RootIncomplete: &#123;</span><br><span class="line">      (function () &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          throw ReactError(Error(&quot;Should have a work-in-progress.&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">    // Flow knows about invariant, so it complains if I add a break statement,</span><br><span class="line">    // but eslint doesn&apos;t know about invariant, so it complains if I do.</span><br><span class="line">    // eslint-disable-next-line no-fallthrough</span><br><span class="line">    case RootErrored: &#123;</span><br><span class="line">      // An error was thrown. First check if there is lower priority work</span><br><span class="line">      // scheduled on this root.</span><br><span class="line">      var _lastPendingTime = root.lastPendingTime;</span><br><span class="line">      if (_lastPendingTime &lt; expirationTime) &#123;</span><br><span class="line">        // There&apos;s lower priority work. Before raising the error, try rendering</span><br><span class="line">        // at the lower priority to see if it fixes it. Use a continuation to</span><br><span class="line">        // maintain the existing priority and position in the queue.</span><br><span class="line">        return renderRoot.bind(null, root, _lastPendingTime);</span><br><span class="line">      &#125;</span><br><span class="line">      if (!isSync) &#123;</span><br><span class="line">        // If we&apos;re rendering asynchronously, it&apos;s possible the error was</span><br><span class="line">        // caused by tearing due to a mutation during an event. Try rendering</span><br><span class="line">        // one more time without yiedling to events.</span><br><span class="line">        prepareFreshStack(root, expirationTime);</span><br><span class="line">        scheduleSyncCallback(renderRoot.bind(null, root, expirationTime));</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // If we&apos;re already rendering synchronously, commit the root in its</span><br><span class="line">      // errored state.</span><br><span class="line">      return commitRoot.bind(null, root);</span><br><span class="line">    &#125;</span><br><span class="line">    case RootSuspended: &#123;</span><br><span class="line">      flushSuspensePriorityWarningInDEV();</span><br><span class="line"></span><br><span class="line">      // We have an acceptable loading state. We need to figure out if we should</span><br><span class="line">      // immediately commit it or wait a bit.</span><br><span class="line"></span><br><span class="line">      // If we have processed new updates during this render, we may now have a</span><br><span class="line">      // new loading state ready. We want to ensure that we commit that as soon as</span><br><span class="line">      // possible.</span><br><span class="line">      var hasNotProcessedNewUpdates =</span><br><span class="line">        workInProgressRootLatestProcessedExpirationTime === Sync;</span><br><span class="line">      if (</span><br><span class="line">        hasNotProcessedNewUpdates &amp;&amp;</span><br><span class="line">        !isSync &amp;&amp;</span><br><span class="line">        // do not delay if we&apos;re inside an act() scope</span><br><span class="line">        !(true &amp;&amp; flushSuspenseFallbacksInTests &amp;&amp; IsThisRendererActing.current)</span><br><span class="line">      ) &#123;</span><br><span class="line">        // If we have not processed any new updates during this pass, then this is</span><br><span class="line">        // either a retry of an existing fallback state or a hidden tree.</span><br><span class="line">        // Hidden trees shouldn&apos;t be batched with other work and after that&apos;s</span><br><span class="line">        // fixed it can only be a retry.</span><br><span class="line">        // We&apos;re going to throttle committing retries so that we don&apos;t show too</span><br><span class="line">        // many loading states too quickly.</span><br><span class="line">        var msUntilTimeout =</span><br><span class="line">          globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();</span><br><span class="line">        // Don&apos;t bother with a very short suspense time.</span><br><span class="line">        if (msUntilTimeout &gt; 10) &#123;</span><br><span class="line">          if (workInProgressRootHasPendingPing) &#123;</span><br><span class="line">            // This render was pinged but we didn&apos;t get to restart earlier so try</span><br><span class="line">            // restarting now instead.</span><br><span class="line">            prepareFreshStack(root, expirationTime);</span><br><span class="line">            return renderRoot.bind(null, root, expirationTime);</span><br><span class="line">          &#125;</span><br><span class="line">          var _lastPendingTime2 = root.lastPendingTime;</span><br><span class="line">          if (_lastPendingTime2 &lt; expirationTime) &#123;</span><br><span class="line">            // There&apos;s lower priority work. It might be unsuspended. Try rendering</span><br><span class="line">            // at that level.</span><br><span class="line">            return renderRoot.bind(null, root, _lastPendingTime2);</span><br><span class="line">          &#125;</span><br><span class="line">          // The render is suspended, it hasn&apos;t timed out, and there&apos;s no lower</span><br><span class="line">          // priority work to do. Instead of committing the fallback</span><br><span class="line">          // immediately, wait for more data to arrive.</span><br><span class="line">          root.timeoutHandle = scheduleTimeout(</span><br><span class="line">            commitRoot.bind(null, root),</span><br><span class="line">            msUntilTimeout</span><br><span class="line">          );</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // The work expired. Commit immediately.</span><br><span class="line">      return commitRoot.bind(null, root);</span><br><span class="line">    &#125;</span><br><span class="line">    case RootSuspendedWithDelay: &#123;</span><br><span class="line">      flushSuspensePriorityWarningInDEV();</span><br><span class="line"></span><br><span class="line">      if (</span><br><span class="line">        !isSync &amp;&amp;</span><br><span class="line">        // do not delay if we&apos;re inside an act() scope</span><br><span class="line">        !(true &amp;&amp; flushSuspenseFallbacksInTests &amp;&amp; IsThisRendererActing.current)</span><br><span class="line">      ) &#123;</span><br><span class="line">        // We&apos;re suspended in a state that should be avoided. We&apos;ll try to avoid committing</span><br><span class="line">        // it for as long as the timeouts let us.</span><br><span class="line">        if (workInProgressRootHasPendingPing) &#123;</span><br><span class="line">          // This render was pinged but we didn&apos;t get to restart earlier so try</span><br><span class="line">          // restarting now instead.</span><br><span class="line">          prepareFreshStack(root, expirationTime);</span><br><span class="line">          return renderRoot.bind(null, root, expirationTime);</span><br><span class="line">        &#125;</span><br><span class="line">        var _lastPendingTime3 = root.lastPendingTime;</span><br><span class="line">        if (_lastPendingTime3 &lt; expirationTime) &#123;</span><br><span class="line">          // There&apos;s lower priority work. It might be unsuspended. Try rendering</span><br><span class="line">          // at that level immediately.</span><br><span class="line">          return renderRoot.bind(null, root, _lastPendingTime3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var _msUntilTimeout = void 0;</span><br><span class="line">        if (workInProgressRootLatestSuspenseTimeout !== Sync) &#123;</span><br><span class="line">          // We have processed a suspense config whose expiration time we can use as</span><br><span class="line">          // the timeout.</span><br><span class="line">          _msUntilTimeout =</span><br><span class="line">            expirationTimeToMs(workInProgressRootLatestSuspenseTimeout) - now();</span><br><span class="line">        &#125; else if (workInProgressRootLatestProcessedExpirationTime === Sync) &#123;</span><br><span class="line">          // This should never normally happen because only new updates cause</span><br><span class="line">          // delayed states, so we should have processed something. However,</span><br><span class="line">          // this could also happen in an offscreen tree.</span><br><span class="line">          _msUntilTimeout = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // If we don&apos;t have a suspense config, we&apos;re going to use a heuristic to</span><br><span class="line">          var eventTimeMs = inferTimeFromExpirationTime(</span><br><span class="line">            workInProgressRootLatestProcessedExpirationTime</span><br><span class="line">          );</span><br><span class="line">          var currentTimeMs = now();</span><br><span class="line">          var timeUntilExpirationMs =</span><br><span class="line">            expirationTimeToMs(expirationTime) - currentTimeMs;</span><br><span class="line">          var timeElapsed = currentTimeMs - eventTimeMs;</span><br><span class="line">          if (timeElapsed &lt; 0) &#123;</span><br><span class="line">            // We get this wrong some time since we estimate the time.</span><br><span class="line">            timeElapsed = 0;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          _msUntilTimeout = jnd(timeElapsed) - timeElapsed;</span><br><span class="line"></span><br><span class="line">          // Clamp the timeout to the expiration time.</span><br><span class="line">          // TODO: Once the event time is exact instead of inferred from expiration time</span><br><span class="line">          // we don&apos;t need this.</span><br><span class="line">          if (timeUntilExpirationMs &lt; _msUntilTimeout) &#123;</span><br><span class="line">            _msUntilTimeout = timeUntilExpirationMs;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Don&apos;t bother with a very short suspense time.</span><br><span class="line">        if (_msUntilTimeout &gt; 10) &#123;</span><br><span class="line">          // The render is suspended, it hasn&apos;t timed out, and there&apos;s no lower</span><br><span class="line">          // priority work to do. Instead of committing the fallback</span><br><span class="line">          // immediately, wait for more data to arrive.</span><br><span class="line">          root.timeoutHandle = scheduleTimeout(</span><br><span class="line">            commitRoot.bind(null, root),</span><br><span class="line">            _msUntilTimeout</span><br><span class="line">          );</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      // The work expired. Commit immediately.</span><br><span class="line">      return commitRoot.bind(null, root);</span><br><span class="line">    &#125;</span><br><span class="line">    case RootCompleted: &#123;</span><br><span class="line">      // The work completed. Ready to commit.</span><br><span class="line">      if (</span><br><span class="line">        !isSync &amp;&amp;</span><br><span class="line">        // do not delay if we&apos;re inside an act() scope</span><br><span class="line">        !(</span><br><span class="line">          true &amp;&amp;</span><br><span class="line">          flushSuspenseFallbacksInTests &amp;&amp;</span><br><span class="line">          IsThisRendererActing.current</span><br><span class="line">        ) &amp;&amp;</span><br><span class="line">        workInProgressRootLatestProcessedExpirationTime !== Sync &amp;&amp;</span><br><span class="line">        workInProgressRootCanSuspendUsingConfig !== null</span><br><span class="line">      ) &#123;</span><br><span class="line">        // If we have exceeded the minimum loading delay, which probably</span><br><span class="line">        // means we have shown a spinner already, we might have to suspend</span><br><span class="line">        // a bit longer to ensure that the spinner is shown for enough time.</span><br><span class="line">        var _msUntilTimeout2 = computeMsUntilSuspenseLoadingDelay(</span><br><span class="line">          workInProgressRootLatestProcessedExpirationTime,</span><br><span class="line">          expirationTime,</span><br><span class="line">          workInProgressRootCanSuspendUsingConfig</span><br><span class="line">        );</span><br><span class="line">        if (_msUntilTimeout2 &gt; 10) &#123;</span><br><span class="line">          root.timeoutHandle = scheduleTimeout(</span><br><span class="line">            commitRoot.bind(null, root),</span><br><span class="line">            _msUntilTimeout2</span><br><span class="line">          );</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return commitRoot.bind(null, root);</span><br><span class="line">    &#125;</span><br><span class="line">    default: &#123;</span><br><span class="line">      (function () &#123;</span><br><span class="line">        &#123;</span><br><span class="line">          throw ReactError(Error(&quot;Unknown root exit status.&quot;));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prepareFreshStack"><a href="#prepareFreshStack" class="headerlink" title="prepareFreshStack"></a>prepareFreshStack</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function prepareFreshStack(root, expirationTime) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;prepareFreshStack&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  root.finishedWork = null;</span><br><span class="line">  root.finishedExpirationTime = NoWork;</span><br><span class="line"></span><br><span class="line">  var timeoutHandle = root.timeoutHandle;</span><br><span class="line">  if (timeoutHandle !== noTimeout) &#123;</span><br><span class="line">    // The root previous suspended and scheduled a timeout to commit a fallback</span><br><span class="line">    // state. Now that we have additional work, cancel the timeout.</span><br><span class="line">    root.timeoutHandle = noTimeout;</span><br><span class="line">    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above</span><br><span class="line">    cancelTimeout(timeoutHandle);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (workInProgress !== null) &#123;</span><br><span class="line">    var interruptedWork = workInProgress.return;</span><br><span class="line">    while (interruptedWork !== null) &#123;</span><br><span class="line">      unwindInterruptedWork(interruptedWork);</span><br><span class="line">      interruptedWork = interruptedWork.return;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 设置当前渲染的工作的流程的节点是ROOT</span><br><span class="line">  workInProgressRoot = root;</span><br><span class="line">  workInProgress = createWorkInProgress(root.current, null, expirationTime);</span><br><span class="line">  renderExpirationTime = expirationTime;</span><br><span class="line">  workInProgressRootExitStatus = RootIncomplete;</span><br><span class="line">  workInProgressRootLatestProcessedExpirationTime = Sync;</span><br><span class="line">  workInProgressRootLatestSuspenseTimeout = Sync;</span><br><span class="line">  workInProgressRootCanSuspendUsingConfig = null;</span><br><span class="line">  workInProgressRootHasPendingPing = false;</span><br><span class="line"></span><br><span class="line">  if (enableSchedulerTracing) &#123;</span><br><span class="line">    spawnedWorkDuringRender = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    ReactStrictModeWarnings.discardPendingWarnings();</span><br><span class="line">    componentsThatTriggeredHighPriSuspend = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法最重要的就是就是createWorkInProgress就是创建渲染流程的当前节点。首先，我们将当前的节点设置为root节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">// This is used to create an alternate fiber to do work on.</span><br><span class="line">function createWorkInProgress(current, pendingProps, expirationTime) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;createWorkInProgress&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  var workInProgress = current.alternate;</span><br><span class="line">  if (workInProgress === null) &#123;</span><br><span class="line">    // We use a double buffering pooling technique because we know that we&apos;ll</span><br><span class="line">    // only ever need at most two versions of a tree. We pool the &quot;other&quot; unused</span><br><span class="line">    // node that we&apos;re free to reuse. This is lazily created to avoid allocating</span><br><span class="line">    // extra objects for things that are never updated. It also allow us to</span><br><span class="line">    // reclaim the extra memory if needed.</span><br><span class="line">    workInProgress = createFiber(</span><br><span class="line">      current.tag,</span><br><span class="line">      pendingProps,</span><br><span class="line">      current.key,</span><br><span class="line">      current.mode</span><br><span class="line">    );</span><br><span class="line">    workInProgress.elementType = current.elementType;</span><br><span class="line">    workInProgress.type = current.type;</span><br><span class="line">    workInProgress.stateNode = current.stateNode;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      // DEV-only fields</span><br><span class="line">      workInProgress._debugID = current._debugID;</span><br><span class="line">      workInProgress._debugSource = current._debugSource;</span><br><span class="line">      workInProgress._debugOwner = current._debugOwner;</span><br><span class="line">      workInProgress._debugHookTypes = current._debugHookTypes;</span><br><span class="line">    &#125;</span><br><span class="line">    // 这个代码需要注意下</span><br><span class="line">    workInProgress.alternate = current;</span><br><span class="line">    current.alternate = workInProgress;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    workInProgress.pendingProps = pendingProps;</span><br><span class="line"></span><br><span class="line">    // We already have an alternate.</span><br><span class="line">    // Reset the effect tag.</span><br><span class="line">    workInProgress.effectTag = NoEffect;</span><br><span class="line"></span><br><span class="line">    // The effect list is no longer valid.</span><br><span class="line">    workInProgress.nextEffect = null;</span><br><span class="line">    workInProgress.firstEffect = null;</span><br><span class="line">    workInProgress.lastEffect = null;</span><br><span class="line"></span><br><span class="line">    if (enableProfilerTimer) &#123;</span><br><span class="line">      // We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.</span><br><span class="line">      // This prevents time from endlessly accumulating in new commits.</span><br><span class="line">      // This has the downside of resetting values for different priority renders,</span><br><span class="line">      // But works for yielding (the common case) and should support resuming.</span><br><span class="line">      workInProgress.actualDuration = 0;</span><br><span class="line">      workInProgress.actualStartTime = -1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  workInProgress.childExpirationTime = current.childExpirationTime;</span><br><span class="line">  workInProgress.expirationTime = current.expirationTime;</span><br><span class="line"></span><br><span class="line">  workInProgress.child = current.child;</span><br><span class="line">  workInProgress.memoizedProps = current.memoizedProps;</span><br><span class="line">  workInProgress.memoizedState = current.memoizedState;</span><br><span class="line">  workInProgress.updateQueue = current.updateQueue;</span><br><span class="line"></span><br><span class="line">  // Clone the dependencies object. This is mutated during the render phase, so</span><br><span class="line">  // it cannot be shared with the current fiber.</span><br><span class="line">  var currentDependencies = current.dependencies;</span><br><span class="line">  workInProgress.dependencies =</span><br><span class="line">    currentDependencies === null</span><br><span class="line">      ? null</span><br><span class="line">      : &#123;</span><br><span class="line">        expirationTime: currentDependencies.expirationTime,</span><br><span class="line">        firstContext: currentDependencies.firstContext,</span><br><span class="line">        responders: currentDependencies.responders</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  // These will be overridden during the parent&apos;s reconciliation</span><br><span class="line">  workInProgress.sibling = current.sibling;</span><br><span class="line">  workInProgress.index = current.index;</span><br><span class="line">  workInProgress.ref = current.ref;</span><br><span class="line"></span><br><span class="line">  if (enableProfilerTimer) &#123;</span><br><span class="line">    workInProgress.selfBaseDuration = current.selfBaseDuration;</span><br><span class="line">    workInProgress.treeBaseDuration = current.treeBaseDuration;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    workInProgress._debugNeedsRemount = current._debugNeedsRemount;</span><br><span class="line">    switch (workInProgress.tag) &#123;</span><br><span class="line">      case IndeterminateComponent:</span><br><span class="line">      case FunctionComponent:</span><br><span class="line">      case SimpleMemoComponent:</span><br><span class="line">        workInProgress.type = resolveFunctionForHotReloading(current.type);</span><br><span class="line">        break;</span><br><span class="line">      case ClassComponent:</span><br><span class="line">        workInProgress.type = resolveClassForHotReloading(current.type);</span><br><span class="line">        break;</span><br><span class="line">      case ForwardRef:</span><br><span class="line">        workInProgress.type = resolveForwardRefForHotReloading(current.type);</span><br><span class="line">        break;</span><br><span class="line">      default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return workInProgress;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们用于当前刷新的节点，基本已经准备好了。<br>我们来看一下这个workINProgress的节点的信息</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://i.loli.net/2020/04/07/OIrLAZ8x5y2St64.jpg"  alt="-w537"></p><p>这个方法里面，我们需要着重的看一下workLoopSync的这个方法。 </p><p>这个方法会进行队列的遍历。会依次取出我们的View树中所有的Element进行调用对应的生命周期方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    console.log(</span><br><span class="line">      &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">      &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;workLoopSync&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos; +</span><br><span class="line">      &quot;isSync = &quot; + isSync</span><br><span class="line"></span><br><span class="line">    );</span><br><span class="line">    if (isSync) &#123;</span><br><span class="line">      workLoopSync();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      workLoop();</span><br><span class="line">    &#125;</span><br><span class="line">    break;</span><br><span class="line">  &#125; catch (thrownValue) &#123;</span><br><span class="line">    // Reset module-level state that was set during the render phase.</span><br><span class="line">    resetContextDependencies();</span><br><span class="line">    resetHooks();</span><br><span class="line"></span><br><span class="line">    var sourceFiber = workInProgress;</span><br><span class="line">    if (sourceFiber === null || sourceFiber.return === null) &#123;</span><br><span class="line">      // Expected to be working on a non-root fiber. This is a fatal error</span><br><span class="line">      // because there&apos;s no ancestor that can handle it; the root is</span><br><span class="line">      // supposed to capture all errors that weren&apos;t caught by an error</span><br><span class="line">      // boundary.</span><br><span class="line">      prepareFreshStack(root, expirationTime);</span><br><span class="line">      executionContext = prevExecutionContext;</span><br><span class="line">      throw thrownValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (enableProfilerTimer &amp;&amp; sourceFiber.mode &amp; ProfileMode) &#123;</span><br><span class="line">      // Record the time spent rendering before an error was thrown. This</span><br><span class="line">      // avoids inaccurate Profiler durations in the case of a</span><br><span class="line">      // suspended render.</span><br><span class="line">      stopProfilerTimerIfRunningAndRecordDelta(sourceFiber, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var returnFiber = sourceFiber.return;</span><br><span class="line">    throwException(</span><br><span class="line">      root,</span><br><span class="line">      returnFiber,</span><br><span class="line">      sourceFiber,</span><br><span class="line">      thrownValue,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">    workInProgress = completeUnitOfWork(sourceFiber);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; while (true);</span><br></pre></td></tr></table></figure><p>我们来分析一下workLoopSync这个方法</p><h3 id="workLoopSync调用"><a href="#workLoopSync调用" class="headerlink" title="workLoopSync调用"></a>workLoopSync调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这是一个循环队列算法的调度</span><br><span class="line"> */</span><br><span class="line">function workLoopSync() &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;workLoopSync&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  // Already timed out, so perform work without checking if we need to yield.</span><br><span class="line">  while (workInProgress !== null) &#123;</span><br><span class="line">    workInProgress = performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加入到队列中。执行当前刷新的节点的相关逻辑。</p><h3 id="performUnitOfWork调用"><a href="#performUnitOfWork调用" class="headerlink" title="performUnitOfWork调用"></a>performUnitOfWork调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 调用beginWork方法，</span><br><span class="line"> * 生成FiberNode的workInProgress，即current.alternate。</span><br><span class="line"> * @param &#123;*&#125; unitOfWork </span><br><span class="line"> */</span><br><span class="line">function performUnitOfWork(unitOfWork) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;performUnitOfWork&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  // The current, flushed, state of this fiber is the alternate. Ideally</span><br><span class="line">  // nothing should rely on this, but relying on it here means that we don&apos;t</span><br><span class="line">  // need an additional field on the work in progress.</span><br><span class="line">  var current$$1 = unitOfWork.alternate;</span><br><span class="line"></span><br><span class="line">  startWorkTimer(unitOfWork);</span><br><span class="line">  setCurrentFiber(unitOfWork);</span><br><span class="line">  </span><br><span class="line">  var next = void 0;</span><br><span class="line">  if (enableProfilerTimer &amp;&amp; (unitOfWork.mode &amp; ProfileMode) !== NoMode) &#123;</span><br><span class="line">    startProfilerTimer(unitOfWork);</span><br><span class="line">    next = beginWork$$1(current$$1, unitOfWork, renderExpirationTime);</span><br><span class="line">    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    next = beginWork$$1(current$$1, unitOfWork, renderExpirationTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  resetCurrentFiber();</span><br><span class="line">  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span><br><span class="line">  // 这个地方我们的逻辑可以梳理一下。当上面的深度优先的算法，一直到最终的叶子节点</span><br><span class="line">  // next的节点为null 的时候。</span><br><span class="line">  if (next === null) &#123;</span><br><span class="line">    // If this doesn&apos;t spawn new work, complete the current work.</span><br><span class="line">    // 我可以知道，这个方法最终返回的应该是当前节点的兄弟节点</span><br><span class="line">    next = completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactCurrentOwner$2.current = null;</span><br><span class="line">  return next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的逻辑，我们可以知道他其实调用beginWork$$1的方法。</p><h3 id="beginWork-1-调用"><a href="#beginWork-1-调用" class="headerlink" title="beginWork$$1 调用"></a>beginWork$$1 调用</h3><p>我们来看一下beginWork$$1的方法的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">beginWork$$1 = function(current$$1, unitOfWork, expirationTime) &#123;</span><br><span class="line">    // If a component throws an error, we replay it again in a synchronously</span><br><span class="line">    // dispatched event, so that the debugger will treat it as an uncaught</span><br><span class="line">    // error See ReactErrorUtils for more information.</span><br><span class="line"></span><br><span class="line">    // Before entering the begin phase, copy the work-in-progress onto a dummy</span><br><span class="line">    // fiber. If beginWork throws, we&apos;ll use this to reset the state.</span><br><span class="line">    var originalWorkInProgressCopy = assignFiberPropertiesInDEV(</span><br><span class="line">      dummyFiber,</span><br><span class="line">      unitOfWork</span><br><span class="line">    );</span><br><span class="line">    try &#123;</span><br><span class="line">      return beginWork$1(current$$1, unitOfWork, expirationTime);</span><br><span class="line">    &#125; catch (originalError) &#123;</span><br><span class="line">      if (</span><br><span class="line">        originalError !== null &amp;&amp;</span><br><span class="line">        typeof originalError === &quot;object&quot; &amp;&amp;</span><br><span class="line">        typeof originalError.then === &quot;function&quot;</span><br><span class="line">      ) &#123;</span><br><span class="line">        // Don&apos;t replay promises. Treat everything else like an error.</span><br><span class="line">        throw originalError;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Keep this code in sync with renderRoot; any changes here must have</span><br><span class="line">      // corresponding changes there.</span><br><span class="line">      resetContextDependencies();</span><br><span class="line">      resetHooks();</span><br><span class="line"></span><br><span class="line">      // Unwind the failed stack frame</span><br><span class="line">      unwindInterruptedWork(unitOfWork);</span><br><span class="line"></span><br><span class="line">      // Restore the original properties of the fiber.</span><br><span class="line">      assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);</span><br><span class="line"></span><br><span class="line">      if (enableProfilerTimer &amp;&amp; unitOfWork.mode &amp; ProfileMode) &#123;</span><br><span class="line">        // Reset the profiler timer.</span><br><span class="line">        startProfilerTimer(unitOfWork);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // Run beginWork again.</span><br><span class="line">      invokeGuardedCallback(</span><br><span class="line">        null,</span><br><span class="line">        beginWork$1,</span><br><span class="line">        null,</span><br><span class="line">        current$$1,</span><br><span class="line">        unitOfWork,</span><br><span class="line">        expirationTime</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      if (hasCaughtError()) &#123;</span><br><span class="line">        var replayError = clearCaughtError();</span><br><span class="line">        // `invokeGuardedCallback` sometimes sets an expando `_suppressLogging`.</span><br><span class="line">        // Rethrow this error instead of the original one.</span><br><span class="line">        throw replayError;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // This branch is reachable if the render phase is impure.</span><br><span class="line">        throw originalError;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>从代码追溯，我们可以看到这个方法调用的</p><h3 id="beginWork-1调用"><a href="#beginWork-1调用" class="headerlink" title="beginWork$1调用"></a>beginWork$1调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 进行Class组件的节点的更新</span><br><span class="line"> * ClassComponent，即我们在写React代码的时候自己写的Component，即例子中的App</span><br><span class="line"> * @param &#123;*&#125; current$$1 </span><br><span class="line"> * @param &#123;*&#125; workInProgress </span><br><span class="line"> * @param &#123;*&#125; Component </span><br><span class="line"> * @param &#123;*&#125; nextProps </span><br><span class="line"> * @param &#123;*&#125; renderExpirationTime </span><br><span class="line"> */</span><br><span class="line">function updateClassComponent(</span><br><span class="line">  current$$1,</span><br><span class="line">  workInProgress,</span><br><span class="line">  Component,</span><br><span class="line">  nextProps,</span><br><span class="line">  renderExpirationTime</span><br><span class="line">) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    if (workInProgress.type !== workInProgress.elementType) &#123;</span><br><span class="line">      // Lazy component props can&apos;t be validated in createElement</span><br><span class="line">      // because they&apos;re only guaranteed to be resolved here.</span><br><span class="line">      var innerPropTypes = Component.propTypes;</span><br><span class="line">      if (innerPropTypes) &#123;</span><br><span class="line">        checkPropTypes(</span><br><span class="line">          innerPropTypes,</span><br><span class="line">          nextProps, // Resolved props</span><br><span class="line">          &quot;prop&quot;,</span><br><span class="line">          getComponentName(Component),</span><br><span class="line">          getCurrentFiberStackInDev</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Push context providers early to prevent context stack mismatches.</span><br><span class="line">  // During mounting we don&apos;t know the child context yet as the instance doesn&apos;t exist.</span><br><span class="line">  // We will invalidate the child context in finishClassComponent() right after rendering.</span><br><span class="line">  var hasContext = void 0;</span><br><span class="line">  if (isContextProvider(Component)) &#123;</span><br><span class="line">    hasContext = true;</span><br><span class="line">    pushContextProvider(workInProgress);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    hasContext = false;</span><br><span class="line">  &#125;</span><br><span class="line">  prepareToReadContext(workInProgress, renderExpirationTime);</span><br><span class="line">  //FiberNode会通过stateNode绑定一些其他的对象，例如ReactComponent实例</span><br><span class="line">  var instance = workInProgress.stateNode;</span><br><span class="line">  var shouldUpdate = void 0;</span><br><span class="line">  if (instance === null) &#123;</span><br><span class="line">    if (current$$1 !== null) &#123;</span><br><span class="line">      // An class component without an instance only mounts if it suspended</span><br><span class="line">      // inside a non- concurrent tree, in an inconsistent state. We want to</span><br><span class="line">      // tree it like a new mount, even though an empty version of it already</span><br><span class="line">      // committed. Disconnect the alternate pointers.</span><br><span class="line">      current$$1.alternate = null;</span><br><span class="line">      workInProgress.alternate = null;</span><br><span class="line">      // Since this is conceptually a new fiber, schedule a Placement effect</span><br><span class="line">      workInProgress.effectTag |= Placement;</span><br><span class="line">    &#125;</span><br><span class="line">    // In the initial pass we might need to construct the instance.</span><br><span class="line">    // 进行ClassComponent的组件实例的构造</span><br><span class="line">    constructClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">    // 进行ClassComponent的组件的componentWillMount</span><br><span class="line">    mountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">    shouldUpdate = true;</span><br><span class="line">  &#125; else if (current$$1 === null) &#123;</span><br><span class="line">    // In a resume, we&apos;ll already have an instance we can reuse.</span><br><span class="line">    shouldUpdate = resumeMountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    shouldUpdate = updateClassInstance(</span><br><span class="line">      current$$1,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderExpirationTime</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  var nextUnitOfWork = finishClassComponent(</span><br><span class="line">    current$$1,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderExpirationTime</span><br><span class="line">  );</span><br><span class="line">  &#123;</span><br><span class="line">    var inst = workInProgress.stateNode;</span><br><span class="line">    if (inst.props !== nextProps) &#123;</span><br><span class="line">      !didWarnAboutReassigningProps</span><br><span class="line">        ? warning$1(</span><br><span class="line">            false,</span><br><span class="line">            &quot;It looks like %s is reassigning its own `this.props` while rendering. &quot; +</span><br><span class="line">              &quot;This is not supported and can lead to confusing bugs.&quot;,</span><br><span class="line">            getComponentName(workInProgress.type) || &quot;a component&quot;</span><br><span class="line">          )</span><br><span class="line">        : void 0;</span><br><span class="line">      didWarnAboutReassigningProps = true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return nextUnitOfWork;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的ReactNative的生命周期基本都是在这里面完成</p><h3 id="completeUnitOfWork调用-单个节点树的完成"><a href="#completeUnitOfWork调用-单个节点树的完成" class="headerlink" title="completeUnitOfWork调用 单个节点树的完成"></a>completeUnitOfWork调用 单个节点树的完成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function completeUnitOfWork(unitOfWork) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;completeUnitOfWork&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;完成组件队列处理&apos;</span><br><span class="line">  );</span><br><span class="line">  // Attempt to complete the current unit of work, then move to the next</span><br><span class="line">  // sibling. If there are no more siblings, return to the parent fiber.</span><br><span class="line">  workInProgress = unitOfWork;</span><br><span class="line"></span><br><span class="line">    // ···········省略部分代码</span><br><span class="line">    </span><br><span class="line">    // 这个地方，我们返回的是当前任务节点的兄弟节点</span><br><span class="line">    var siblingFiber = workInProgress.sibling;</span><br><span class="line">    if (siblingFiber !== null) &#123;</span><br><span class="line">      // If there is more work to do in this returnFiber, do that next.</span><br><span class="line">      return siblingFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    // Otherwise, return to the parent</span><br><span class="line">    workInProgress = returnFiber;</span><br><span class="line">  &#125; while (workInProgress !== null);</span><br><span class="line"></span><br><span class="line">  // We&apos;ve reached the root.</span><br><span class="line">  if (workInProgressRootExitStatus === RootIncomplete) &#123;</span><br><span class="line">    workInProgressRootExitStatus = RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当单个空间树都遍历完成之后，最终方法其实调用到commitRoot</p><h3 id="commitRoot的调用"><a href="#commitRoot的调用" class="headerlink" title="commitRoot的调用"></a>commitRoot的调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * root节点渲染提交</span><br><span class="line"> * @param &#123;&#125; root </span><br><span class="line"> */</span><br><span class="line">function commitRoot(root) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;commitRoot&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;</span><br><span class="line">  );</span><br><span class="line">  var renderPriorityLevel = getCurrentPriorityLevel();</span><br><span class="line">  // 我们按照由优先级的调度，去执行commitRootImpl</span><br><span class="line">  runWithPriority(</span><br><span class="line">    ImmediatePriority,</span><br><span class="line">    commitRootImpl.bind(null, root, renderPriorityLevel)</span><br><span class="line">  );</span><br><span class="line">  // If there are passive effects, schedule a callback to flush them. This goes</span><br><span class="line">  // outside commitRootImpl so that it inherits the priority of the render.</span><br><span class="line">  if (rootWithPendingPassiveEffects !== null) &#123;</span><br><span class="line">    scheduleCallback(NormalPriority, function () &#123;</span><br><span class="line">      flushPassiveEffects();</span><br><span class="line">      return null;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitRootImpl的调用"><a href="#commitRootImpl的调用" class="headerlink" title="commitRootImpl的调用"></a>commitRootImpl的调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 我们来进行组件的提交</span><br><span class="line">       do &#123;</span><br><span class="line">         &#123;</span><br><span class="line">           invokeGuardedCallback(</span><br><span class="line">             null,</span><br><span class="line">             commitLayoutEffects,</span><br><span class="line">             null,</span><br><span class="line">             root,</span><br><span class="line">             expirationTime</span><br><span class="line">           );</span><br><span class="line">           if (hasCaughtError()) &#123;</span><br><span class="line">             (function () &#123;</span><br><span class="line">               if (!(nextEffect !== null)) &#123;</span><br><span class="line">                 throw ReactError(Error(&quot;Should be working on an effect.&quot;));</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;)();</span><br><span class="line">             var _error2 = clearCaughtError();</span><br><span class="line">             captureCommitPhaseError(nextEffect, _error2);</span><br><span class="line">             nextEffect = nextEffect.nextEffect;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125; while (nextEffect !== null);</span><br></pre></td></tr></table></figure><p>这个时候开始进行反向的组件的渲染流程。进行componentDidMount的方法的回调</p><h3 id="commitLayoutEffects的调用"><a href="#commitLayoutEffects的调用" class="headerlink" title="commitLayoutEffects的调用"></a>commitLayoutEffects的调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">function commitLayoutEffects(root, committedExpirationTime) &#123;</span><br><span class="line">  // TODO: Should probably move the bulk of this function to commitWork.</span><br><span class="line">  while (nextEffect !== null) &#123;</span><br><span class="line">    setCurrentFiber(nextEffect);</span><br><span class="line"></span><br><span class="line">    var effectTag = nextEffect.effectTag;</span><br><span class="line"></span><br><span class="line">    if (effectTag &amp; (Update | Callback)) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      var current$$1 = nextEffect.alternate;</span><br><span class="line">      // 进行组件生命周期的提交</span><br><span class="line">      commitLifeCycles(root, current$$1, nextEffect, committedExpirationTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (effectTag &amp; Ref) &#123;</span><br><span class="line">      recordEffect();</span><br><span class="line">      commitAttachRef(nextEffect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (effectTag &amp; Passive) &#123;</span><br><span class="line">      rootDoesHavePassiveEffects = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resetCurrentFiber();</span><br><span class="line">    nextEffect = nextEffect.nextEffect;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="commitLifeCycles-方法的调用"><a href="#commitLifeCycles-方法的调用" class="headerlink" title="commitLifeCycles()方法的调用"></a>commitLifeCycles()方法的调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function commitLifeCycles(</span><br><span class="line">  finishedRoot,</span><br><span class="line">  current$$1,</span><br><span class="line">  finishedWork,</span><br><span class="line">  committedExpirationTime</span><br><span class="line">) &#123;</span><br><span class="line">  switch (finishedWork.tag) &#123;</span><br><span class="line">    case FunctionComponent:</span><br><span class="line">    case ForwardRef:</span><br><span class="line">    case SimpleMemoComponent: &#123;</span><br><span class="line">      commitHookEffectList(UnmountLayout, MountLayout, finishedWork);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    case ClassComponent: &#123;</span><br><span class="line">      // 我们主要看看ClassComponent的组件的提交</span><br><span class="line">      var instance = finishedWork.stateNode;</span><br><span class="line">      if (finishedWork.effectTag &amp; Update) &#123;</span><br><span class="line">        if (current$$1 === null) &#123;</span><br><span class="line">          startPhaseTimer(finishedWork, &quot;componentDidMount&quot;);</span><br><span class="line">          // We could update instance props and state here,</span><br><span class="line">          // but instead we rely on them being set during last render.</span><br><span class="line">          // TODO: revisit this when we implement resuming.</span><br><span class="line">          &#123;</span><br><span class="line">            if (</span><br><span class="line">              finishedWork.type === finishedWork.elementType &amp;&amp;</span><br><span class="line">              !didWarnAboutReassigningProps</span><br><span class="line">            ) &#123;</span><br><span class="line">              !(instance.props === finishedWork.memoizedProps)</span><br><span class="line">                ? warning$1(</span><br><span class="line">                  false,</span><br><span class="line">                  &quot;Expected %s props to match memoized props before &quot; +</span><br><span class="line">                  &quot;componentDidMount. &quot; +</span><br><span class="line">                  &quot;This might either be because of a bug in React, or because &quot; +</span><br><span class="line">                  &quot;a component reassigns its own `this.props`. &quot; +</span><br><span class="line">                  &quot;Please file an issue.&quot;,</span><br><span class="line">                  getComponentName(finishedWork.type) || &quot;instance&quot;</span><br><span class="line">                )</span><br><span class="line">                : void 0;</span><br><span class="line">              !(instance.state === finishedWork.memoizedState)</span><br><span class="line">                ? warning$1(</span><br><span class="line">                  false,</span><br><span class="line">                  &quot;Expected %s state to match memoized state before &quot; +</span><br><span class="line">                  &quot;componentDidMount. &quot; +</span><br><span class="line">                  &quot;This might either be because of a bug in React, or because &quot; +</span><br><span class="line">                  &quot;a component reassigns its own `this.props`. &quot; +</span><br><span class="line">                  &quot;Please file an issue.&quot;,</span><br><span class="line">                  getComponentName(finishedWork.type) || &quot;instance&quot;</span><br><span class="line">                )</span><br><span class="line">                : void 0;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          // 调用组件实例的componentDidMount</span><br><span class="line">          instance.componentDidMount();</span><br><span class="line">          stopPhaseTimer();</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="completeUnitOfWorkde调用"><a href="#completeUnitOfWorkde调用" class="headerlink" title="completeUnitOfWorkde调用"></a>completeUnitOfWorkde调用</h3><p>我们继续回到completeUnitOfWorkde的方法调用逻辑中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">if (</span><br><span class="line">           returnFiber !== null &amp;&amp;</span><br><span class="line">           // Do not append effects to parents if a sibling failed to complete</span><br><span class="line">           (returnFiber.effectTag &amp; Incomplete) === NoEffect</span><br><span class="line">         ) &#123;</span><br><span class="line">           // Append all the effects of the subtree and this fiber onto the effect</span><br><span class="line">           // list of the parent. The completion order of the children affects the</span><br><span class="line">           // side-effect order.</span><br><span class="line">           if (returnFiber.firstEffect === null) &#123;</span><br><span class="line">             returnFiber.firstEffect = workInProgress.firstEffect;</span><br><span class="line">           &#125;</span><br><span class="line">           if (workInProgress.lastEffect !== null) &#123;</span><br><span class="line">             if (returnFiber.lastEffect !== null) &#123;</span><br><span class="line">               returnFiber.lastEffect.nextEffect = workInProgress.firstEffect;</span><br><span class="line">             &#125;</span><br><span class="line">             returnFiber.lastEffect = workInProgress.lastEffect;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // If this fiber had side-effects, we append it AFTER the children&apos;s</span><br><span class="line">           // side-effects. We can perform certain side-effects earlier if needed,</span><br><span class="line">           // by doing multiple passes over the effect list. We don&apos;t want to</span><br><span class="line">           // schedule our own side-effect on our own list because if end up</span><br><span class="line">           // reusing children we&apos;ll schedule this effect onto itself since we&apos;re</span><br><span class="line">           // at the end.</span><br><span class="line">           var effectTag = workInProgress.effectTag;</span><br><span class="line"></span><br><span class="line">           // Skip both NoWork and PerformedWork tags when creating the effect</span><br><span class="line">           // list. PerformedWork effect is read by React DevTools but shouldn&apos;t be</span><br><span class="line">           // committed.</span><br><span class="line">           if (effectTag &gt; PerformedWork) &#123;</span><br><span class="line">             if (returnFiber.lastEffect !== null) &#123;</span><br><span class="line">               returnFiber.lastEffect.nextEffect = workInProgress;</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">               returnFiber.firstEffect = workInProgress;</span><br><span class="line">             &#125;</span><br><span class="line">             returnFiber.lastEffect = workInProgress;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>当前节点的所有子节点都遍历完成之后，会调用completeWork这个方法</p><h3 id="completeWork节点的调用。"><a href="#completeWork节点的调用。" class="headerlink" title="completeWork节点的调用。"></a>completeWork节点的调用。</h3><p>我们继续看这个方法下面，回调调用的当前的父节点的兄弟节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">console.log(</span><br><span class="line">             &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">             &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;createInstance begin&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;,type</span><br><span class="line">           );</span><br><span class="line">           var _instance6 = createInstance(</span><br><span class="line">             type,</span><br><span class="line">             newProps,</span><br><span class="line">             rootContainerInstance,</span><br><span class="line">             currentHostContext,</span><br><span class="line">             workInProgress</span><br><span class="line">           );</span><br></pre></td></tr></table></figure><h3 id="createInstance调用"><a href="#createInstance调用" class="headerlink" title="createInstance调用"></a>createInstance调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">function createInstance(</span><br><span class="line">  type,</span><br><span class="line">  props,</span><br><span class="line">  rootContainerInstance,</span><br><span class="line">  hostContext,</span><br><span class="line">  internalInstanceHandle</span><br><span class="line">) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;createInstance&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;, type</span><br><span class="line">  );</span><br><span class="line">  var tag = allocateTag();</span><br><span class="line">  var viewConfig = getViewConfigForType(type);</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    // 属性的处理</span><br><span class="line">    for (var key in viewConfig.validAttributes) &#123;</span><br><span class="line">      if (props.hasOwnProperty(key)) &#123;</span><br><span class="line">        ReactNativePrivateInterface.deepFreezeAndThrowOnMutationInDev(</span><br><span class="line">          props[key]</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var updatePayload = create(props, viewConfig.validAttributes);</span><br><span class="line">  console.log(</span><br><span class="line">    &apos;ReactNativeRender-dev.js&apos;,</span><br><span class="line">    &apos;FMsg:&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;UIManager.createView&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&apos;, viewConfig.uiViewClassName</span><br><span class="line">  );</span><br><span class="line">  ReactNativePrivateInterface.UIManager.createView(</span><br><span class="line">    tag, // reactTag</span><br><span class="line">    viewConfig.uiViewClassName, // viewName</span><br><span class="line">    rootContainerInstance, // rootTag</span><br><span class="line">    updatePayload // props</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  var component = new ReactNativeFiberHostComponent(tag, viewConfig);</span><br><span class="line"></span><br><span class="line">  precacheFiberNode(internalInstanceHandle, tag);</span><br><span class="line">  updateFiberProps(tag, props);</span><br><span class="line"></span><br><span class="line">  // Not sure how to avoid this cast. Flow is okay if the component is defined</span><br><span class="line">  // in the same file but if it&apos;s external it can&apos;t see the types.</span><br><span class="line">  return component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们可以看到ReactNativePrivateInterface.UIManager.createView() 这个就调用到原生组件的UIManager的createView的方法里面。关于怎么调用到Java那边。这个我们在ReactNative的通信机制里面会讲到。所以这里我们直接到Java那边。</p><p>我们直接看Java那边的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ReactMethod</span><br><span class="line">public void createView(int tag, String className, int rootViewTag, ReadableMap props) &#123;</span><br><span class="line">  if (DEBUG) &#123;</span><br><span class="line">    String message =</span><br><span class="line">            &quot;(UIManager.createView) tag: &quot; + tag + &quot;, class: &quot; + className + &quot;, props: &quot; + props;</span><br><span class="line">    FLog.d(ReactConstants.TAG, message);</span><br><span class="line">    PrinterHolder.getPrinter().logMessage(ReactDebugOverlayTags.UI_MANAGER, message);</span><br><span class="line">  &#125;</span><br><span class="line">  mUIImplementation.createView(tag, className, rootViewTag, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/** Invoked by React to create a new node with a given tag, class name and properties. */</span><br><span class="line">public void createView(int tag, String className, int rootViewTag, ReadableMap props) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:UI渲染流程第二步(2)：createView() called with: tag = [&quot; + tag + &quot;], className = [&quot; + className + &quot;], rootViewTag = [&quot; + rootViewTag + &quot;], props = [&quot; + props + &quot;]&quot;);</span><br><span class="line">  synchronized (uiImplementationThreadLock) &#123;</span><br><span class="line">    ReactShadowNode cssNode = createShadowNode(className);</span><br><span class="line">    ReactShadowNode rootNode = mShadowNodeRegistry.getNode(rootViewTag);</span><br><span class="line">    Assertions.assertNotNull(rootNode, &quot;Root node with tag &quot; + rootViewTag + &quot; doesn&apos;t exist&quot;);</span><br><span class="line">    cssNode.setReactTag(tag); // Thread safety needed here</span><br><span class="line">    cssNode.setViewClassName(className);</span><br><span class="line">    cssNode.setRootTag(rootNode.getReactTag());</span><br><span class="line">    cssNode.setThemedContext(rootNode.getThemedContext());</span><br><span class="line"></span><br><span class="line">    mShadowNodeRegistry.addNode(cssNode);</span><br><span class="line"></span><br><span class="line">    ReactStylesDiffMap styles = null;</span><br><span class="line">    if (props != null) &#123;</span><br><span class="line">      styles = new ReactStylesDiffMap(props);</span><br><span class="line">      cssNode.updateProperties(styles);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleCreateView(cssNode, rootViewTag, styles);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protected void handleCreateView(</span><br><span class="line">    ReactShadowNode cssNode, int rootViewTag, @Nullable ReactStylesDiffMap styles) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:UI渲染流程第三步(3)：handleCreateView() called with: cssNode = [&quot; + cssNode + &quot;], rootViewTag = [&quot; + rootViewTag + &quot;], styles = [&quot; + styles + &quot;]&quot;);</span><br><span class="line">  if (!cssNode.isVirtual()) &#123;</span><br><span class="line">    mNativeViewHierarchyOptimizer.handleCreateView(cssNode, cssNode.getThemedContext(), styles);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/** Handles a createView call. May or may not actually create a native view. */</span><br><span class="line">public void handleCreateView(</span><br><span class="line">    ReactShadowNode node,</span><br><span class="line">    ThemedReactContext themedContext,</span><br><span class="line">    @Nullable ReactStylesDiffMap initialProps) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:UI渲染流程第四步(4)：handleCreateView() called with: node = [&quot; + node + &quot;], themedContext = [&quot; + themedContext + &quot;], initialProps = [&quot; + initialProps + &quot;]&quot;);</span><br><span class="line">  if (!ENABLED) &#123;</span><br><span class="line">    assertNodeSupportedWithoutOptimizer(node);</span><br><span class="line">    int tag = node.getReactTag();</span><br><span class="line">    mUIViewOperationQueue.enqueueCreateView(</span><br><span class="line">        themedContext, tag, node.getViewClass(), initialProps);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  boolean isLayoutOnly =</span><br><span class="line">      node.getViewClass().equals(ViewProps.VIEW_CLASS_NAME)</span><br><span class="line">          &amp;&amp; isLayoutOnlyAndCollapsable(initialProps);</span><br><span class="line">  node.setIsLayoutOnly(isLayoutOnly);</span><br><span class="line"></span><br><span class="line">  if (node.getNativeKind() != NativeKind.NONE) &#123;</span><br><span class="line">    mUIViewOperationQueue.enqueueCreateView(</span><br><span class="line">        themedContext, node.getReactTag(), node.getViewClass(), initialProps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void enqueueCreateView(</span><br><span class="line">    ThemedReactContext themedContext,</span><br><span class="line">    int viewReactTag,</span><br><span class="line">    String viewClassName,</span><br><span class="line">    @Nullable ReactStylesDiffMap initialProps) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:UI渲染流程第五步(5)：enqueueCreateView() called with: themedContext = [&quot; + themedContext + &quot;], viewReactTag = [&quot; + viewReactTag + &quot;], viewClassName = [&quot; + viewClassName + &quot;], initialProps = [&quot; + initialProps + &quot;]&quot;);</span><br><span class="line">  synchronized (mNonBatchedOperationsLock) &#123;</span><br><span class="line">    mNonBatchedOperations.addLast(</span><br><span class="line">        new CreateViewOperation(themedContext, viewReactTag, viewClassName, initialProps));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们把它包装成了一个Operations的类。然后放在队列中的里面。可以想象我们需要把这些Operations取出来，然后执行我们的生成View渲染View的相关操作。</p><p>我们可以看UIViewOperationQueue这里面的关于mNonBatchedOperations的取用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 调用View的操作的分发</span><br><span class="line">   * @param frameTimeNanos</span><br><span class="line">   */</span><br><span class="line">  private void dispatchPendingNonBatchedOperations(long frameTimeNanos) &#123;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">      long timeLeftInFrame = FRAME_TIME_MS - ((System.nanoTime() - frameTimeNanos) / 1000000);</span><br><span class="line">      if (timeLeftInFrame &lt; mMinTimeLeftInFrameForNonBatchedOperationMs) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      UIOperation nextOperation;</span><br><span class="line">      synchronized (mNonBatchedOperationsLock) &#123;</span><br><span class="line">        if (mNonBatchedOperations.isEmpty()) &#123;</span><br><span class="line">          break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 我们可以清楚的看到，所有关于View的操作都是从这里面从队列里面出去来</span><br><span class="line">        nextOperation = mNonBatchedOperations.pollFirst();</span><br><span class="line">        Log.d(TAG, &quot;FMsg:dispatchPendingNonBatchedOperations() called with: nextOperation = [&quot; + nextOperation + &quot;]&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">        long nonBatchedExecutionStartTime = SystemClock.uptimeMillis();</span><br><span class="line">        nextOperation.execute();</span><br><span class="line">        mNonBatchedExecutionTotalTime +=</span><br><span class="line">            SystemClock.uptimeMillis() - nonBatchedExecutionStartTime;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">        mIsInIllegalUIState = true;</span><br><span class="line">        throw e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们来看一下这个逻辑是谁那边来调用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFrameGuarded(long frameTimeNanos) &#123;</span><br><span class="line">  if (mIsInIllegalUIState) &#123;</span><br><span class="line">    FLog.w(</span><br><span class="line">        ReactConstants.TAG,</span><br><span class="line">        &quot;Not flushing pending UI operations because of previously thrown Exception&quot;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Systrace.beginSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE, &quot;dispatchNonBatchedUIOperations&quot;);</span><br><span class="line">  try &#123;</span><br><span class="line">    dispatchPendingNonBatchedOperations(frameTimeNanos);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(Systrace.TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  flushPendingBatches();</span><br><span class="line"></span><br><span class="line">  ReactChoreographer.getInstance()</span><br><span class="line">      .postFrameCallback(ReactChoreographer.CallbackType.DISPATCH_UI, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public abstract class GuardedFrameCallback extends ChoreographerCompat.FrameCallback &#123;</span><br><span class="line">  private static final String TAG = &quot;GuardedFrameCallback&quot;;</span><br><span class="line">  private final ReactContext mReactContext;</span><br><span class="line"></span><br><span class="line">  protected GuardedFrameCallback(ReactContext reactContext) &#123;</span><br><span class="line">    mReactContext = reactContext;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public final void doFrame(long frameTimeNanos) &#123;</span><br><span class="line">    //Log.d(TAG, &quot;FMsg:doFrame() called with: frameTimeNanos = [&quot; + frameTimeNanos + &quot;]&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">      doFrameGuarded(frameTimeNanos);</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">      mReactContext.handleException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Like the standard doFrame but RuntimeExceptions will be caught and passed to &#123;@link</span><br><span class="line">   * com.facebook.react.bridge.ReactContext#handleException(RuntimeException)&#125;.</span><br><span class="line">   */</span><br><span class="line">  protected abstract void doFrameGuarded(long frameTimeNanos);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个地方就一目了然了。这个UIViewOperrations队列是由Choreographer来进行驱动取用的。</p><p>那么队列的任务取出来之后，怎么进行任务的处理的呢？</p><p>我们回过头去看dispatchPendingNonBatchedOperations这个方法的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">synchronized (mNonBatchedOperationsLock) &#123;</span><br><span class="line">          if (mNonBatchedOperations.isEmpty()) &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">          // 我们可以清楚的看到，所有关于View的操作都是从这里面从队列里面出去来</span><br><span class="line">          nextOperation = mNonBatchedOperations.pollFirst();</span><br><span class="line">          Log.d(TAG, &quot;FMsg:dispatchPendingNonBatchedOperations() called with: nextOperation = [&quot; + nextOperation + &quot;]&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">          long nonBatchedExecutionStartTime = SystemClock.uptimeMillis();</span><br><span class="line">          nextOperation.execute();</span><br><span class="line">          mNonBatchedExecutionTotalTime +=</span><br><span class="line">              SystemClock.uptimeMillis() - nonBatchedExecutionStartTime;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">          mIsInIllegalUIState = true;</span><br><span class="line">          throw e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>我们看，针对UIOperation的批处理的数据，分别执行execute方法。</p><p>ViewOperation的抽象类，有很多的继承类。分别代码VIew的不同的操作方法。这里我们主要分析CreateViewOperation的代码实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private final class CreateViewOperation extends ViewOperation &#123;</span><br><span class="line"></span><br><span class="line">  private final ThemedReactContext mThemedContext;</span><br><span class="line">  private final String mClassName;</span><br><span class="line">  private final @Nullable ReactStylesDiffMap mInitialProps;</span><br><span class="line"></span><br><span class="line">  public CreateViewOperation(</span><br><span class="line">      ThemedReactContext themedContext,</span><br><span class="line">      int tag,</span><br><span class="line">      String className,</span><br><span class="line">      @Nullable ReactStylesDiffMap initialProps) &#123;</span><br><span class="line">    super(tag);</span><br><span class="line">    mThemedContext = themedContext;</span><br><span class="line">    mClassName = className;</span><br><span class="line">    mInitialProps = initialProps;</span><br><span class="line">    Systrace.startAsyncFlow(Systrace.TRACE_TAG_REACT_VIEW, &quot;createView&quot;, mTag);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void execute() &#123;</span><br><span class="line">    Systrace.endAsyncFlow(Systrace.TRACE_TAG_REACT_VIEW, &quot;createView&quot;, mTag);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:渲染流程第六步：!!!!!!!!!!!!!mNativeViewHierarchyManager createView !!!!!!!!!!!!&quot;);</span><br><span class="line">    mNativeViewHierarchyManager.createView(mThemedContext, mTag, mClassName, mInitialProps);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到execute的方法其实很简单。直接调用的NativeViewHierarchyManager的createView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void createView(</span><br><span class="line">    ThemedReactContext themedContext,</span><br><span class="line">    int tag,</span><br><span class="line">    String className,</span><br><span class="line">    @Nullable ReactStylesDiffMap initialProps) &#123;</span><br><span class="line">  UiThreadUtil.assertOnUiThread();</span><br><span class="line">  SystraceMessage.beginSection(</span><br><span class="line">          Systrace.TRACE_TAG_REACT_VIEW, &quot;NativeViewHierarchyManager_createView&quot;)</span><br><span class="line">      .arg(&quot;tag&quot;, tag)</span><br><span class="line">      .arg(&quot;className&quot;, className)</span><br><span class="line">      .flush();</span><br><span class="line">  try &#123;</span><br><span class="line">    ViewManager viewManager = mViewManagers.get(className);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:渲染流程第七步：createView() called with: themedContext = [&quot; + themedContext + &quot;], tag = [&quot; + tag + &quot;], className = [&quot; + className + &quot;], initialProps = [&quot; + initialProps + &quot;]&quot;);</span><br><span class="line">    View view = viewManager.createView(themedContext, null, null, mJSResponderHandler);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:渲染流程第七步：createView() view === &quot; + view.toString());</span><br><span class="line">    // 从这个整个渲染流程的就已经结束了！！！。但是我们还需要学习。既然View的已经存入到mTagsToViews</span><br><span class="line">    // 那么下面我们思考一下，我们是什么时候把他取出来。然后add 到ReactRootView中</span><br><span class="line">    mTagsToViews.put(tag, view);</span><br><span class="line">    mTagsToViewManagers.put(tag, viewManager);</span><br><span class="line"></span><br><span class="line">    // Use android View id field to store React tag. This is possible since we don&apos;t inflate</span><br><span class="line">    // React views from layout xmls. Thus it is easier to just reuse that field instead of</span><br><span class="line">    // creating another (potentially much more expensive) mapping from view to React tag</span><br><span class="line">    view.setId(tag);</span><br><span class="line">    if (initialProps != null) &#123;</span><br><span class="line">      viewManager.updateProperties(view, initialProps);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(Systrace.TRACE_TAG_REACT_VIEW);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个整个渲染流程的就已经结束了！！！。但是我们还需要学习。既然View的已经存入到mTagsToViews</p><p>那么下面我们思考一下，我们是什么时候把他取出来。然后add 到ReactRootView中??</p>]]></content>
      
      
      
        <tags>
            
            <tag> ReactNative </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactNative的启动流程精讲(基于ReactNative0.61.5)</title>
      <link href="/2020/03/13/ReactNative%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%B2%BE%E8%AE%B2(%E5%9F%BA%E4%BA%8EReactNative0.61.5)/"/>
      <url>/2020/03/13/ReactNative%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E7%B2%BE%E8%AE%B2(%E5%9F%BA%E4%BA%8EReactNative0.61.5)/</url>
      
        <content type="html"><![CDATA[<h1 id="ReactNative的启动流程精讲-基于ReactNative0-61-5"><a href="#ReactNative的启动流程精讲-基于ReactNative0-61-5" class="headerlink" title="ReactNative的启动流程精讲(基于ReactNative0.61.5)"></a>ReactNative的启动流程精讲(基于ReactNative0.61.5)</h1><p>文章参考：<a href="https://github.com/sucese/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/3ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.md" target="_blank" rel="noopener">https://github.com/sucese/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/3ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.md</a></p><p>文章参考：<a href="https://www.jianshu.com/p/baff68f85d41" target="_blank" rel="noopener">https://www.jianshu.com/p/baff68f85d41</a></p><h3 id="创建ReactNativeHost"><a href="#创建ReactNativeHost" class="headerlink" title="创建ReactNativeHost"></a>创建ReactNativeHost</h3><p>ReactNative的启动流程，我们首先看Application中的代码，实例化ReactNativeHost。ReactNativeHost主要的工作就是创建了ReactInstanceManager，它将一些信息传递给了ReactInstanceManager。同时，我们看一下ReactNativeHost的提供的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ReactNativeHost &#123;</span><br><span class="line">   </span><br><span class="line">      protected ReactInstanceManager createReactInstanceManager() &#123;</span><br><span class="line">        ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()</span><br><span class="line">          //应用上下文</span><br><span class="line">          .setApplication(mApplication)</span><br><span class="line">          //JSMainModuleP相当于应用首页的js Bundle，可以传递url从服务器拉取js Bundle</span><br><span class="line">          //当然这个只在dev模式下可以使用</span><br><span class="line">          .setJSMainModulePath(getJSMainModuleName())</span><br><span class="line">          //是否开启dev模式</span><br><span class="line">          .setUseDeveloperSupport(getUseDeveloperSupport())</span><br><span class="line">          //红盒的回调</span><br><span class="line">          .setRedBoxHandler(getRedBoxHandler())</span><br><span class="line">          //自定义UI实现机制，这个我们一般用不到</span><br><span class="line">          .setUIImplementationProvider(getUIImplementationProvider())</span><br><span class="line">          .setInitialLifecycleState(LifecycleState.BEFORE_CREATE);</span><br><span class="line">    </span><br><span class="line">        //添加ReactPackage</span><br><span class="line">        for (ReactPackage reactPackage : getPackages()) &#123;</span><br><span class="line">          builder.addPackage(reactPackage);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        //获取js Bundle的加载路径</span><br><span class="line">        String jsBundleFile = getJSBundleFile();</span><br><span class="line">        if (jsBundleFile != null) &#123;</span><br><span class="line">          builder.setJSBundleFile(jsBundleFile);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          builder.setBundleAssetName(Assertions.assertNotNull(getBundleAssetName()));</span><br><span class="line">        &#125;</span><br><span class="line">        return builder.build();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是ReactNativeHost提供的一些方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected @Nullable RedBoxHandler getRedBoxHandler();</span><br><span class="line">protected @Nullable JavaScriptExecutorFactory getJavaScriptExecutorFactory();</span><br><span class="line">protected final Application getApplication();</span><br><span class="line">protected UIImplementationProvider getUIImplementationProvider();</span><br></pre></td></tr></table></figure><h3 id="实例化ReactActivityDelegate："><a href="#实例化ReactActivityDelegate：" class="headerlink" title="实例化ReactActivityDelegate："></a>实例化ReactActivityDelegate：</h3><p>启动ReactActivity的子类实例，在这个Activty的启动流程中，正式开始我们ReactNative启动和加载流程。<br>我们先来分析一下ReactActivityDelegate。我么可以看到ReactActivityDelegate的一些提供的方法。就知道这个类的一些职责。他主要就是Activity的宿主的一些生命周期的委托调用。也就是所有ReactNative和宿主Activity的关联都是通过这个类类简历联系的。</p><p>当然我们也看到。其实所有的生命周期的方法。这个类要么委托给ReactDelegate。要么就是直接ReactInstanceManager进行处理。所以这个类的职责也是非常简单的。</p><p>可以说ReactNative和她的宿主Activity达到了很好的解耦。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ReactActivity extends AppCompatActivity</span><br><span class="line">    implements DefaultHardwareBackBtnHandler, PermissionAwareActivity &#123;</span><br><span class="line"></span><br><span class="line">  private final ReactActivityDelegate mDelegate;</span><br><span class="line"></span><br><span class="line">  protected ReactActivity() &#123;</span><br><span class="line">    mDelegate = createReactActivityDelegate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Returns the name of the main component registered from JavaScript. This is used to schedule</span><br><span class="line">   * rendering of the component. e.g. &quot;MoviesApp&quot;</span><br><span class="line">   */</span><br><span class="line">  protected @Nullable String getMainComponentName() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Called at construction time, override if you have a custom delegate implementation. */</span><br><span class="line">  protected ReactActivityDelegate createReactActivityDelegate() &#123;</span><br><span class="line">    return new ReactActivityDelegate(this, getMainComponentName());</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类很简单，就是实例化的一个Activity的委托对象。然后所有的生命周期调用全部使用ReactActivityDelegate的代理对象完成。</p><p>那么下面，我们看一下这个类的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ReactActivityDelegate(ReactActivity activity, @Nullable String mainComponentName) &#123;</span><br><span class="line">    Log.d(TAG, &quot;第二步：FMsg: 实例化ReactActivityDelegate called with: activity = [&quot; + activity + &quot;], mainComponentName = [&quot; + mainComponentName + &quot;]&quot;);</span><br><span class="line">    mActivity = activity;</span><br><span class="line">    mMainComponentName = mainComponentName;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们看一下。Activity的onCreate的方法的代理实现。</p><h3 id="实例化ReactDelegate"><a href="#实例化ReactDelegate" class="headerlink" title="实例化ReactDelegate"></a>实例化ReactDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    String mainComponentName = getMainComponentName();</span><br><span class="line">    mReactDelegate =</span><br><span class="line">        new ReactDelegate(</span><br><span class="line">            getPlainActivity(), getReactNativeHost(), mainComponentName, getLaunchOptions()) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          protected ReactRootView createRootView() &#123;</span><br><span class="line">            return ReactActivityDelegate.this.createRootView();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    //mMainComponentName就是上面ReactActivity.getMainComponentName()返回的组件名    </span><br><span class="line">    if (mMainComponentName != null) &#123;</span><br><span class="line">      //载入app页面</span><br><span class="line">      loadApp(mainComponentName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法一个，实例化ReactDelegate对象。二是调用loadApp的方法。</p><p>我们来看一下ReactDelegate的这个对象。他的职责到底是什么呢？？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void loadApp(String appKey) &#123;</span><br><span class="line">    mReactDelegate.loadApp(appKey);</span><br><span class="line">    getPlainActivity().setContentView(mReactDelegate.getReactRootView());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个方法很简单。还是调用了ReactDelegate的loadApp方法。至此位置ReactActivityDelegate的启动流程中的职责也就告一段落。下面我们看一下ReactDelegate里面的loadApp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void loadApp(String appKey) &#123;</span><br><span class="line">  if (mReactRootView != null) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;Cannot loadApp while app is already running.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //创建ReactRootView作为根视图,它本质上是一个FrameLayout</span><br><span class="line">  mReactRootView = createRootView();、</span><br><span class="line">  //启动RN应用.这个地方我们要注意下。ReactInstanceManager就是从这个地方开始实例化的。</span><br><span class="line">  mReactRootView.startReactApplication(</span><br><span class="line">      getReactNativeHost().getReactInstanceManager(), appKey, mLaunchOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终这个方法是调用到ReactRootView。这个View我们知道，其实就是我们通过setContentView设置给Activity宿主的FameLayout</p><h3 id="实例化ReactInstanceManager"><a href="#实例化ReactInstanceManager" class="headerlink" title="实例化ReactInstanceManager"></a>实例化ReactInstanceManager</h3><p>我们可以从代码中看到，在startReactApplication的时候，我们通过ReactNativeHost的实例化对象来获取ReactInstanceManager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/** Get the current &#123;@link ReactInstanceManager&#125; instance, or create one. */</span><br><span class="line"> public ReactInstanceManager getReactInstanceManager() &#123;</span><br><span class="line">   if (mReactInstanceManager == null) &#123;</span><br><span class="line">     ReactMarker.logMarker(ReactMarkerConstants.GET_REACT_INSTANCE_MANAGER_START);</span><br><span class="line">     mReactInstanceManager = createReactInstanceManager();</span><br><span class="line">     ReactMarker.logMarker(ReactMarkerConstants.GET_REACT_INSTANCE_MANAGER_END);</span><br><span class="line">   &#125;</span><br><span class="line">   return mReactInstanceManager;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> protected ReactInstanceManager createReactInstanceManager() &#123;</span><br><span class="line">   ReactMarker.logMarker(ReactMarkerConstants.BUILD_REACT_INSTANCE_MANAGER_START);</span><br><span class="line">   Log.d(TAG, &quot;FMsg:第五步：createReactInstanceManager() called&quot;);</span><br><span class="line">   ReactInstanceManagerBuilder builder =</span><br><span class="line">       ReactInstanceManager.builder()</span><br><span class="line">           .setApplication(mApplication)</span><br><span class="line">            // 设置JSMain的根路径地址。也就是index.js  //&quot;index.android&quot;</span><br><span class="line">           .setJSMainModulePath(getJSMainModuleName())</span><br><span class="line">           .setUseDeveloperSupport(getUseDeveloperSupport())</span><br><span class="line">           //红盒的回调</span><br><span class="line">           .setRedBoxHandler(getRedBoxHandler())</span><br><span class="line">           // 获取JS执行引擎的工作累的方法。默认是JSC。当然我们也可以自定义设置成V8的引擎</span><br><span class="line">           // 如果需要自定义设置，那么Application中重写这个方法</span><br><span class="line">           .setJavaScriptExecutorFactory(getJavaScriptExecutorFactory())</span><br><span class="line">            //自定义UI实现机制，这个我们一般用不到</span><br><span class="line">           .setUIImplementationProvider(getUIImplementationProvider())</span><br><span class="line">           .setJSIModulesPackage(getJSIModulePackage())</span><br><span class="line">           .setInitialLifecycleState(LifecycleState.BEFORE_CREATE);</span><br><span class="line">   // 类实例化的作用就是传递给ReactInstanceManager所有的Packages</span><br><span class="line">   Log.i(TAG, &quot;FMsg:第五步：createReactInstanceManager: addPackage  size = &quot; + getPackages().size());</span><br><span class="line">   // 这个使我们Application实例化的时候，我们提供的ReactPackage</span><br><span class="line">   for (ReactPackage reactPackage : getPackages()) &#123;</span><br><span class="line">     builder.addPackage(reactPackage);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String jsBundleFile = getJSBundleFile();</span><br><span class="line">   Log.i(TAG, &quot;FMsg:第五步：createReactInstanceManager: jsBundleFile = &quot;+jsBundleFile);</span><br><span class="line">   if (jsBundleFile != null) &#123;</span><br><span class="line">     builder.setJSBundleFile(jsBundleFile);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     builder.setBundleAssetName(Assertions.assertNotNull(getBundleAssetName()));</span><br><span class="line">   &#125;</span><br><span class="line">   // 这个建造者模式，可以好好分析一下。里面有很多的默认参数</span><br><span class="line">   ReactInstanceManager reactInstanceManager = builder.build();</span><br><span class="line">   ReactMarker.logMarker(ReactMarkerConstants.BUILD_REACT_INSTANCE_MANAGER_END);</span><br><span class="line">   return reactInstanceManager;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其实从这个地方。ReactNativeHost的历史使命就完成了。所有我们复写的他的提供方法都是在这个地方传递给ReactInstance的构造化实例对象。</p><p>下面，我们来看一下ReactInstanceManager的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/* package */ ReactInstanceManager(</span><br><span class="line">     Context applicationContext,</span><br><span class="line">     @Nullable Activity currentActivity,</span><br><span class="line">     @Nullable DefaultHardwareBackBtnHandler defaultHardwareBackBtnHandler,</span><br><span class="line">     JavaScriptExecutorFactory javaScriptExecutorFactory,</span><br><span class="line">     @Nullable JSBundleLoader bundleLoader,</span><br><span class="line">     @Nullable String jsMainModulePath,</span><br><span class="line">     List&lt;ReactPackage&gt; packages,</span><br><span class="line">     boolean useDeveloperSupport,</span><br><span class="line">     @Nullable NotThreadSafeBridgeIdleDebugListener bridgeIdleDebugListener,</span><br><span class="line">     LifecycleState initialLifecycleState,</span><br><span class="line">     @Nullable UIImplementationProvider mUIImplementationProvider,</span><br><span class="line">     NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler,</span><br><span class="line">     @Nullable RedBoxHandler redBoxHandler,</span><br><span class="line">     boolean lazyViewManagersEnabled,</span><br><span class="line">     @Nullable DevBundleDownloadListener devBundleDownloadListener,</span><br><span class="line">     int minNumShakes,</span><br><span class="line">     // 这个参数也比较重要，这个参数就是ReactNative的刷新帧的频率。默认-1.表示直接使用Android的刷新帧频率</span><br><span class="line">     int minTimeLeftInFrameForNonBatchedOperationMs,</span><br><span class="line">     @Nullable JSIModulePackage jsiModulePackage,</span><br><span class="line">     @Nullable Map&lt;String, RequestHandler&gt; customPackagerCommandHandlers) &#123;</span><br><span class="line">   Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.ctor()&quot;);</span><br><span class="line">   Log.d(TAG, &quot;FMsg:第五步：ReactInstanceManager() called with: currentActivity = [&quot; + currentActivity + &quot;], defaultHardwareBackBtnHandler = [&quot; + defaultHardwareBackBtnHandler + &quot;], javaScriptExecutorFactory = [&quot; + javaScriptExecutorFactory + &quot;], bundleLoader = [&quot; + bundleLoader + &quot;], jsMainModulePath = [&quot; + jsMainModulePath + &quot;], packages = [&quot; + packages + &quot;], useDeveloperSupport = [&quot; + useDeveloperSupport + &quot;], bridgeIdleDebugListener = [&quot; + bridgeIdleDebugListener + &quot;], initialLifecycleState = [&quot; + initialLifecycleState + &quot;], mUIImplementationProvider = [&quot; + mUIImplementationProvider + &quot;], nativeModuleCallExceptionHandler = [&quot; + nativeModuleCallExceptionHandler + &quot;], redBoxHandler = [&quot; + redBoxHandler + &quot;], lazyViewManagersEnabled = [&quot; + lazyViewManagersEnabled + &quot;], devBundleDownloadListener = [&quot; + devBundleDownloadListener + &quot;], minNumShakes = [&quot; + minNumShakes + &quot;], minTimeLeftInFrameForNonBatchedOperationMs = [&quot; + minTimeLeftInFrameForNonBatchedOperationMs + &quot;], jsiModulePackage = [&quot; + jsiModulePackage + &quot;], customPackagerCommandHandlers = [&quot; + customPackagerCommandHandlers + &quot;]&quot;);</span><br><span class="line">   initializeSoLoaderIfNecessary(applicationContext);</span><br><span class="line"></span><br><span class="line">   DisplayMetricsHolder.initDisplayMetricsIfNotInitialized(applicationContext);</span><br><span class="line"></span><br><span class="line">   mApplicationContext = applicationContext;</span><br><span class="line">   mCurrentActivity = currentActivity;</span><br><span class="line">   mDefaultBackButtonImpl = defaultHardwareBackBtnHandler;</span><br><span class="line">   // 其实默认传入的null  如果我们想使用其他JS引擎，比如V8.我们可以在这里面进行传入</span><br><span class="line">   mJavaScriptExecutorFactory = javaScriptExecutorFactory;</span><br><span class="line">   mBundleLoader = bundleLoader;</span><br><span class="line">   mJSMainModulePath = jsMainModulePath;</span><br><span class="line">   mPackages = new ArrayList&lt;&gt;();</span><br><span class="line">   mUseDeveloperSupport = useDeveloperSupport;</span><br><span class="line">   Systrace.beginSection(</span><br><span class="line">       Systrace.TRACE_TAG_REACT_JAVA_BRIDGE, &quot;ReactInstanceManager.initDevSupportManager&quot;);</span><br><span class="line">   mDevSupportManager =</span><br><span class="line">       DevSupportManagerFactory.create(</span><br><span class="line">           applicationContext,</span><br><span class="line">           createDevHelperInterface(),</span><br><span class="line">           mJSMainModulePath,</span><br><span class="line">           useDeveloperSupport,</span><br><span class="line">           redBoxHandler,</span><br><span class="line">           devBundleDownloadListener,</span><br><span class="line">           minNumShakes,</span><br><span class="line">           customPackagerCommandHandlers);</span><br><span class="line">   Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">   mBridgeIdleDebugListener = bridgeIdleDebugListener;</span><br><span class="line">   mLifecycleState = initialLifecycleState;</span><br><span class="line">   mMemoryPressureRouter = new MemoryPressureRouter(applicationContext);</span><br><span class="line">   mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;</span><br><span class="line"></span><br><span class="line">   /// 这个地方就是添加ReactPackage</span><br><span class="line">   synchronized (mPackages) &#123;</span><br><span class="line">     PrinterHolder.getPrinter()</span><br><span class="line">         .logMessage(ReactDebugOverlayTags.RN_CORE, &quot;RNCore: Use Split Packages&quot;);</span><br><span class="line">     // 这个方法很重要，这个方法我们会将系统内置的那些CoreModulesPackage添加进去</span><br><span class="line">     // AndroidInfoModule.class,</span><br><span class="line">     // DeviceEventManagerModule.class,</span><br><span class="line">     // DeviceInfoModule.class,</span><br><span class="line">     // DevSettingsModule.class,</span><br><span class="line">     // ExceptionsManagerModule.class,</span><br><span class="line">     // HeadlessJsTaskSupportModule.class,</span><br><span class="line">     // SourceCodeModule.class,</span><br><span class="line">     // Timing.class,</span><br><span class="line">     // UIManagerModule.class</span><br><span class="line">     mPackages.add(</span><br><span class="line">         new CoreModulesPackage(</span><br><span class="line">             this,</span><br><span class="line">             new DefaultHardwareBackBtnHandler() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void invokeDefaultOnBackPressed() &#123;</span><br><span class="line">                 ReactInstanceManager.this.invokeDefaultOnBackPressed();</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             mUIImplementationProvider,</span><br><span class="line">             lazyViewManagersEnabled,</span><br><span class="line">             minTimeLeftInFrameForNonBatchedOperationMs));</span><br><span class="line">     if (mUseDeveloperSupport) &#123;</span><br><span class="line">       mPackages.add(new DebugCorePackage());</span><br><span class="line">     &#125;</span><br><span class="line">     mPackages.addAll(packages);</span><br><span class="line">   &#125;</span><br><span class="line">   mJSIModulePackage = jsiModulePackage;</span><br><span class="line"></span><br><span class="line">   // Instantiate ReactChoreographer in UI thread.</span><br><span class="line">   // 这个就是实例化Android的序列帧的监听对象</span><br><span class="line">   ReactChoreographer.initialize();</span><br><span class="line">   if (mUseDeveloperSupport) &#123;</span><br><span class="line">     mDevSupportManager.startInspector();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>从ReactInstanceManager的构造函数，我们可以看到。所有ReactNative的启动的初始化资源基本都已经准备完毕。所以startReactApplication的方法。我们必须要传入ReactInstanceManager实例化对象。</p><p>其实通过查看ReactInstance的类的内容，我们可以看到这个类的方法其实也是比较简单的。他的关于启动流程最大的一个作用就是创建ReactContext。那么这个创建ReactContext是什么开始的呢？</p><p>我们来继续看ReactRootView的startReactApplication方法。</p><h3 id="startReactApplication"><a href="#startReactApplication" class="headerlink" title="startReactApplication"></a>startReactApplication</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@ThreadConfined(UI)</span><br><span class="line">public void startReactApplication(</span><br><span class="line">    ReactInstanceManager reactInstanceManager,</span><br><span class="line">    String moduleName,</span><br><span class="line">    @Nullable Bundle initialProperties,</span><br><span class="line">    @Nullable String initialUITemplate) &#123;</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;startReactApplication&quot;);</span><br><span class="line">  try &#123;</span><br><span class="line">    // 线程检查</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line"></span><br><span class="line">    // TODO(6788889): Use POJO instead of bundle here, apparently we can&apos;t just use WritableMap</span><br><span class="line">    // here as it may be deallocated in native after passing via JNI bridge, but we want to reuse</span><br><span class="line">    // it in the case of re-creating the catalyst instance</span><br><span class="line">    Assertions.assertCondition(</span><br><span class="line">        mReactInstanceManager == null,</span><br><span class="line">        &quot;This root view has already been attached to a catalyst instance manager&quot;);</span><br><span class="line"></span><br><span class="line">    mReactInstanceManager = reactInstanceManager;</span><br><span class="line">    mJSModuleName = moduleName;</span><br><span class="line">    mAppProperties = initialProperties;</span><br><span class="line">    mInitialUITemplate = initialUITemplate;</span><br><span class="line"></span><br><span class="line">    if (mUseSurface) &#123;</span><br><span class="line">      // TODO initialize surface here</span><br><span class="line">    &#125;</span><br><span class="line">    //创建RN上下文上下文对象</span><br><span class="line">    mReactInstanceManager.createReactContextInBackground();</span><br><span class="line">    //attachToReactInstanceManager 调用的是mReactInstanceManager.attachRootView(this)</span><br><span class="line">    attachToReactInstanceManager();</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法比较深，我们可以一步步往下看。进入到这个方法，就进入到ReactInstance的核心功能。也是ReactNative启动的核心流程。也是最重要的流程中。createReactContext的创建流程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">@ThreadConfined(UI)</span><br><span class="line">  public void createReactContextInBackground() &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.createReactContextInBackground()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：ReactRootView开始创建ReactContext createReactContextInBackground() called&quot;);</span><br><span class="line">    UiThreadUtil</span><br><span class="line">        .assertOnUiThread(); // Assert before setting mHasStartedCreatingInitialContext = true</span><br><span class="line">    if (!mHasStartedCreatingInitialContext) &#123;</span><br><span class="line">      mHasStartedCreatingInitialContext = true;</span><br><span class="line">      recreateReactContextInBackgroundInner();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   @ThreadConfined(UI)</span><br><span class="line">  private void recreateReactContextInBackgroundInner() &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.recreateReactContextInBackgroundInner()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：调用内部方法recreateReactContextInBackgroundInner() called&quot;);</span><br><span class="line">    PrinterHolder.getPrinter()</span><br><span class="line">        .logMessage(ReactDebugOverlayTags.RN_CORE, &quot;RNCore: recreateReactContextInBackground&quot;);</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line">    // 调试相关的逻辑，咱们暂时忽略</span><br><span class="line">    if (mUseDeveloperSupport &amp;&amp; mJSMainModulePath != null) &#123;</span><br><span class="line">      final DeveloperSettings devSettings = mDevSupportManager.getDevSettings();</span><br><span class="line"></span><br><span class="line">      if (!Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;</span><br><span class="line">        if (mBundleLoader == null) &#123;</span><br><span class="line">          mDevSupportManager.handleReloadJS();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          mDevSupportManager.isPackagerRunning(</span><br><span class="line">              new PackagerStatusCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onPackagerStatusFetched(final boolean packagerIsRunning) &#123;</span><br><span class="line">                  UiThreadUtil.runOnUiThread(</span><br><span class="line">                      new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                          if (packagerIsRunning) &#123;</span><br><span class="line">                            mDevSupportManager.handleReloadJS();</span><br><span class="line">                          &#125; else if (mDevSupportManager.hasUpToDateJSBundleInCache()</span><br><span class="line">                              &amp;&amp; !devSettings.isRemoteJSDebugEnabled()) &#123;</span><br><span class="line">                            // If there is a up-to-date bundle downloaded from server,</span><br><span class="line">                            // with remote JS debugging disabled, always use that.</span><br><span class="line">                            onJSBundleLoadedFromServer(null);</span><br><span class="line">                          &#125; else &#123;</span><br><span class="line">                            // If dev server is down, disable the remote JS debugging.</span><br><span class="line">                            devSettings.setRemoteJSDebugEnabled(false);</span><br><span class="line">                            recreateReactContextInBackgroundFromBundleLoader();</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recreateReactContextInBackgroundFromBundleLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   @ThreadConfined(UI)</span><br><span class="line">  private void recreateReactContextInBackgroundFromBundleLoader() &#123;</span><br><span class="line">    Log.d(</span><br><span class="line">        ReactConstants.TAG,</span><br><span class="line">        &quot;ReactInstanceManager.recreateReactContextInBackgroundFromBundleLoader()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：线上环境来将会使用后台任务创建ReactContext recreateReactContextInBackgroundFromBundleLoader() called&quot;);</span><br><span class="line">    PrinterHolder.getPrinter()</span><br><span class="line">        .logMessage(ReactDebugOverlayTags.RN_CORE, &quot;RNCore: load from BundleLoader&quot;);</span><br><span class="line">    recreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @ThreadConfined(UI)</span><br><span class="line">  private void runCreateReactContextOnNewThread(final ReactContextInitParams initParams) &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.runCreateReactContextOnNewThread()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：runCreateReactContextOnNewThread() called with: initParams = [&quot; + initParams + &quot;]&quot;);</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line">    synchronized (mAttachedReactRoots) &#123;</span><br><span class="line">      synchronized (mReactContextLock) &#123;</span><br><span class="line">        // 生命周期的回收，主要是针对可能会造成的多次初始化RN环境的</span><br><span class="line">        if (mCurrentReactContext != null) &#123;</span><br><span class="line">          tearDownReactContext(mCurrentReactContext);</span><br><span class="line">          mCurrentReactContext = null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCreateReactContextThread =</span><br><span class="line">        new Thread(</span><br><span class="line">            null,</span><br><span class="line">            new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                ReactMarker.logMarker(REACT_CONTEXT_THREAD_END);</span><br><span class="line">                synchronized (ReactInstanceManager.this.mHasStartedDestroying) &#123;</span><br><span class="line">                  while (ReactInstanceManager.this.mHasStartedDestroying) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                      ReactInstanceManager.this.mHasStartedDestroying.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                      continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // As destroy() may have run and set this to false, ensure that it is true before we</span><br><span class="line">                // create</span><br><span class="line">                mHasStartedCreatingInitialContext = true;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                  Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);</span><br><span class="line">                  ReactMarker.logMarker(VM_INIT);</span><br><span class="line">                  Log.i(TAG, &quot;FMsg:第六步：runCreateReactContextOnNewThread run: &quot; + Thread.currentThread().getName());</span><br><span class="line">                  final ReactApplicationContext reactApplicationContext =</span><br><span class="line">                      createReactContext(</span><br><span class="line">                          initParams.getJsExecutorFactory().create(),</span><br><span class="line">                          initParams.getJsBundleLoader());</span><br><span class="line"></span><br><span class="line">                  mCreateReactContextThread = null;</span><br><span class="line">                  ReactMarker.logMarker(PRE_SETUP_REACT_CONTEXT_START);</span><br><span class="line"></span><br><span class="line">                  // 这个地方也是一个保护机制，我们暂时不需要关注</span><br><span class="line">                  final Runnable maybeRecreateReactContextRunnable =</span><br><span class="line">                      new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                          if (mPendingReactContextInitParams != null) &#123;</span><br><span class="line">                            runCreateReactContextOnNewThread(mPendingReactContextInitParams);</span><br><span class="line">                            mPendingReactContextInitParams = null;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;;</span><br><span class="line">                  Runnable setupReactContextRunnable =</span><br><span class="line">                      new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                            setupReactContext(reactApplicationContext);</span><br><span class="line">                          &#125; catch (Exception e) &#123;</span><br><span class="line">                            mDevSupportManager.handleException(e);</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;;</span><br><span class="line"></span><br><span class="line">                  reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);</span><br><span class="line">                  UiThreadUtil.runOnUiThread(maybeRecreateReactContextRunnable);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                  mDevSupportManager.handleException(e);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;create_react_context&quot;);</span><br><span class="line">    ReactMarker.logMarker(REACT_CONTEXT_THREAD_START);</span><br><span class="line">    mCreateReactContextThread.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个地方就是我们比较重要的创建ReactContext对象的逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> /** @return instance of &#123;@link ReactContext&#125; configured a &#123;@link CatalystInstance&#125; set */</span><br><span class="line">private ReactApplicationContext createReactContext(</span><br><span class="line">    JavaScriptExecutor jsExecutor, JSBundleLoader jsBundleLoader) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第六步：ReactInstanceManager.createReactContext &quot; + Thread.currentThread().getName());</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第六步：createReactContext() called with: jsExecutor = [&quot; + jsExecutor + &quot;], jsBundleLoader = [&quot; + jsBundleLoader + &quot;]&quot;);</span><br><span class="line">  ReactMarker.logMarker(CREATE_REACT_CONTEXT_START, jsExecutor.getName());</span><br><span class="line">  // 这个地方就进行了实例化reactContext</span><br><span class="line">  // ReactApplicationContext extends ReactContext extends ContextWrapper</span><br><span class="line">  // 构造函数传入的是Context。 eactApplicationContext是ReactContext的包装类。</span><br><span class="line">  final ReactApplicationContext reactContext = new ReactApplicationContext(mApplicationContext);</span><br><span class="line"></span><br><span class="line">  // 这个就是NativeModuleCallExceptionHandler.异常捕获器</span><br><span class="line">  NativeModuleCallExceptionHandler exceptionHandler =</span><br><span class="line">      mNativeModuleCallExceptionHandler != null</span><br><span class="line">          ? mNativeModuleCallExceptionHandler</span><br><span class="line">          : mDevSupportManager;</span><br><span class="line">  reactContext.setNativeModuleCallExceptionHandler(exceptionHandler);</span><br><span class="line"></span><br><span class="line">  // 创建JavaModule注册表Builder，用来创建JavaModule注册表，JavaModule注册表将所有的JavaModule注册到CatalystInstance中。</span><br><span class="line">  NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);</span><br><span class="line">  // 最最重要的一个对象，催化器实例对象</span><br><span class="line">  // jsExecutor、nativeModuleRegistry、nativeModuleRegistry等各种参数处理好之后，开始构建CatalystInstanceImpl实例。</span><br><span class="line">  CatalystInstanceImpl.Builder catalystInstanceBuilder =</span><br><span class="line">      new CatalystInstanceImpl.Builder()</span><br><span class="line">              // 设置ReactNative的消息队列的配置数据</span><br><span class="line">          .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())</span><br><span class="line">              // 通过JS执行器工厂实例化的JS线程执行器</span><br><span class="line">          .setJSExecutor(jsExecutor)</span><br><span class="line">          .setRegistry(nativeModuleRegistry)</span><br><span class="line">          .setJSBundleLoader(jsBundleLoader)</span><br><span class="line">          .setNativeModuleCallExceptionHandler(exceptionHandler);</span><br><span class="line"></span><br><span class="line">  ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_START);</span><br><span class="line">  // CREATE_CATALYST_INSTANCE_END is in JSCExecutor.cpp</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;createCatalystInstance&quot;);</span><br><span class="line">  final CatalystInstance catalystInstance;</span><br><span class="line">  try &#123;</span><br><span class="line">    // 没什么好说的。空值判断。但是催化器的构造函数我们需要研究一下。</span><br><span class="line">    // 里面针对消息队列的线程进行初始化</span><br><span class="line">    catalystInstance = catalystInstanceBuilder.build();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">    ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_END);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 关联ReacContext与CatalystInstance实例化</span><br><span class="line">  // 解析上面实例化的是三个线程封装对象</span><br><span class="line">  reactContext.initializeWithInstance(catalystInstance);</span><br><span class="line"></span><br><span class="line">  if (mJSIModulePackage != null) &#123;</span><br><span class="line">    // 这个默认是为null的。这个数据最初是在ReactNativeHost里面传入的</span><br><span class="line">    catalystInstance.addJSIModules(</span><br><span class="line">        mJSIModulePackage.getJSIModules(</span><br><span class="line">            reactContext, catalystInstance.getJavaScriptContextHolder()));</span><br><span class="line">    // 这个地方没太看懂</span><br><span class="line">    if (ReactFeatureFlags.useTurboModules) &#123;</span><br><span class="line">      catalystInstance.setTurboModuleManager(</span><br><span class="line">          catalystInstance.getJSIModule(JSIModuleType.TurboModuleManager));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (mBridgeIdleDebugListener != null) &#123;</span><br><span class="line">    catalystInstance.addBridgeIdleDebugListener(mBridgeIdleDebugListener);</span><br><span class="line">  &#125;</span><br><span class="line">  if (Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;</span><br><span class="line">    catalystInstance.setGlobalVariable(&quot;__RCTProfileIsProfiling&quot;, &quot;true&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  ReactMarker.logMarker(ReactMarkerConstants.PRE_RUN_JS_BUNDLE_START);</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;runJSBundle&quot;);</span><br><span class="line">  // 加载JSBundle的数据</span><br><span class="line">  catalystInstance.runJSBundle();</span><br><span class="line">  Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line"></span><br><span class="line">  return reactContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是非常重要的方法，我们需要一点点来分析一下。</p><p>1、首先他将Application的对象用ReactApplicationContext进行包装，生成ReactApplication对象。这个没什么好说的。简单的包装而已。</p><p>2、创建JavaModule的注册表</p><p>3、进行CatalystInstanceImpl实例化</p><p>4、关联ReacContext与CatalystInstance实例化 解析上面实例化的是三个线程封装对象。这个地方。</p><p> 我们主要作用是让reactContext来持有catalystInstance对象 两个作用：1、获取这个实力上面传入ReactQueueConfigurationSpec实例，或者三个消息队列线程封装的对象        2、主要是通过催化器实例获取JSModule、NativeModule</p><p>其次，ReacContext还有就是一些生命周期的管理</p><h3 id="实例化CatalystInstanceImpl"><a href="#实例化CatalystInstanceImpl" class="headerlink" title="实例化CatalystInstanceImpl"></a>实例化CatalystInstanceImpl</h3><p>下面就是最重要的催化剂实例的构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private CatalystInstanceImpl(</span><br><span class="line">      final ReactQueueConfigurationSpec reactQueueConfigurationSpec,</span><br><span class="line">      final JavaScriptExecutor jsExecutor,</span><br><span class="line">      final NativeModuleRegistry nativeModuleRegistry,</span><br><span class="line">      final JSBundleLoader jsBundleLoader,</span><br><span class="line">      NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler) &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;Initializing React Xplat Bridge.&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第七步：CatalystInstanceImpl() called with: reactQueueConfigurationSpec = [&quot; + reactQueueConfigurationSpec + &quot;], jsExecutor = [&quot; + jsExecutor + &quot;], nativeModuleRegistry = [&quot; + nativeModuleRegistry + &quot;], jsBundleLoader = [&quot; + jsBundleLoader + &quot;], nativeModuleCallExceptionHandler = [&quot; + nativeModuleCallExceptionHandler + &quot;]&quot;);</span><br><span class="line">    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;createCatalystInstanceImpl&quot;);</span><br><span class="line"></span><br><span class="line">    // 重点关注一下这一方法。这是一个Native方法。这样我们就调用到Native层</span><br><span class="line">    mHybridData = initHybrid();</span><br><span class="line">    // ReactNative的消息队列相关的实例化</span><br><span class="line">    // TODO 这个地方要重点看一下</span><br><span class="line">    // 这个主要是分别在对应的线程中创建消息任务队列的Handler(搬运工)</span><br><span class="line">    // 当然还创建了两个线程(主线程不用创建)</span><br><span class="line">    mReactQueueConfiguration =</span><br><span class="line">        ReactQueueConfigurationImpl.create(</span><br><span class="line">            reactQueueConfigurationSpec, new NativeExceptionHandler());</span><br><span class="line">    mBridgeIdleListeners = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    // NativeModules注入器</span><br><span class="line">    mNativeModuleRegistry = nativeModuleRegistry;</span><br><span class="line">    mJSModuleRegistry = new JavaScriptModuleRegistry();</span><br><span class="line">    // JSBundlerLoader</span><br><span class="line">    mJSBundleLoader = jsBundleLoader;</span><br><span class="line">    mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;</span><br><span class="line">    mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();</span><br><span class="line">    mTraceListener = new JSProfilerTraceListener(this);</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, &quot;FMsg: 第七步：CatalystInstanceImpl() called Initializing React Xplat Bridge before initializeBridge&quot;);</span><br><span class="line">    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;initializeCxxBridge&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第七步：CatalystInstanceImpl() called with: initializeCxxBridge&quot;);</span><br><span class="line"></span><br><span class="line">    // TODO 这个地方要重点看一下. 又一个非常重要的方法。</span><br><span class="line">    // 初始化Java和Native之间的Bridge桥。这个是一个Native方法</span><br><span class="line">    initializeBridge(</span><br><span class="line">        //</span><br><span class="line">        new BridgeCallback(this),</span><br><span class="line">        // JSCore的JS引擎</span><br><span class="line">        jsExecutor,</span><br><span class="line">        // JS消息队列线程封装对象</span><br><span class="line">        mReactQueueConfiguration.getJSQueueThread(),</span><br><span class="line">            // Native消息队列线程封装对象</span><br><span class="line">        mNativeModulesQueueThread,</span><br><span class="line">        // 非C++的Modules就是JavaModule.也就是我们在Application里面封装的Modules</span><br><span class="line">        // 这些NativeModules都会被封装成JavaModuleWrapper对象送给Native层</span><br><span class="line">        mNativeModuleRegistry.getJavaModules(this),</span><br><span class="line">        // 获取我们所有的Module中的C++的modules。这个是通过注解来标记那个NativeModule是C++</span><br><span class="line">        // 但是我们翻了一下源码，没看到哪个NativeModule是C++</span><br><span class="line">        mNativeModuleRegistry.getCxxModules());</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;第七步：实例化Initializing React Xplat Bridge after initializeBridge&quot;);</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line"></span><br><span class="line">    mJavaScriptContextHolder = new JavaScriptContextHolder(getJavaScriptContext());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>下面，我们看一下Native层的调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jni::local_ref&lt;CatalystInstanceImpl::jhybriddata&gt; CatalystInstanceImpl::initHybrid(</span><br><span class="line">    jni::alias_ref&lt;jclass&gt;) &#123;</span><br><span class="line">   cout&lt;&lt;&quot;===========FMsg:CatalystInstanceImpl initHybrid  called===============&quot;&lt;&lt;endl;</span><br><span class="line">  return makeCxxInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void CatalystInstanceImpl::initializeBridge(</span><br><span class="line">    jni::alias_ref&lt;ReactCallback::javaobject&gt; callback,</span><br><span class="line">    // This executor is actually a factory holder.</span><br><span class="line">    JavaScriptExecutorHolder* jseh,</span><br><span class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; jsQueue,</span><br><span class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; nativeModulesQueue,</span><br><span class="line">    jni::alias_ref&lt;jni::JCollection&lt;JavaModuleWrapper::javaobject&gt;::javaobject&gt; javaModules,</span><br><span class="line">    jni::alias_ref&lt;jni::JCollection&lt;ModuleHolder::javaobject&gt;::javaobject&gt; cxxModules) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt;&quot;===========FMsg:CatalystInstanceImpl initializeBridge===============&quot;&lt;&lt;endl;</span><br><span class="line">    // .............省略部分代码</span><br><span class="line"></span><br><span class="line">  moduleRegistry_ = std::make_shared&lt;ModuleRegistry&gt;(</span><br><span class="line">    buildNativeModuleList(</span><br><span class="line">       std::weak_ptr&lt;Instance&gt;(instance_),</span><br><span class="line">       javaModules,</span><br><span class="line">       cxxModules,</span><br><span class="line">       moduleMessageQueue_));</span><br><span class="line"></span><br><span class="line">  instance_-&gt;initializeBridge(</span><br><span class="line">    std::make_unique&lt;JInstanceCallback&gt;(</span><br><span class="line">    callback,</span><br><span class="line">    moduleMessageQueue_),</span><br><span class="line">    jseh-&gt;getExecutorFactory(),</span><br><span class="line">    folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),</span><br><span class="line">    moduleRegistry_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，Java层的代码执行完毕。我们彻底就进入Native层的代码逻辑了。上面Jni代码中，调用的instance_-&gt;initializeBridge()。 这个逻辑层，我们要到Native层去查找逻辑实现了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Instance::initializeBridge(</span><br><span class="line">    std::unique_ptr&lt;InstanceCallback&gt; callback,</span><br><span class="line">    std::shared_ptr&lt;JSExecutorFactory&gt; jsef,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">    std::shared_ptr&lt;ModuleRegistry&gt; moduleRegistry) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:Instance initializeBridge===============&quot;&lt;&lt;endl;</span><br><span class="line">  callback_ = std::move(callback);</span><br><span class="line">  moduleRegistry_ = std::move(moduleRegistry);</span><br><span class="line">  jsQueue-&gt;runOnQueueSync([this, &amp;jsef, jsQueue]() mutable &#123;</span><br><span class="line">    nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</span><br><span class="line">        jsef.get(), moduleRegistry_, jsQueue, callback_);</span><br><span class="line"></span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m_syncMutex);</span><br><span class="line">    m_syncReady = true;</span><br><span class="line">    m_syncCV.notify_all();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  CHECK(nativeToJsBridge_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上线的代码中。催化器对象在启动的流程中的主要作用就完成了。主要就是将催化器初始化的一些Java、Native、JS层的一些通信对象准备好。</p><p>我们在回过头去，看catalystInstance.runJSBundle()方法的调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void runJSBundle() &#123;</span><br><span class="line">  Log.d(ReactConstants.TAG, &quot;CatalystInstanceImpl.runJSBundle()&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第九步：runJSBundle() called&quot;);</span><br><span class="line">  Assertions.assertCondition(!mJSBundleHasLoaded, &quot;JS bundle was already loaded!&quot;);</span><br><span class="line">  // incrementPendingJSCalls();</span><br><span class="line">  mJSBundleLoader.loadScript(CatalystInstanceImpl.this);</span><br><span class="line"></span><br><span class="line">  synchronized (mJSCallsPendingInitLock) &#123;</span><br><span class="line"></span><br><span class="line">    // Loading the bundle is queued on the JS thread, but may not have</span><br><span class="line">    // run yet.  It&apos;s safe to set this here, though, since any work it</span><br><span class="line">    // gates will be queued on the JS thread behind the load.</span><br><span class="line">    mAcceptCalls = true;</span><br><span class="line"></span><br><span class="line">    for (PendingJSCall function : mJSCallsPendingInit) &#123;</span><br><span class="line">      function.call(this);</span><br><span class="line">    &#125;</span><br><span class="line">    mJSCallsPendingInit.clear();</span><br><span class="line">    mJSBundleHasLoaded = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // This is registered after JS starts since it makes a JS call</span><br><span class="line">  Systrace.registerListener(mTraceListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static JSBundleLoader createFileLoader(</span><br><span class="line">    final String fileName, final String assetUrl, final boolean loadSynchronously) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第九步：createFileLoader() called with: fileName = [&quot; + fileName + &quot;], assetUrl = [&quot; + assetUrl + &quot;], loadSynchronously = [&quot; + loadSynchronously + &quot;]&quot;);</span><br><span class="line">  return new JSBundleLoader() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String loadScript(JSBundleLoaderDelegate delegate) &#123;</span><br><span class="line">      delegate.loadScriptFromFile(fileName, assetUrl, loadSynchronously);</span><br><span class="line">      return fileName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void loadScriptFromFile(String fileName, String sourceURL, boolean loadSynchronously) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第九步：loadScriptFromFile() called with: fileName = [&quot; + fileName + &quot;], sourceURL = [&quot; + sourceURL + &quot;], loadSynchronously = [&quot; + loadSynchronously + &quot;]&quot;);</span><br><span class="line">  mSourceURL = sourceURL;</span><br><span class="line">  jniLoadScriptFromFile(fileName, sourceURL, loadSynchronously);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个jniLoadScriptFromFile也是一个Native的方法，我们可以看到他会调用到CatalystInstanceImpl.cpp的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void CatalystInstanceImpl::jniLoadScriptFromFile(const std::string&amp; fileName,</span><br><span class="line">                                                 const std::string&amp; sourceURL,</span><br><span class="line">                                                 bool loadSynchronously) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:CatalystInstanceImpl jniLoadScriptFromFile===============&quot;&lt;&lt;endl;</span><br><span class="line">  if (Instance::isIndexedRAMBundle(fileName.c_str())) &#123;</span><br><span class="line">    instance_-&gt;loadRAMBundleFromFile(fileName, sourceURL, loadSynchronously);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    std::unique_ptr&lt;const JSBigFileString&gt; script;</span><br><span class="line">    RecoverableError::runRethrowingAsRecoverable&lt;std::system_error&gt;(</span><br><span class="line">      [&amp;fileName, &amp;script]() &#123;</span><br><span class="line">        script = JSBigFileString::fromPath(fileName);</span><br><span class="line">      &#125;);</span><br><span class="line">    instance_-&gt;loadScriptFromString(std::move(script), sourceURL, loadSynchronously);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用到Instancee.cpp的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Instance::loadScriptFromString(std::unique_ptr&lt;const JSBigString&gt; string,</span><br><span class="line">                                    std::string sourceURL,</span><br><span class="line">                                    bool loadSynchronously) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:Instance loadScriptFromString===============&quot;&lt;&lt;endl;</span><br><span class="line">  SystraceSection s(&quot;Instance::loadScriptFromString&quot;, &quot;sourceURL&quot;,</span><br><span class="line">                    sourceURL);</span><br><span class="line">  if (loadSynchronously) &#123;</span><br><span class="line">    loadApplicationSync(nullptr, std::move(string), std::move(sourceURL));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    loadApplication(nullptr, std::move(string), std::move(sourceURL));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Instance::loadApplication(std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">                               std::unique_ptr&lt;const JSBigString&gt; string,</span><br><span class="line">                               std::string sourceURL) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:Instance loadApplication=========string======&quot;&lt;&lt;endl;</span><br><span class="line">  callback_-&gt;incrementPendingJSCalls();</span><br><span class="line">  SystraceSection s(&quot;Instance::loadApplication&quot;, &quot;sourceURL&quot;,</span><br><span class="line">                    sourceURL);</span><br><span class="line">  nativeToJsBridge_-&gt;loadApplication(std::move(bundleRegistry), std::move(string),</span><br><span class="line">                                     std::move(sourceURL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面有调用到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void NativeToJsBridge::loadApplication(</span><br><span class="line">    std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">    std::unique_ptr&lt;const JSBigString&gt; startupScript,</span><br><span class="line">    std::string startupScriptSourceURL) &#123;</span><br><span class="line">   LOG(INFO) &lt;&lt;&quot;===========FMsg:NativeToJsBridge loadApplication===============&quot;&lt;&lt;endl;</span><br><span class="line">  runOnExecutorQueue(</span><br><span class="line">      [this,</span><br><span class="line">       bundleRegistryWrap=folly::makeMoveWrapper(std::move(bundleRegistry)),</span><br><span class="line">       startupScript=folly::makeMoveWrapper(std::move(startupScript)),</span><br><span class="line">       startupScriptSourceURL=std::move(startupScriptSourceURL)]</span><br><span class="line">        (JSExecutor* executor) mutable &#123;</span><br><span class="line">    auto bundleRegistry = bundleRegistryWrap.move();</span><br><span class="line">    if (bundleRegistry) &#123;</span><br><span class="line">      executor-&gt;setBundleRegistry(std::move(bundleRegistry));</span><br><span class="line">    &#125;</span><br><span class="line">     //executor从runOnExecutorQueue()返回的map中取得，与OnLoad中的JSCJavaScriptExecutorHolder对应，也与</span><br><span class="line">     //Java中的JSCJavaScriptExecutor对应。它的实例在JSExecutor.cpp中实现。</span><br><span class="line">    try &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt;&quot;===========FMsg:NativeToJsBridge executor  loadApplicationScript======&quot; &lt;&lt; startupScriptSourceURL &lt;&lt; &quot;。&quot;&lt;&lt;endl;</span><br><span class="line">      executor-&gt;loadApplicationScript(std::move(*startupScript),</span><br><span class="line">                                      std::move(startupScriptSourceURL));</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">      m_applicationScriptHasFailure = true;</span><br><span class="line">      throw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void NativeToJsBridge::runOnExecutorQueue(std::function&lt;void(JSExecutor*)&gt; task) &#123;</span><br><span class="line">  if (*m_destroyed) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;bool&gt; isDestroyed = m_destroyed;</span><br><span class="line">  m_executorMessageQueueThread-&gt;runOnQueue([this, isDestroyed, task=std::move(task)] &#123;</span><br><span class="line">    if (*isDestroyed) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The executor is guaranteed to be valid for the duration of the task because:</span><br><span class="line">    // 1. the executor is only destroyed after it is unregistered</span><br><span class="line">    // 2. the executor is unregistered on this queue</span><br><span class="line">    // 3. we just confirmed that the executor hasn&apos;t been unregistered above</span><br><span class="line">    task(m_executor.get());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们看到他调用了JSIExecutor的loadApplicationScript。下面我们来看一下这个方法的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">void JSIExecutor::loadApplicationScript(</span><br><span class="line">    std::unique_ptr&lt;const JSBigString&gt; script,</span><br><span class="line">    std::string sourceURL) &#123;</span><br><span class="line">  SystraceSection s(&quot;JSIExecutor::loadApplicationScript&quot;);</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:JSIExecutor loadApplicationScript===============sourceURL = &quot; &lt;&lt; sourceURL &lt;&lt; &quot;。&quot; &lt;&lt;endl;</span><br><span class="line">  // TODO: check for and use precompiled HBC</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;nativeModuleProxy&quot;,</span><br><span class="line">      Object::createFromHostObject(</span><br><span class="line">          *runtime_, std::make_shared&lt;NativeModuleProxy&gt;(*this)));</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;nativeFlushQueueImmediate&quot;,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, &quot;nativeFlushQueueImmediate&quot;),</span><br><span class="line">          1,</span><br><span class="line">          [this](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              const jsi::Value &amp;,</span><br><span class="line">              const jsi::Value *args,</span><br><span class="line">              size_t count) &#123;</span><br><span class="line">            if (count != 1) &#123;</span><br><span class="line">              throw std::invalid_argument(</span><br><span class="line">                  &quot;nativeFlushQueueImmediate arg count must be 1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 应该是JSIExecutor⾥里里⾯面callNativeModules中的delegate_-&gt;callNativeModules</span><br><span class="line">            LOG(INFO) &lt;&lt;&quot;===========FMsg:JSIExecutor loadApplicationScript======callNativeModules=======&quot;&lt;&lt;endl;</span><br><span class="line">            callNativeModules(args[0], false);</span><br><span class="line">            return Value::undefined();</span><br><span class="line">          &#125;));</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;nativeCallSyncHook&quot;,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, &quot;nativeCallSyncHook&quot;),</span><br><span class="line">          1,</span><br><span class="line">          [this](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              const jsi::Value &amp;,</span><br><span class="line">              const jsi::Value *args,</span><br><span class="line">              size_t count) &#123; return nativeCallSyncHook(args, count); &#125;));</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;globalEvalWithSourceUrl&quot;,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, &quot;globalEvalWithSourceUrl&quot;),</span><br><span class="line">          1,</span><br><span class="line">          [this](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              const jsi::Value &amp;,</span><br><span class="line">              const jsi::Value *args,</span><br><span class="line">              size_t count) &#123; return globalEvalWithSourceUrl(args, count); &#125;));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  if (runtimeInstaller_) &#123;</span><br><span class="line">    runtimeInstaller_(*runtime_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool hasLogger(ReactMarker::logTaggedMarker);</span><br><span class="line">  std::string scriptName = simpleBasename(sourceURL);</span><br><span class="line">  if (hasLogger) &#123;</span><br><span class="line">    ReactMarker::logTaggedMarker(</span><br><span class="line">        ReactMarker::RUN_JS_BUNDLE_START, scriptName.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  //使用Webkit JSC去解释执行JS</span><br><span class="line">  runtime_-&gt;evaluateJavaScript(</span><br><span class="line">      std::make_unique&lt;BigStringBuffer&gt;(std::move(script)), sourceURL);</span><br><span class="line">  flush();</span><br><span class="line">  if (hasLogger) &#123;</span><br><span class="line">    ReactMarker::logMarker(ReactMarker::CREATE_REACT_CONTEXT_STOP);</span><br><span class="line">    ReactMarker::logTaggedMarker(</span><br><span class="line">        ReactMarker::RUN_JS_BUNDLE_STOP, scriptName.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后代码调用到evaluateJavaScript方法中。这个方法的实现JSCRuntime.cpp中。我们简简单看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jsi::Value JSCRuntime::evaluateJavaScript(</span><br><span class="line">    const std::shared_ptr&lt;const jsi::Buffer&gt; &amp;buffer,</span><br><span class="line">    const std::string&amp; sourceURL) &#123;</span><br><span class="line">  // LOG(INFO) &lt;&lt;&quot;===========FMsg:JSCRuntime evaluateJavaScript===============sourceURL = &quot; &lt;&lt; sourceURL &lt;&lt; &quot;。&quot; &lt;&lt;endl;</span><br><span class="line">  std::string tmp(</span><br><span class="line">      reinterpret_cast&lt;const char*&gt;(buffer-&gt;data()), buffer-&gt;size());</span><br><span class="line">  JSStringRef sourceRef = JSStringCreateWithUTF8CString(tmp.c_str());</span><br><span class="line">  JSStringRef sourceURLRef = nullptr;</span><br><span class="line">  if (!sourceURL.empty()) &#123;</span><br><span class="line">    sourceURLRef = JSStringCreateWithUTF8CString(sourceURL.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  JSValueRef exc = nullptr;</span><br><span class="line">  JSValueRef res =</span><br><span class="line">      JSEvaluateScript(ctx_, sourceRef, nullptr, sourceURLRef, 0, &amp;exc);</span><br><span class="line">  JSStringRelease(sourceRef);</span><br><span class="line">  if (sourceURLRef) &#123;</span><br><span class="line">    JSStringRelease(sourceURLRef);</span><br><span class="line">  &#125;</span><br><span class="line">  checkException(res, exc);</span><br><span class="line">  return createValue(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们我们开始加载JSBundle的逻辑已经执行完毕。但是这个时候其实ReactNative并没有启动起来。</p><p>我们下面来看一下启动流程的最后一步：</p><p>我们来回到ReactRootView的startReactApplication这个方法中的最后一步：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void attachToReactInstanceManager() &#123;</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;attachToReactInstanceManager&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:attachToReactInstanceManager() called&quot;);</span><br><span class="line">  try &#123;</span><br><span class="line">    if (mIsAttachedToInstance) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsAttachedToInstance = true;</span><br><span class="line">      // ReactInstanceManager绑定到当前的RootView</span><br><span class="line">    Assertions.assertNotNull(mReactInstanceManager).attachRootView(this);</span><br><span class="line">    getViewTreeObserver().addOnGlobalLayoutListener(getCustomGlobalLayoutListener());</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，我们来看attachRootView的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void attachRootView(ReactRoot reactRoot) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:attachRootView() called with: reactRoot = [&quot; + reactRoot + &quot;]&quot;);</span><br><span class="line">  UiThreadUtil.assertOnUiThread();</span><br><span class="line">  // ReactInstanceManager 是支持多 RootView 的.其实这个地方大家可以猜想，其实我们的ReactNative的页面，可以作为一个小的页面View</span><br><span class="line">  // 附着到宿主Activity上。</span><br><span class="line">  mAttachedReactRoots.add(reactRoot);</span><br><span class="line"></span><br><span class="line">  // Reset reactRoot content as it&apos;s going to be populated by the application content from JS.</span><br><span class="line">  clearReactRoot(reactRoot);</span><br><span class="line"></span><br><span class="line">  // If react context is being created in the background, JS application will be started</span><br><span class="line">  // automatically when creation completes, as reactRoot reactRoot is part of the attached</span><br><span class="line">  // reactRoot reactRoot list.</span><br><span class="line">  ReactContext currentContext = getCurrentReactContext();</span><br><span class="line">  if (mCreateReactContextThread == null &amp;&amp; currentContext != null) &#123;</span><br><span class="line">    // 最后，取出 ReactContext，让 ReactRootView 与 CatalystInstance 相关联：</span><br><span class="line">    attachRootViewToInstance(reactRoot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private void attachRootViewToInstance(final ReactRoot reactRoot) &#123;</span><br><span class="line">  Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.attachRootViewToInstance()&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第十步：attachRootViewToInstance() called with: reactRoot = [&quot; + reactRoot + &quot;]&quot;);</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;attachRootViewToInstance&quot;);</span><br><span class="line"></span><br><span class="line">  // 首先通过 UIManagerHelper 拿到 UIManager：</span><br><span class="line">  // UIManager 是什么呢？它有两个实现类：FabricUIManager、UIManagerModule</span><br><span class="line">  // 我们来看后者，它的注释中说：这是一个原生模块，允许JS创建和更新原生视图。其实这个就是我们后来看RN的渲染流程中非常重要的类</span><br><span class="line">  UIManager uiManager =</span><br><span class="line">      UIManagerHelper.getUIManager(mCurrentReactContext, reactRoot.getUIManagerType());</span><br><span class="line"></span><br><span class="line">  @Nullable Bundle initialProperties = reactRoot.getAppProperties();</span><br><span class="line"></span><br><span class="line">  final int rootTag =</span><br><span class="line">      uiManager.addRootView(</span><br><span class="line">          reactRoot.getRootViewGroup(),</span><br><span class="line">          initialProperties == null</span><br><span class="line">              ? new WritableNativeMap()</span><br><span class="line">              : Arguments.fromBundle(initialProperties),</span><br><span class="line">          reactRoot.getInitialUITemplate());</span><br><span class="line">  reactRoot.setRootViewTag(rootTag);</span><br><span class="line">  if (reactRoot.getUIManagerType() == FABRIC) &#123;</span><br><span class="line">    // Fabric requires to call updateRootLayoutSpecs before starting JS Application,</span><br><span class="line">    // this ensures the root will hace the correct pointScaleFactor.</span><br><span class="line">    uiManager.updateRootLayoutSpecs(</span><br><span class="line">        rootTag, reactRoot.getWidthMeasureSpec(), reactRoot.getHeightMeasureSpec());</span><br><span class="line">    reactRoot.setShouldLogContentAppeared(true);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第十步：attachRootViewToInstance() called with: reactRoot = [&quot; + reactRoot + &quot;]&quot;);</span><br><span class="line">    // 这个方法就是我们真的去调用JS的相关代码，我们可以看看这个代码</span><br><span class="line">    reactRoot.runApplication();</span><br><span class="line">  &#125;</span><br><span class="line">  Systrace.beginAsyncSection(</span><br><span class="line">      TRACE_TAG_REACT_JAVA_BRIDGE, &quot;pre_rootView.onAttachedToReactInstance&quot;, rootTag);</span><br><span class="line">  // 这个地方其实，我们有疑问：</span><br><span class="line">  // 为什么使用UiThreadUtil.runOnUiThread。而不是</span><br><span class="line">  //  mCurrentReactContext.runOnUiQueueThread();???</span><br><span class="line">  UiThreadUtil.runOnUiThread(</span><br><span class="line">      new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">          Systrace.endAsyncSection(</span><br><span class="line">              TRACE_TAG_REACT_JAVA_BRIDGE, &quot;pre_rootView.onAttachedToReactInstance&quot;, rootTag);</span><br><span class="line">          reactRoot.onStage(ReactStage.ON_ATTACH_TO_INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的最后一步，我们就可以看到reactRoot.runApplication()  这个方法很明显，就是运行起来JS的相关代码逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void runApplication() &#123;</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;ReactRootView.runApplication&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第十一步：ReactRootView runApplication() called&quot;);</span><br><span class="line">  try &#123;</span><br><span class="line">    if (mReactInstanceManager == null || !mIsAttachedToInstance) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();</span><br><span class="line">    if (reactContext == null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CatalystInstance catalystInstance = reactContext.getCatalystInstance();</span><br><span class="line">    String jsAppModuleName = getJSModuleName();</span><br><span class="line"></span><br><span class="line">    if (mUseSurface) &#123;</span><br><span class="line">      // TODO call surface&apos;s runApplication</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (mWasMeasured) &#123;</span><br><span class="line">        updateRootLayoutSpecs(mWidthMeasureSpec, mHeightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      WritableNativeMap appParams = new WritableNativeMap();</span><br><span class="line">      appParams.putDouble(&quot;rootTag&quot;, getRootViewTag());</span><br><span class="line">      @Nullable Bundle appProperties = getAppProperties();</span><br><span class="line">      if (appProperties != null) &#123;</span><br><span class="line">        appParams.putMap(&quot;initialProps&quot;, Arguments.fromBundle(appProperties));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mShouldLogContentAppeared = true;</span><br><span class="line">      Log.i(TAG, &quot;FMsg: 第十步：==============runApplication: ==========================&quot; + jsAppModuleName);</span><br><span class="line">      Log.i(TAG, &quot;FMsg: 第十步：==============runApplication: ==========================&quot; + appParams);</span><br><span class="line">      catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也是比较简单的。通过ReactContext的实例，拿到催化器实例。然后通过催化器实例获取JSModule的runApplication</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T extends JavaScriptModule&gt; T getJSModule(Class&lt;T&gt; jsInterface) &#123;</span><br><span class="line">  // Log.d(TAG, &quot;FMsg:getJSModule() called with: jsInterface = [&quot; + jsInterface + &quot;]&quot;);</span><br><span class="line">  // mJSModuleRegistry注入器获取当前的注入器。至于怎么去获取的。我们可以再分析</span><br><span class="line">  return mJSModuleRegistry.getJavaScriptModule(this, jsInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，最终调用的是 catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams) ， AppRegistry.class 是JS层暴露给Java层的接口方法。它的真正实现在 AppRegistry.js 里， AppRegistry.js 是运行所有 RN 应用的 JS 层入口，我们来看看它的实现：在 Libraries/ReactNative 中的 AppRegistry.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Loads the JavaScript bundle and runs the app.</span><br><span class="line"> *</span><br><span class="line"> * See http://facebook.github.io/react-native/docs/appregistry.html#runapplication</span><br><span class="line"> */</span><br><span class="line">runApplication(appKey: string, appParameters: any): void &#123;</span><br><span class="line">  const msg =</span><br><span class="line">    &apos;Running &quot;&apos; + appKey + &apos;&quot; with &apos; + JSON.stringify(appParameters);</span><br><span class="line">  infoLog(msg);</span><br><span class="line">  BugReporting.addSource(</span><br><span class="line">    &apos;AppRegistry.runApplication&apos; + runCount++,</span><br><span class="line">    () =&gt; msg,</span><br><span class="line">  );</span><br><span class="line">  invariant(</span><br><span class="line">    runnables[appKey] &amp;&amp; runnables[appKey].run,</span><br><span class="line">    `&quot;$&#123;appKey&#125;&quot; has not been registered. This can happen if:\n` +</span><br><span class="line">      &apos;* Metro (the local dev server) is run from the wrong folder. &apos; +</span><br><span class="line">      &apos;Check if Metro is running, stop it and restart it in the current project.\n&apos; +</span><br><span class="line">      &quot;* A module failed to load due to an error and `AppRegistry.registerComponent` wasn&apos;t called.&quot;,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  SceneTracker.setActiveScene(&#123;name: appKey&#125;);</span><br><span class="line">  runnables[appKey].run(appParameters);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>到这里就会去调用JS进行渲染，在通过 UIManagerModule 将JS组件转换成Android组件，最终显示在 ReactRootView 上。</p><p>最后总结一下，就是先在应用终端启动并创建上下文对象，启动 JS Runtime ，进行布局，将JS端的代码通过C++层， UIManagerMoodule 转化成 Android 组件，再进行渲染，最后将渲染的View添加到 ReactRootView 上，最终呈现在用户面前。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ReactNative；Android； </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建型模式-单例模式（Singleton Pattern）</title>
      <link href="/2019/06/13/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%20Pattern%EF%BC%89/"/>
      <url>/2019/06/13/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton%20Pattern%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>文章参考：<a href="：https://blog.csdn.net/zhengzhb/article/details/7331354">https://blog.csdn.net/zhengzhb/article/details/7331354</a></p><h3 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h3><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个打印机，只能有一个正在工作的任务。一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的必要性。</p><h3 id="设计模式定义"><a href="#设计模式定义" class="headerlink" title="设计模式定义"></a>设计模式定义</h3><p>单例模式(Singleton Pattern)确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。</p><p>单例模式是一种创建型模式，指某个类采用Singleton模式，则在这个类被创建后，只可能产生一个实例供外部访问，并且提供一个全局的访问点。单例模式的要点有三个：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。单例模式又名单件模式或单态模式。</p><p> 核心知识点如下：</p><ul><li>(1) 将采用单例设计模式的类的构造方法私有化（采用private修饰）。</li><li>(2) 在其内部产生该类的实例化对象，并将其封装成private static类型。</li><li>(3) 定义一个静态方法返回该类的实例。</li></ul><h3 id="UML图设计"><a href="#UML图设计" class="headerlink" title="UML图设计"></a>UML图设计</h3><p><img src="/img/loading.gif" class="lazyload" data-src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190804172909-singletonuml.png"  alt="image"></p><!--![image](http://note.youdao.com/yws/res/37552/BF1447069BDA4353B90B55D2316660DE)--><h3 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h3><p>优点：　</p><ul><li>1、提供了对唯一实例，并且自行实例化并向整个系统提供这个实例；</li><li>2、Java中频繁创建和销毁类对象都会占用一部分系统资源，使用单例模式可以提高性能；</li><li>3、允许可变数量的实例；</li></ul><p>缺点：</p><ul><li></li><li>1、单例模式中，没有抽象层，所以对于单例类的扩展并不方便；</li><li>2、单例类的职责过重，在一定程度上违背了“单一职责原则”；</li><li>3、滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失；</li></ul><h3 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h3><h4 id="1-饿汉式单例"><a href="#1-饿汉式单例" class="headerlink" title="1.饿汉式单例."></a>1.饿汉式单例.</h4><p>这种方式基于classloader机制避免了多线程的同步问题，单例对象在类装载时就实例化。所以饿汉式是用空间来换时间，解决了线程同步的问题。</p><p>优点是：写起来比较简单，而且不存在多线程同步问题，避免了synchronized所造成的性能问题；</p><p>缺点是：当类SingletonTest被加载的时候，会初始化static的instance，静态变量被创建并分配内存空间，从这以后，这个static的instance对象便一直占着这段内存（即便你还没有用到这个实例），当类被卸载时，静态变量被摧毁，并释放所占有的内存，因此在某些特定条件下会耗费内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton INSTANCE = new Singleton();</span><br><span class="line">　private Singleton() &#123;&#125;</span><br><span class="line">　public static Singleton getInstance() &#123;</span><br><span class="line">     return INSTANCE;   </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="2-懒汉式单例。"><a href="#2-懒汉式单例。" class="headerlink" title="2.懒汉式单例。"></a>2.懒汉式单例。</h4><p>懒汉式主要是用时间来换空间。主要当单例在使用的时候才会检查是否初始化对象。在多线程情况下，同时调用入口方法获取实例时可能无法正常工作，所以懒汉式单例是非线程安全的。</p><p>优点是：写起来比较简单，当类Singleton被加载的时候，静态变量static的instance未被创建并分配内存空间，当getInstance方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存；</p><p>缺点是：并发环境下很可能出现多个Singleton实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//懒汉单例，线程不安全，当启动多线程，同时获取多个实例时会报错</span><br><span class="line">  private static Singleton INSTANCE = null;</span><br><span class="line">  private Singleton() &#123;&#125;</span><br><span class="line">  public static Singleton getInstance() &#123;</span><br><span class="line">       if(INSTANCE == null) &#123;</span><br><span class="line">           INSTANCE = new Singleton();</span><br><span class="line">       &#125;</span><br><span class="line">       return INSTANCE;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>当然，懒汉式也可以解决非线程安全的问题。那就是给getInstance()方法加上synchronized锁。</p><p>优点是：使用synchronized关键字避免多线程访问时，出现多个Singleton实例。</p><p>缺点是：同步方法频繁调用时，效率略低。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static Singleton INSTANCE = null;</span><br><span class="line">   private Singleton() &#123;&#125;</span><br><span class="line">   public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if(INSTANCE == null) &#123;</span><br><span class="line">            INSTANCE = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-Double-Check-Lock-DCL-双重锁定-实现单例"><a href="#3-Double-Check-Lock-DCL-双重锁定-实现单例" class="headerlink" title="3.Double Check Lock(DCL 双重锁定)实现单例"></a>3.Double Check Lock(DCL 双重锁定)实现单例</h4><p>我们把上面的懒汉式进行优化修改一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//懒汉单例，线程不安全，当启动多线程，同时获取多个实例时会报错</span><br><span class="line">   private static Singleton INSTANCE = null;</span><br><span class="line">   private Singleton() &#123;&#125;</span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">        if(INSTANCE == null) &#123;</span><br><span class="line">            synchronized(Singleton.class)&#123;</span><br><span class="line">                if(null ==INSTANCE)&#123;</span><br><span class="line">                    INSTANCE = new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> 我们来着重分析一下getInstance方法.我们可以看到getInstance方法中对instance进行了两次判空。第一层判空主要是为了避免不必要的多次同步。第二层判空则是为了在null的情况才创造实例对象。这是什么意思呢？是不是有点摸不着头脑，我们就来着重分析一下。</p><p> 假设线程A执行到mInstance = new Singleton()语句，在这里看起来是一句代码，其实他并不是一个原子操作。这句代码最终会被编译成多条汇编指令，他大致做了三件事情：</p><ul><li>（一）给Singleton的实例分配内存</li><li>（二）调用Singleton的构造方法，初始化成员字段</li><li>（三）将mInstance的对象指向分配的内存空间（此时mInstance就不是null了）。</li></ul><p>但是，由于Java编译器允许处理器乱序执行。以及JDK1.5之前JMM（Java内存模型）中cache、寄存器到主存回写顺序的规定。上面的第二步和第三步的顺序是不固定的。所以执行属性有可能是1-2-3或者1-3-2。如果是后者，3执行完，但是2未执行。被切换到线程b上。这时候mInstance因为已经在线程b上执行了第三步，所以mInstance已经不为空了。所以线程b执行取走了mInstance对象（但是，此时Singleton的对象并没有初始化）所以这个时候使用就会出错了。这就是DCL失效问题。</p><p>在JDK1.5以后。SUN官方已经注意到这个问题了。调整了JVM。集体化了Volatile关键字。如果是JDK1.5之后的版本。则只需要向下面来声明单例对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private volatile static Singleton INSTANCE = null;</span><br></pre></td></tr></table></figure><p>这样就可以保证每次取用INSTANCE对象的时候，都是从主内存中取对象。这样使用DCL就可以保证对象单例。但是，当时使用volatile或多或少也会影响到性能。但是考虑到程序的正确性。牺牲掉这点性能是值得的。</p><p>DCL的方法优点：资源利用率高，第一次执行getInstance()时候单例对象才会被实例化，效率高。</p><p>缺点是第一次加载的时候反应有点慢</p><h4 id="4-静态内部类实现单例"><a href="#4-静态内部类实现单例" class="headerlink" title="4.静态内部类实现单例"></a>4.静态内部类实现单例</h4><p>静态内部类实现单例跟饿汉模式有点类似，只是在类装载的时候，SingletonHolder并没有被主动使用，只有显式调用getInstance方法是，才会调用装载SingletoHolder类，从而实例化instance，既实现了线程安全，又避免了同步带来的性能影响。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class OptimusNetWork &#123;</span><br><span class="line"></span><br><span class="line">    private final OptimusNetClient mHttpClient;</span><br><span class="line"></span><br><span class="line">    private OptimusNetWork() &#123;</span><br><span class="line">        mHttpClient = new OptimusNetClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 我们定义一个静态内部类，来作为单例对象的持有者</span><br><span class="line">    private static class OptimusNetWorkHolder &#123;</span><br><span class="line">        private static final OptimusNetWork INSTANCE = new OptimusNetWork();</span><br><span class="line">    &#125;</span><br><span class="line">    // 所有只有调用getInstance的时候，才会调用OptimusNetWorkHolder。从而实例化OptimusNetWork</span><br><span class="line">    public final static OptimusNetWork getInstance() &#123;</span><br><span class="line">        return OptimusNetWorkHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-枚举实现的单例"><a href="#5-枚举实现的单例" class="headerlink" title="5.枚举实现的单例"></a>5.枚举实现的单例</h4><p>有没有个更简单的实现单例的方式。</p><p>目前最为安全的实现单例的方法是通过内部静态enum的方法来实现，因为JVM会保证enum不能被反射并且构造器方法只执行一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class EnumSingleton()&#123;</span><br><span class="line">    //EnumSingleton 私有构造函数 </span><br><span class="line">private EnumSingleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">    public static EnumSingleton getInstance()&#123;</span><br><span class="line">    SingletonEnum.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">    private static enum SingletonEnum() &#123;</span><br><span class="line">          INSTANCE;</span><br><span class="line">          public void doSomething()&#123;</span><br><span class="line">              System.out.println(&quot;do sth&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-使用容器实现单例"><a href="#6-使用容器实现单例" class="headerlink" title="6.使用容器实现单例"></a>6.使用容器实现单例</h4><p>这个就比较不常用了。所以我们暂时就先不介绍他了。</p><h3 id="问题思考：单例模式与垃圾回收"><a href="#问题思考：单例模式与垃圾回收" class="headerlink" title="问题思考：单例模式与垃圾回收"></a>问题思考：单例模式与垃圾回收</h3><p>我们先来思考一个问题：当一个单例的对象长久不用时，会不会被jvm的垃圾收集机制回收??</p><p> 首先说一下为什么会产生这一疑问，笔者本人再此之前从来没有考虑过垃圾回收对单例模式的影响，直到去年读了一本书，《设计模式之禅》秦小波著。在书中提到在j2ee应用中，jvm垃圾回收机制会把长久不用的单例类对象当作垃圾，并在cpu空闲的时候对其进行回收。之前读过的几本设计模式的书，包括《java与模式》，书中都没有提到jvm垃圾回收机制对单例的影响。并且在工作过程中，也没有过单例对象被回收的经历，加上工作中很多前辈曾经告诫过笔者：尽量不要声明太多的静态属性，因为这些静态属性被加载后不会被释放。因此对jvm垃圾收集会回收单例对象这一说法持怀疑态度。渐渐地，发现在同事中和网上的技术人员中，对这一问题也基本上是鲜明的对立两派。那么到底jvm会不会回收长久不用的单例对象呢。</p><p> 所以到底会不会回收。我们特地写了一段代码来进行验证。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Singleton &#123;</span><br><span class="line">private byte[] a = new byte[6*1024*1024];</span><br><span class="line">private static Singleton singleton = new Singleton();</span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">return singleton;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Obj &#123;</span><br><span class="line">private byte[] a = new byte[3*1024*1024];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Client&#123;</span><br><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">Singleton.getInstance();</span><br><span class="line">while(true)&#123;</span><br><span class="line">new Obj();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本段程序的目的是模拟j2ee容器，首先实例化单例类，这个单例类占6M内存，然后程序进入死循环，不断的创建对象，逼迫jvm进行垃圾回收，然后观察垃圾收集信息，如果进行垃圾收集后，内存仍然大于6M，则说明垃圾回收不会回收单例对象。运行本程序使用的虚拟机是hotspot虚拟机，也就是我们使用的最多的java官方提供的虚拟机，俗称jdk，版本是jdk1.6.0_12 运行时vm arguments参数为：-verbose:gc -Xms20M -Xmx20M，意思是每次jvm进行垃圾回收时显示内存信息，jvm的内存设为固定20M。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">……</span><br><span class="line"></span><br><span class="line">[Full GC 18566K-&gt;6278K(20352K), 0.0101066 secs]</span><br><span class="line"></span><br><span class="line">[GC 18567K-&gt;18566K(20352K), 0.0001978 secs]</span><br><span class="line"></span><br><span class="line">[Full GC 18566K-&gt;6278K(20352K), 0.0088229 secs]</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure><p> 从运行结果中可以看到总有6M空间没有被收集。因此，笔者认为，至少在hotspot虚拟机中，垃圾回收是不会回收单例对象的。</p><p>后来查阅了一些相关的资料，hotspot虚拟机的垃圾收集算法使用根搜索算法。这个算法的基本思路是：对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。通过一系列名为根（GC Roots）的引用作为起点，从这些根开始搜索，经过一系列的路径，如果可以到达java堆中的对象，那么这个对象就是“活”的，是不可回收的。可以作为根的对象有：</p><ul><li>1、虚拟机栈（栈桢中的本地变量表）中的引用的对象。</li><li>2、方法区中的类静态属性引用的对象。</li><li>3、方法区中的常量引用的对象。</li><li>4、本地方法栈中JNI的引用的对象。</li></ul><p>方法区是jvm的一块内存区域，用来存放类相关的信息。很明显，java中单例模式创建的对象被自己类中的静态属性所引用，符合第二条，因此，单例对象不会被jvm垃圾收集。</p><p>虽然jvm堆中的单例对象不会被垃圾收集，但是单例类本身如果长时间不用会不会被收集呢？因为jvm对方法区也是有垃圾收集机制的。如果单例类被收集，那么堆中的对象就会失去到根的路径，必然会被垃圾收集掉。jvm卸载类的判定条件如下：</p><ul><li>该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>只有三个条件都满足，jvm才会在垃圾收集的时候卸载类。显然，单例的类不满足条件一，因此单例类也不会被卸载。也就是说，只要单例类中的静态引用指向jvm堆中的单例对象，那么单例类和单例对象都不会被垃圾收集，依据根搜索算法，对象是否会被垃圾收集与未被使用时间长短无关，仅仅在于这个对象是不是“活”的。假如一个对象长久未使用而被回收，那么收集算法应该是最近最长未使用算法，最近最长未使用算法一般用在操作系统的内外存交换中，如果用在虚拟机垃圾回收中，岂不是太不安全了？以上是笔者的观点。</p><p>因此笔者的观点是：<strong>在hotspot虚拟机1.6版本中，除非人为地断开单例中静态引用到单例对象的联接，否则jvm垃圾收集器是不会回收单例对象的。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式；单例模式； </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类学习之HashMap基础知识学习（基于JDK1.8.0_181）</title>
      <link href="/2019/01/13/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E4%BA%8EJDK1.8.0_181%EF%BC%89/"/>
      <url>/2019/01/13/Java%E9%9B%86%E5%90%88%E7%B1%BB%E5%AD%A6%E4%B9%A0%E4%B9%8BHashMap%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9F%BA%E4%BA%8EJDK1.8.0_181%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>文章参考 <a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/06/24/java-hashmap.html</a></p><p>开始文章之前，我们先来思考几个问题：</p><ul><li>1、初始化的容量为什么是16？</li><li>2、存储元素的数组的长度为什么都是2的幂次倍？</li><li>3、JDK7之后，为什么引入了红黑树？？引入红黑树有什么作用？？</li><li>3、红黑树的转化策略</li><li>4、HashMap的树形化的阈值为什么是8。列表化的阈值为什么是6.</li><li>5、HashMap的树形化的时机，还有什么限制？？</li></ul><p>以上这个问题的答案：肯定都是为了性能撒！！</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HashMap是基于拉链法实现的一个散列表，它存储的内容是键值对(key-value)映射,内部由数组和链表和红黑树实现。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它不是线程安全的。如果我们想要保证同步，可以考虑使用HashTable或者是ConcurrentHashMap。<br>HashMap的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>下面我们来对照源码类分析一下Hashmap的源码，来分析HashMap的工作原理。</p><p>首先，我们来看一下，HashMap的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 默认的加载因子</span><br><span class="line"> */</span><br><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">// 无参构造函数</span><br><span class="line">public HashMap() &#123;</span><br><span class="line">    // 初始化填充因子.默认为0.75f</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 传入初始化容量的含参构造函数</span><br><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">    // 调用HashMap(int, float)型构造函数</span><br><span class="line">    this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 自定义初始化容量和默认填充因子的构造函数</span><br><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    // 初始容量不能小于0，否则报错</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                                            initialCapacity);</span><br><span class="line">    // 初始容量不能大于最大值，否则为最大值</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    // 填充因子不能小于或等于0，不能为非数字</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                            loadFactor);</span><br><span class="line">    // 初始化填充因子</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    /// 这个方法可以将任意一个整数转换大约的最小成2的幂次方。</span><br><span class="line">    // 例如输入10，则会返回16。</span><br><span class="line">    // 另外，有人可能疑惑，不是说threshold是 数组容量 * loadFactor得到的吗？</span><br><span class="line">    // 是的，但是在第一次put操作，扩充数组时，会将这个threshold作为数组容量，然后再重新计算这个值。</span><br><span class="line">    // 这个方法的具体实现我们下面解析</span><br><span class="line">    this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 以Map作为参数的构造函数</span><br><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">    // 初始化填充因子</span><br><span class="line">    this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    // 将m中的所有元素添加至HashMap中，这个方法我们下面分析</span><br><span class="line">    putMapEntries(m, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们来看一下类的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 默认的初始容量是16,为什么默认是16，后面我们会解释道</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 最大容量 2的30次幂</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍。Node则是链表节点对象。</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table;</span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子，但是第一次不是)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 填充因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Hasp的重点方法解析"><a href="#4、Hasp的重点方法解析" class="headerlink" title="4、Hasp的重点方法解析"></a>4、Hasp的重点方法解析</h3><pre><code>请注意。我们是以JDK1.8.0_181版本来分析的。不同的JDK版本可能在实现有不同，但是基本思想都是一致的。</code></pre><h4 id="4-1、HashMap的put-存放元素"><a href="#4-1、HashMap的put-存放元素" class="headerlink" title="4.1、HashMap的put() 存放元素"></a>4.1、HashMap的put() 存放元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这个是非常重要的方法！！！</span><br><span class="line"> * 所以我们着重分析一下</span><br><span class="line"> * 这个方法是将对应的value与对应的key进行关联，存放到Map中</span><br><span class="line"> * 如果原来Map中有对应key的value.那么便会更新为入参value</span><br><span class="line"> */</span><br><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">    // 这个方法调用了putVal()。入参的时候调用hash(key)这个方法代码中有讲解</span><br><span class="line">    return putVal(hash(key), key, value, false, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 从上面我们可以看到put()方法调用了这个方法。</span><br><span class="line"> * onlyIfAbsent：当存入键值对时，如果该key已存在，是否覆盖它的value。false为覆盖，true为不覆盖 *参考putIfAbsent()方法。</span><br><span class="line"> * evict：用于子类LinkedHashMap。 也就是说在hashmap是没有用的</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> * 下面我们简单介绍一下这个方法：</span><br><span class="line"> *          1.检查数组是否为空，执行resize()扩充；</span><br><span class="line"> *          2.通过hash值计算数组索引，获取该索引位的首节点。 </span><br><span class="line"> *          3.如果首节点为null（没发生碰撞） ，</span><br><span class="line"> *          直接添加节点到该索引位 (bucket) 。 </span><br><span class="line"> *          4.如果首节点不为null （发生碰撞） ，</span><br><span class="line"> *          那么有3种情况 ：</span><br><span class="line"> *              ① key和首节点的key相同，覆盖old value （保证key的唯一性） ；</span><br><span class="line"> *          否则执行②或③ </span><br><span class="line"> *              ② 如果首节点是红黑树节点（TreeNode），将键值对添加到红黑树。 </span><br><span class="line"> *              ③ 如果首节点是链表，将键值对添加到链表。添加之后会判断链表长度是否到达TREEIFY_THRESHOLD - 1这个阈值，“尝试”将链表转换成红黑树。 </span><br><span class="line"> *          5.最后判断当前元素个数是否大于threshold，扩充数组。</span><br><span class="line"> */</span><br><span class="line">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">               boolean evict) &#123;</span><br><span class="line">    // 声明hash桶的内部数组临时变量tab     </span><br><span class="line">    // p：hash对应的索引位中的首节点 </span><br><span class="line">    // n：内部数组的长度    i：hash对应的索引位</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">    // 条件一:table为null 或者table数组长度为0。</span><br><span class="line">    if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">        n = (tab = resize()).length;  // 执行扩容操作，并计算数组长度</span><br><span class="line">    // i = (n-1)&amp;hash 计算index值。如果为null 那么通过newNode来构建hash桶的这个节点</span><br><span class="line">    if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">        // 创建一个新的节点</span><br><span class="line">        tab[i] = newNode(hash, key, value, null);</span><br><span class="line">    else &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">         //节点key存在，直接覆盖value</span><br><span class="line">        if (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        // 如果判断当前链是红黑树    </span><br><span class="line">        else if (p instanceof TreeNode)</span><br><span class="line">            // 则执行红黑树的插入值的相关操作</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">         // 此时首节点为链表，如果链表中存在该键值对，直接覆盖value。</span><br><span class="line">        // 如果不存在，则在末端插入键值对。然后判断链表是否大于等于7，尝试转换成红黑树。</span><br><span class="line">         // 注意此处使用“尝试”，因为在treeifyBin方法中还会判断当前数组容量是否到达64，</span><br><span class="line">        // 否则会放弃次此转换，优先扩充数组容量。    </span><br><span class="line">        else &#123;</span><br><span class="line">        // 如果p节点不是为空，也不是为红黑树，那就是普通的链表</span><br><span class="line">        // 走到这里，hash碰撞了。检查链表中是否包含key，或将键值对添加到链表末尾</span><br><span class="line">            for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">            // p.next == null，到达链表末尾，添加新节点，如果长度足够，转换成树结构。</span><br><span class="line">                if ((e = p.next) == null) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, null);</span><br><span class="line">                     //链表长度大于7转换为红黑树进行处理</span><br><span class="line">                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果对应的Key已经存在则直接覆盖Value即可</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    break;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e != null) &#123; // existing mapping for key</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    // 如果超过最大的扩容林接着，则进行扩容</span><br><span class="line">    if (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-2、HashMap的get-存放元素。"><a href="#4-2、HashMap的get-存放元素。" class="headerlink" title="4.2、HashMap的get() 存放元素。"></a>4.2、HashMap的get() 存放元素。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 我们根据key来获取Node的节点数据</span><br><span class="line"> */</span><br><span class="line">public V get(Object key) &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    // 根据key来计算对应的Hash值，通过key的hash值和key来获取对应的Value</span><br><span class="line">    // 下面我们来看getNode方法</span><br><span class="line">    return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 获取HashMap的Node节点</span><br><span class="line"> */</span><br><span class="line">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">    //tab：内部数组  first: 索引位首节点 n: 数组长度 k: 索引位首节点的key</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">    </span><br><span class="line">    //数组不为null 数组长度大于0 定位到数组中的索引处。并判断索引位首节点不为null</span><br><span class="line">    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">       </span><br><span class="line">        // i = (n - 1) &amp; hash ，n是数组长度，hash就是通过hash()方法进行高低位异或运算得出来的hash值。 //这个表达式就是hash值的取模运算，上面已经说过当除数为2的次方时，可以用与运算提高性能。</span><br><span class="line">        // 所以这里也就是解决了我们为什么要将数组长度取2的N次方</span><br><span class="line">        </span><br><span class="line">        (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        </span><br><span class="line">        // 如果索引位首节点的hash==key的hash 或者 key和索引位首节点的k相同</span><br><span class="line">        if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">             // 返回索引位首节点(值对象)</span><br><span class="line">            return first;</span><br><span class="line">        //  </span><br><span class="line">        if ((e = first.next) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                // 如果是红黑色则到红黑树中查找.</span><br><span class="line">                // getNode的方法比较简单，下面我们就来看getTreeNode的方法实现</span><br><span class="line">                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            // 否则就在链表中进行遍历朝朝。找到就返回e    </span><br><span class="line">            do &#123;</span><br><span class="line">                if (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                    return e;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-resize-数组扩容"><a href="#4-3-resize-数组扩容" class="headerlink" title="4.3 resize() 数组扩容"></a>4.3 resize() 数组扩容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">final HashMap.Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 如果数组已经是最大长度，不进行扩充。</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则数组容量扩充一倍。（2的N次方）</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果数组还没创建，但是已经指定了threshold（这种情况是带参构造创建的对象），threshold的值为数组长度</span><br><span class="line">    // 在 &quot;构造函数&quot; 那块内容进行过说明。</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    // 这种情况是通过无参构造创建的对象</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 可能是上面newThr = oldThr &lt;&lt; 1时，最高位被移除了，变为0。</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">  </span><br><span class="line">    // 到了这里，新的数组长度已经被计算出来，创建一个新的数组。</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])new HashMap.Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    // 下面代码是将原来数组的元素转移到新数组中。问题在于，数组长度发生变化。 </span><br><span class="line">    // 那么通过hash%数组长度计算的索引也将和原来的不同。</span><br><span class="line">    // jdk 1.7中是通过重新计算每个元素的索引，重新存入新的数组，称为rehash操作。</span><br><span class="line">    // 这也是hashMap无序性的原因之一。而现在jdk 1.8对此做了优化，非常的巧妙。</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        </span><br><span class="line">        // 遍历原数组</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            // 取出首节点</span><br><span class="line">            HashMap.Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 如果链表只有一个节点，那么直接重新计算索引存入新数组。</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 如果该节点是红黑树，执行split方法，和链表类似的处理。</span><br><span class="line">                else if (e instanceof HashMap.TreeNode)</span><br><span class="line">                    ((HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                // 此时节点是链表</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    // loHead，loTail为原链表的节点，索引不变。</span><br><span class="line">                    HashMap.Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    // hiHeadm, hiTail为新链表节点，原索引 + 原数组长度。</span><br><span class="line">                    HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    HashMap.Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                   // 遍历链表</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 新增bit为0的节点，存入原链表。</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 新增bit为1的节点，存入新链表。</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原链表存回原索引位</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 新链表存到：原索引位 + 原数组长度</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩充数组不单单只是让数组长度翻倍，将原数组中的元素直接存入新数组中这么简单。<br>因为元素的索引是通过hash&amp;(n - 1)得到的，那么数组的长度由n变为2n，重新计算的索引就可能和原来的不一样了。<br>在jdk1.7中，是通过遍历每一个元素，每一个节点，重新计算他们的索引值，存入新的数组中，称为rehash操作。</p><p>而java1.8对此进行了一些优化，没有了rehash操作。因为当数组长度是通过2的次方扩充的，那么会发现以下规律：</p><p>元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。因此，在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><p>先计算新数组的长度和新的阈值（threshold），然后将旧数组的内容迁移到新数组中，和1.7相比不需要执行rehash操作。因为以2次幂扩展的数组可以简单通过新增的bit判断索引位。</p><h4 id="4-4、树形化的treeifyBin-方法。"><a href="#4-4、树形化的treeifyBin-方法。" class="headerlink" title="4.4、树形化的treeifyBin() 方法。"></a>4.4、树形化的treeifyBin() 方法。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 把链表转换为红黑树</span><br><span class="line">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">    int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">    // 如果当前数组容量太小（小于64），放弃转换，扩充数组。</span><br><span class="line">    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">        resize(); </span><br><span class="line">    &#125; else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">        // 将链表转成红黑树...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashMap在jdk1.8之后引入了红黑树的概念，表示若桶中链表元素超过8时，会自动转化成红黑树；若桶中元素小于等于6时，树结构还原成链表形式。<br>红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。</p><h2 id="五、HashMap的源码分析"><a href="#五、HashMap的源码分析" class="headerlink" title="五、HashMap的源码分析"></a>五、HashMap的源码分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br><span class="line">1311</span><br><span class="line">1312</span><br><span class="line">1313</span><br><span class="line">1314</span><br><span class="line">1315</span><br><span class="line">1316</span><br><span class="line">1317</span><br><span class="line">1318</span><br><span class="line">1319</span><br><span class="line">1320</span><br><span class="line">1321</span><br><span class="line">1322</span><br><span class="line">1323</span><br><span class="line">1324</span><br><span class="line">1325</span><br><span class="line">1326</span><br><span class="line">1327</span><br><span class="line">1328</span><br><span class="line">1329</span><br><span class="line">1330</span><br><span class="line">1331</span><br><span class="line">1332</span><br><span class="line">1333</span><br><span class="line">1334</span><br><span class="line">1335</span><br><span class="line">1336</span><br><span class="line">1337</span><br><span class="line">1338</span><br><span class="line">1339</span><br><span class="line">1340</span><br><span class="line">1341</span><br><span class="line">1342</span><br><span class="line">1343</span><br><span class="line">1344</span><br><span class="line">1345</span><br><span class="line">1346</span><br><span class="line">1347</span><br><span class="line">1348</span><br><span class="line">1349</span><br><span class="line">1350</span><br><span class="line">1351</span><br><span class="line">1352</span><br><span class="line">1353</span><br><span class="line">1354</span><br><span class="line">1355</span><br><span class="line">1356</span><br><span class="line">1357</span><br><span class="line">1358</span><br><span class="line">1359</span><br><span class="line">1360</span><br><span class="line">1361</span><br><span class="line">1362</span><br><span class="line">1363</span><br><span class="line">1364</span><br><span class="line">1365</span><br><span class="line">1366</span><br><span class="line">1367</span><br><span class="line">1368</span><br><span class="line">1369</span><br><span class="line">1370</span><br><span class="line">1371</span><br><span class="line">1372</span><br><span class="line">1373</span><br><span class="line">1374</span><br><span class="line">1375</span><br><span class="line">1376</span><br><span class="line">1377</span><br><span class="line">1378</span><br><span class="line">1379</span><br><span class="line">1380</span><br><span class="line">1381</span><br><span class="line">1382</span><br><span class="line">1383</span><br><span class="line">1384</span><br><span class="line">1385</span><br><span class="line">1386</span><br><span class="line">1387</span><br><span class="line">1388</span><br><span class="line">1389</span><br><span class="line">1390</span><br><span class="line">1391</span><br><span class="line">1392</span><br><span class="line">1393</span><br><span class="line">1394</span><br><span class="line">1395</span><br><span class="line">1396</span><br><span class="line">1397</span><br><span class="line">1398</span><br><span class="line">1399</span><br><span class="line">1400</span><br><span class="line">1401</span><br><span class="line">1402</span><br><span class="line">1403</span><br><span class="line">1404</span><br><span class="line">1405</span><br><span class="line">1406</span><br><span class="line">1407</span><br><span class="line">1408</span><br><span class="line">1409</span><br><span class="line">1410</span><br><span class="line">1411</span><br><span class="line">1412</span><br><span class="line">1413</span><br><span class="line">1414</span><br><span class="line">1415</span><br><span class="line">1416</span><br><span class="line">1417</span><br><span class="line">1418</span><br><span class="line">1419</span><br><span class="line">1420</span><br><span class="line">1421</span><br><span class="line">1422</span><br><span class="line">1423</span><br><span class="line">1424</span><br><span class="line">1425</span><br><span class="line">1426</span><br><span class="line">1427</span><br><span class="line">1428</span><br><span class="line">1429</span><br><span class="line">1430</span><br><span class="line">1431</span><br><span class="line">1432</span><br><span class="line">1433</span><br><span class="line">1434</span><br><span class="line">1435</span><br><span class="line">1436</span><br><span class="line">1437</span><br><span class="line">1438</span><br><span class="line">1439</span><br><span class="line">1440</span><br><span class="line">1441</span><br><span class="line">1442</span><br><span class="line">1443</span><br><span class="line">1444</span><br><span class="line">1445</span><br><span class="line">1446</span><br><span class="line">1447</span><br><span class="line">1448</span><br><span class="line">1449</span><br><span class="line">1450</span><br><span class="line">1451</span><br><span class="line">1452</span><br><span class="line">1453</span><br><span class="line">1454</span><br><span class="line">1455</span><br><span class="line">1456</span><br><span class="line">1457</span><br><span class="line">1458</span><br><span class="line">1459</span><br><span class="line">1460</span><br><span class="line">1461</span><br><span class="line">1462</span><br><span class="line">1463</span><br><span class="line">1464</span><br><span class="line">1465</span><br><span class="line">1466</span><br><span class="line">1467</span><br><span class="line">1468</span><br><span class="line">1469</span><br><span class="line">1470</span><br><span class="line">1471</span><br><span class="line">1472</span><br><span class="line">1473</span><br><span class="line">1474</span><br><span class="line">1475</span><br><span class="line">1476</span><br><span class="line">1477</span><br><span class="line">1478</span><br><span class="line">1479</span><br><span class="line">1480</span><br><span class="line">1481</span><br><span class="line">1482</span><br><span class="line">1483</span><br><span class="line">1484</span><br><span class="line">1485</span><br><span class="line">1486</span><br><span class="line">1487</span><br><span class="line">1488</span><br><span class="line">1489</span><br><span class="line">1490</span><br><span class="line">1491</span><br><span class="line">1492</span><br><span class="line">1493</span><br><span class="line">1494</span><br><span class="line">1495</span><br><span class="line">1496</span><br><span class="line">1497</span><br><span class="line">1498</span><br><span class="line">1499</span><br><span class="line">1500</span><br><span class="line">1501</span><br><span class="line">1502</span><br><span class="line">1503</span><br><span class="line">1504</span><br><span class="line">1505</span><br><span class="line">1506</span><br><span class="line">1507</span><br><span class="line">1508</span><br><span class="line">1509</span><br><span class="line">1510</span><br><span class="line">1511</span><br><span class="line">1512</span><br><span class="line">1513</span><br><span class="line">1514</span><br><span class="line">1515</span><br><span class="line">1516</span><br><span class="line">1517</span><br><span class="line">1518</span><br><span class="line">1519</span><br><span class="line">1520</span><br><span class="line">1521</span><br><span class="line">1522</span><br><span class="line">1523</span><br><span class="line">1524</span><br><span class="line">1525</span><br><span class="line">1526</span><br><span class="line">1527</span><br><span class="line">1528</span><br><span class="line">1529</span><br><span class="line">1530</span><br><span class="line">1531</span><br><span class="line">1532</span><br><span class="line">1533</span><br><span class="line">1534</span><br><span class="line">1535</span><br><span class="line">1536</span><br><span class="line">1537</span><br><span class="line">1538</span><br><span class="line">1539</span><br><span class="line">1540</span><br><span class="line">1541</span><br><span class="line">1542</span><br><span class="line">1543</span><br><span class="line">1544</span><br><span class="line">1545</span><br><span class="line">1546</span><br><span class="line">1547</span><br><span class="line">1548</span><br><span class="line">1549</span><br><span class="line">1550</span><br><span class="line">1551</span><br><span class="line">1552</span><br><span class="line">1553</span><br><span class="line">1554</span><br><span class="line">1555</span><br><span class="line">1556</span><br><span class="line">1557</span><br><span class="line">1558</span><br><span class="line">1559</span><br><span class="line">1560</span><br><span class="line">1561</span><br><span class="line">1562</span><br><span class="line">1563</span><br><span class="line">1564</span><br><span class="line">1565</span><br><span class="line">1566</span><br><span class="line">1567</span><br><span class="line">1568</span><br><span class="line">1569</span><br><span class="line">1570</span><br><span class="line">1571</span><br><span class="line">1572</span><br><span class="line">1573</span><br><span class="line">1574</span><br><span class="line">1575</span><br><span class="line">1576</span><br><span class="line">1577</span><br><span class="line">1578</span><br><span class="line">1579</span><br><span class="line">1580</span><br><span class="line">1581</span><br><span class="line">1582</span><br><span class="line">1583</span><br><span class="line">1584</span><br><span class="line">1585</span><br><span class="line">1586</span><br><span class="line">1587</span><br><span class="line">1588</span><br><span class="line">1589</span><br><span class="line">1590</span><br><span class="line">1591</span><br><span class="line">1592</span><br><span class="line">1593</span><br><span class="line">1594</span><br><span class="line">1595</span><br><span class="line">1596</span><br><span class="line">1597</span><br><span class="line">1598</span><br><span class="line">1599</span><br><span class="line">1600</span><br><span class="line">1601</span><br><span class="line">1602</span><br><span class="line">1603</span><br><span class="line">1604</span><br><span class="line">1605</span><br><span class="line">1606</span><br><span class="line">1607</span><br><span class="line">1608</span><br><span class="line">1609</span><br><span class="line">1610</span><br><span class="line">1611</span><br><span class="line">1612</span><br><span class="line">1613</span><br><span class="line">1614</span><br><span class="line">1615</span><br><span class="line">1616</span><br><span class="line">1617</span><br><span class="line">1618</span><br><span class="line">1619</span><br><span class="line">1620</span><br><span class="line">1621</span><br><span class="line">1622</span><br><span class="line">1623</span><br><span class="line">1624</span><br><span class="line">1625</span><br><span class="line">1626</span><br><span class="line">1627</span><br><span class="line">1628</span><br><span class="line">1629</span><br><span class="line">1630</span><br><span class="line">1631</span><br><span class="line">1632</span><br><span class="line">1633</span><br><span class="line">1634</span><br><span class="line">1635</span><br><span class="line">1636</span><br><span class="line">1637</span><br><span class="line">1638</span><br><span class="line">1639</span><br><span class="line">1640</span><br><span class="line">1641</span><br><span class="line">1642</span><br><span class="line">1643</span><br><span class="line">1644</span><br><span class="line">1645</span><br><span class="line">1646</span><br><span class="line">1647</span><br><span class="line">1648</span><br><span class="line">1649</span><br><span class="line">1650</span><br><span class="line">1651</span><br><span class="line">1652</span><br><span class="line">1653</span><br><span class="line">1654</span><br><span class="line">1655</span><br><span class="line">1656</span><br><span class="line">1657</span><br><span class="line">1658</span><br><span class="line">1659</span><br><span class="line">1660</span><br><span class="line">1661</span><br><span class="line">1662</span><br><span class="line">1663</span><br><span class="line">1664</span><br><span class="line">1665</span><br><span class="line">1666</span><br><span class="line">1667</span><br><span class="line">1668</span><br><span class="line">1669</span><br><span class="line">1670</span><br><span class="line">1671</span><br><span class="line">1672</span><br><span class="line">1673</span><br><span class="line">1674</span><br><span class="line">1675</span><br><span class="line">1676</span><br><span class="line">1677</span><br><span class="line">1678</span><br><span class="line">1679</span><br><span class="line">1680</span><br><span class="line">1681</span><br><span class="line">1682</span><br><span class="line">1683</span><br><span class="line">1684</span><br><span class="line">1685</span><br><span class="line">1686</span><br><span class="line">1687</span><br><span class="line">1688</span><br><span class="line">1689</span><br><span class="line">1690</span><br><span class="line">1691</span><br><span class="line">1692</span><br><span class="line">1693</span><br><span class="line">1694</span><br><span class="line">1695</span><br><span class="line">1696</span><br><span class="line">1697</span><br><span class="line">1698</span><br><span class="line">1699</span><br><span class="line">1700</span><br><span class="line">1701</span><br><span class="line">1702</span><br><span class="line">1703</span><br><span class="line">1704</span><br><span class="line">1705</span><br><span class="line">1706</span><br><span class="line">1707</span><br><span class="line">1708</span><br><span class="line">1709</span><br><span class="line">1710</span><br><span class="line">1711</span><br><span class="line">1712</span><br><span class="line">1713</span><br><span class="line">1714</span><br><span class="line">1715</span><br><span class="line">1716</span><br><span class="line">1717</span><br><span class="line">1718</span><br><span class="line">1719</span><br><span class="line">1720</span><br><span class="line">1721</span><br><span class="line">1722</span><br><span class="line">1723</span><br><span class="line">1724</span><br><span class="line">1725</span><br><span class="line">1726</span><br><span class="line">1727</span><br><span class="line">1728</span><br><span class="line">1729</span><br><span class="line">1730</span><br><span class="line">1731</span><br><span class="line">1732</span><br><span class="line">1733</span><br><span class="line">1734</span><br><span class="line">1735</span><br><span class="line">1736</span><br><span class="line">1737</span><br><span class="line">1738</span><br><span class="line">1739</span><br><span class="line">1740</span><br><span class="line">1741</span><br><span class="line">1742</span><br><span class="line">1743</span><br><span class="line">1744</span><br><span class="line">1745</span><br><span class="line">1746</span><br><span class="line">1747</span><br><span class="line">1748</span><br><span class="line">1749</span><br><span class="line">1750</span><br><span class="line">1751</span><br><span class="line">1752</span><br><span class="line">1753</span><br><span class="line">1754</span><br><span class="line">1755</span><br><span class="line">1756</span><br><span class="line">1757</span><br><span class="line">1758</span><br><span class="line">1759</span><br><span class="line">1760</span><br><span class="line">1761</span><br><span class="line">1762</span><br><span class="line">1763</span><br><span class="line">1764</span><br><span class="line">1765</span><br><span class="line">1766</span><br><span class="line">1767</span><br><span class="line">1768</span><br><span class="line">1769</span><br><span class="line">1770</span><br><span class="line">1771</span><br><span class="line">1772</span><br><span class="line">1773</span><br><span class="line">1774</span><br><span class="line">1775</span><br><span class="line">1776</span><br><span class="line">1777</span><br><span class="line">1778</span><br><span class="line">1779</span><br><span class="line">1780</span><br><span class="line">1781</span><br><span class="line">1782</span><br><span class="line">1783</span><br><span class="line">1784</span><br><span class="line">1785</span><br><span class="line">1786</span><br><span class="line">1787</span><br><span class="line">1788</span><br><span class="line">1789</span><br><span class="line">1790</span><br><span class="line">1791</span><br><span class="line">1792</span><br><span class="line">1793</span><br><span class="line">1794</span><br><span class="line">1795</span><br><span class="line">1796</span><br><span class="line">1797</span><br><span class="line">1798</span><br><span class="line">1799</span><br><span class="line">1800</span><br><span class="line">1801</span><br><span class="line">1802</span><br><span class="line">1803</span><br><span class="line">1804</span><br><span class="line">1805</span><br><span class="line">1806</span><br><span class="line">1807</span><br><span class="line">1808</span><br><span class="line">1809</span><br><span class="line">1810</span><br><span class="line">1811</span><br><span class="line">1812</span><br><span class="line">1813</span><br><span class="line">1814</span><br><span class="line">1815</span><br><span class="line">1816</span><br><span class="line">1817</span><br><span class="line">1818</span><br><span class="line">1819</span><br><span class="line">1820</span><br><span class="line">1821</span><br><span class="line">1822</span><br><span class="line">1823</span><br><span class="line">1824</span><br><span class="line">1825</span><br><span class="line">1826</span><br><span class="line">1827</span><br><span class="line">1828</span><br><span class="line">1829</span><br><span class="line">1830</span><br><span class="line">1831</span><br><span class="line">1832</span><br><span class="line">1833</span><br><span class="line">1834</span><br><span class="line">1835</span><br><span class="line">1836</span><br><span class="line">1837</span><br><span class="line">1838</span><br><span class="line">1839</span><br><span class="line">1840</span><br><span class="line">1841</span><br><span class="line">1842</span><br><span class="line">1843</span><br><span class="line">1844</span><br><span class="line">1845</span><br><span class="line">1846</span><br><span class="line">1847</span><br><span class="line">1848</span><br><span class="line">1849</span><br><span class="line">1850</span><br><span class="line">1851</span><br><span class="line">1852</span><br><span class="line">1853</span><br><span class="line">1854</span><br><span class="line">1855</span><br><span class="line">1856</span><br><span class="line">1857</span><br><span class="line">1858</span><br><span class="line">1859</span><br><span class="line">1860</span><br><span class="line">1861</span><br><span class="line">1862</span><br><span class="line">1863</span><br><span class="line">1864</span><br><span class="line">1865</span><br><span class="line">1866</span><br><span class="line">1867</span><br><span class="line">1868</span><br><span class="line">1869</span><br><span class="line">1870</span><br><span class="line">1871</span><br><span class="line">1872</span><br><span class="line">1873</span><br><span class="line">1874</span><br><span class="line">1875</span><br><span class="line">1876</span><br><span class="line">1877</span><br><span class="line">1878</span><br><span class="line">1879</span><br><span class="line">1880</span><br><span class="line">1881</span><br><span class="line">1882</span><br><span class="line">1883</span><br><span class="line">1884</span><br><span class="line">1885</span><br><span class="line">1886</span><br><span class="line">1887</span><br><span class="line">1888</span><br><span class="line">1889</span><br><span class="line">1890</span><br><span class="line">1891</span><br><span class="line">1892</span><br><span class="line">1893</span><br><span class="line">1894</span><br><span class="line">1895</span><br><span class="line">1896</span><br><span class="line">1897</span><br><span class="line">1898</span><br><span class="line">1899</span><br><span class="line">1900</span><br><span class="line">1901</span><br><span class="line">1902</span><br><span class="line">1903</span><br><span class="line">1904</span><br><span class="line">1905</span><br><span class="line">1906</span><br><span class="line">1907</span><br><span class="line">1908</span><br><span class="line">1909</span><br><span class="line">1910</span><br><span class="line">1911</span><br><span class="line">1912</span><br><span class="line">1913</span><br><span class="line">1914</span><br><span class="line">1915</span><br><span class="line">1916</span><br><span class="line">1917</span><br><span class="line">1918</span><br><span class="line">1919</span><br><span class="line">1920</span><br><span class="line">1921</span><br><span class="line">1922</span><br><span class="line">1923</span><br><span class="line">1924</span><br><span class="line">1925</span><br><span class="line">1926</span><br><span class="line">1927</span><br><span class="line">1928</span><br><span class="line">1929</span><br><span class="line">1930</span><br><span class="line">1931</span><br><span class="line">1932</span><br><span class="line">1933</span><br><span class="line">1934</span><br><span class="line">1935</span><br><span class="line">1936</span><br><span class="line">1937</span><br><span class="line">1938</span><br><span class="line">1939</span><br><span class="line">1940</span><br><span class="line">1941</span><br><span class="line">1942</span><br><span class="line">1943</span><br><span class="line">1944</span><br><span class="line">1945</span><br><span class="line">1946</span><br><span class="line">1947</span><br><span class="line">1948</span><br><span class="line">1949</span><br><span class="line">1950</span><br><span class="line">1951</span><br><span class="line">1952</span><br><span class="line">1953</span><br><span class="line">1954</span><br><span class="line">1955</span><br><span class="line">1956</span><br><span class="line">1957</span><br><span class="line">1958</span><br><span class="line">1959</span><br><span class="line">1960</span><br><span class="line">1961</span><br><span class="line">1962</span><br><span class="line">1963</span><br><span class="line">1964</span><br><span class="line">1965</span><br><span class="line">1966</span><br><span class="line">1967</span><br><span class="line">1968</span><br><span class="line">1969</span><br><span class="line">1970</span><br><span class="line">1971</span><br><span class="line">1972</span><br><span class="line">1973</span><br><span class="line">1974</span><br><span class="line">1975</span><br><span class="line">1976</span><br><span class="line">1977</span><br><span class="line">1978</span><br><span class="line">1979</span><br><span class="line">1980</span><br><span class="line">1981</span><br><span class="line">1982</span><br><span class="line">1983</span><br><span class="line">1984</span><br><span class="line">1985</span><br><span class="line">1986</span><br><span class="line">1987</span><br><span class="line">1988</span><br><span class="line">1989</span><br><span class="line">1990</span><br><span class="line">1991</span><br><span class="line">1992</span><br><span class="line">1993</span><br><span class="line">1994</span><br><span class="line">1995</span><br><span class="line">1996</span><br><span class="line">1997</span><br><span class="line">1998</span><br><span class="line">1999</span><br><span class="line">2000</span><br><span class="line">2001</span><br><span class="line">2002</span><br><span class="line">2003</span><br><span class="line">2004</span><br><span class="line">2005</span><br><span class="line">2006</span><br><span class="line">2007</span><br><span class="line">2008</span><br><span class="line">2009</span><br><span class="line">2010</span><br><span class="line">2011</span><br><span class="line">2012</span><br><span class="line">2013</span><br><span class="line">2014</span><br><span class="line">2015</span><br><span class="line">2016</span><br><span class="line">2017</span><br><span class="line">2018</span><br><span class="line">2019</span><br><span class="line">2020</span><br><span class="line">2021</span><br><span class="line">2022</span><br><span class="line">2023</span><br><span class="line">2024</span><br><span class="line">2025</span><br><span class="line">2026</span><br><span class="line">2027</span><br><span class="line">2028</span><br><span class="line">2029</span><br><span class="line">2030</span><br><span class="line">2031</span><br><span class="line">2032</span><br><span class="line">2033</span><br><span class="line">2034</span><br><span class="line">2035</span><br><span class="line">2036</span><br><span class="line">2037</span><br><span class="line">2038</span><br><span class="line">2039</span><br><span class="line">2040</span><br><span class="line">2041</span><br><span class="line">2042</span><br><span class="line">2043</span><br><span class="line">2044</span><br><span class="line">2045</span><br><span class="line">2046</span><br><span class="line">2047</span><br><span class="line">2048</span><br><span class="line">2049</span><br><span class="line">2050</span><br><span class="line">2051</span><br><span class="line">2052</span><br><span class="line">2053</span><br><span class="line">2054</span><br><span class="line">2055</span><br><span class="line">2056</span><br><span class="line">2057</span><br><span class="line">2058</span><br><span class="line">2059</span><br><span class="line">2060</span><br><span class="line">2061</span><br><span class="line">2062</span><br><span class="line">2063</span><br><span class="line">2064</span><br><span class="line">2065</span><br><span class="line">2066</span><br><span class="line">2067</span><br><span class="line">2068</span><br><span class="line">2069</span><br><span class="line">2070</span><br><span class="line">2071</span><br><span class="line">2072</span><br><span class="line">2073</span><br><span class="line">2074</span><br><span class="line">2075</span><br><span class="line">2076</span><br><span class="line">2077</span><br><span class="line">2078</span><br><span class="line">2079</span><br><span class="line">2080</span><br><span class="line">2081</span><br><span class="line">2082</span><br><span class="line">2083</span><br><span class="line">2084</span><br><span class="line">2085</span><br><span class="line">2086</span><br><span class="line">2087</span><br><span class="line">2088</span><br><span class="line">2089</span><br><span class="line">2090</span><br><span class="line">2091</span><br><span class="line">2092</span><br><span class="line">2093</span><br><span class="line">2094</span><br><span class="line">2095</span><br><span class="line">2096</span><br><span class="line">2097</span><br><span class="line">2098</span><br><span class="line">2099</span><br><span class="line">2100</span><br><span class="line">2101</span><br><span class="line">2102</span><br><span class="line">2103</span><br><span class="line">2104</span><br><span class="line">2105</span><br><span class="line">2106</span><br><span class="line">2107</span><br><span class="line">2108</span><br><span class="line">2109</span><br><span class="line">2110</span><br><span class="line">2111</span><br><span class="line">2112</span><br><span class="line">2113</span><br><span class="line">2114</span><br><span class="line">2115</span><br><span class="line">2116</span><br><span class="line">2117</span><br><span class="line">2118</span><br><span class="line">2119</span><br><span class="line">2120</span><br><span class="line">2121</span><br><span class="line">2122</span><br><span class="line">2123</span><br><span class="line">2124</span><br><span class="line">2125</span><br><span class="line">2126</span><br><span class="line">2127</span><br><span class="line">2128</span><br><span class="line">2129</span><br><span class="line">2130</span><br><span class="line">2131</span><br><span class="line">2132</span><br><span class="line">2133</span><br><span class="line">2134</span><br></pre></td><td class="code"><pre><span class="line">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</span><br><span class="line">    implements Map&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    private static final long serialVersionUID = 362498820763181265L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认的初始化容量是16，必须是2的幂次方（只有为什么我们下面会讲）。</span><br><span class="line">     */</span><br><span class="line">    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 容量最大为2的30次方</span><br><span class="line">     */</span><br><span class="line">    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The load factor used when none specified in constructor.</span><br><span class="line">     * 如果未特殊指定加载因子的话，默认为0.75.</span><br><span class="line">     * 至于为什么是0.75f。这是时间与空间综合考虑的经验值</span><br><span class="line">     */</span><br><span class="line">    static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  树形化阈值，当桶(bucket)上的结点数大于这个值时会转成红黑树</span><br><span class="line">     */</span><br><span class="line">    static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  解除树形化阈值，当桶(bucket)上的结点数小于这个值时树转链表</span><br><span class="line">     */</span><br><span class="line">    static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 树形化阈值的第二条件。当数组的长度小于这个值时，</span><br><span class="line">     * 就算树形化阈达标，链表也不会转化为红黑树，而是优先扩容数组resize()。</span><br><span class="line">     */</span><br><span class="line">    static final int MIN_TREEIFY_CAPACITY = 64;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * HashMap的数据存储Key-Value的节点对象。</span><br><span class="line">     */</span><br><span class="line">    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        final int hash;</span><br><span class="line">        final K key;</span><br><span class="line">        V value;</span><br><span class="line">        // 链表的下一个节点</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        // 节点的构造函数</span><br><span class="line">        Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            this.hash = hash;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.value = value;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final K getKey()        &#123; return key; &#125;</span><br><span class="line">        public final V getValue()      &#123; return value; &#125;</span><br><span class="line">        public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line"></span><br><span class="line">        public final int hashCode() &#123;</span><br><span class="line">            return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final V setValue(V newValue) &#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean equals(Object o) &#123;</span><br><span class="line">            if (o == this)</span><br><span class="line">                return true;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ---------------- Static utilities -------------- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 上面的代码只是用hashCode的高16位与低16位进行异或运算。 </span><br><span class="line">     * hash() 方法就是将hashCode进一步的混淆，增加其 “随机度” ，试图减少插入HashMap时的hash冲突 。</span><br><span class="line">     * 计算HashMap的key的hashCode的值。至于计算这个Key的hash的值的算法</span><br><span class="line">     * 我们可以理解为这是考虑到位扩展的速度、实用性以及尽量让hash散列集合理分布</span><br><span class="line">     * 这些因素之后的权衡做法</span><br><span class="line">     */</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">        int h;</span><br><span class="line">        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns x&apos;s Class if it is of the form &quot;class C implements</span><br><span class="line">     * Comparable&lt;C&gt;&quot;, else null.</span><br><span class="line">     */</span><br><span class="line">    static Class&lt;?&gt; comparableClassFor(Object x) &#123;</span><br><span class="line">        if (x instanceof Comparable) &#123;</span><br><span class="line">            Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</span><br><span class="line">            if ((c = x.getClass()) == String.class) // bypass checks</span><br><span class="line">                return c;</span><br><span class="line">            if ((ts = c.getGenericInterfaces()) != null) &#123;</span><br><span class="line">                for (int i = 0; i &lt; ts.length; ++i) &#123;</span><br><span class="line">                    if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;</span><br><span class="line">                        ((p = (ParameterizedType)t).getRawType() ==</span><br><span class="line">                         Comparable.class) &amp;&amp;</span><br><span class="line">                        (as = p.getActualTypeArguments()) != null &amp;&amp;</span><br><span class="line">                        as.length == 1 &amp;&amp; as[0] == c) // type arg is c</span><br><span class="line">                        return c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns k.compareTo(x) if x matches kc (k&apos;s screened comparable</span><br><span class="line">     * class), else 0.</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) // for cast to Comparable</span><br><span class="line">    static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123;</span><br><span class="line">        return (x == null || x.getClass() != kc ? 0 :</span><br><span class="line">                ((Comparable)k).compareTo(x));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回给定大于容量值的最小2次幂。用来计算扩容的临界值</span><br><span class="line">     * 跟大神学习了。用位运算代替取模预算(据说提升了5~8倍)。</span><br><span class="line">     * 我们可以通过位运算来计算大约某个数的最小二次幂。</span><br><span class="line">     *  &gt;&gt;&gt; : 无符号右移，忽略符号位，空位都以0补齐</span><br><span class="line">     * </span><br><span class="line">     */</span><br><span class="line">    static final int tableSizeFor(int cap) &#123;</span><br><span class="line">        int n = cap - 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 1;</span><br><span class="line">        n |= n &gt;&gt;&gt; 2;</span><br><span class="line">        n |= n &gt;&gt;&gt; 4;</span><br><span class="line">        n |= n &gt;&gt;&gt; 8;</span><br><span class="line">        n |= n &gt;&gt;&gt; 16;</span><br><span class="line">        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ---------------- Fields -------------- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * HashMap的节点数组，当我们第一次使用的时候初始化大小</span><br><span class="line">     * 当需要的时候，我们会进行扩容</span><br><span class="line">     */</span><br><span class="line">    transient Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Holds cached entrySet(). Note that AbstractMap fields are used</span><br><span class="line">     * for keySet() and values().</span><br><span class="line">     */</span><br><span class="line">    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    // HashMap中键值对的数目</span><br><span class="line">    transient int size;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * HashMap结构被修改的次数。</span><br><span class="line">     * 结构修改是指改变HashMap中映射的数量或修改其内部结构的次数(例如，rehash)。</span><br><span class="line">     */</span><br><span class="line">    transient int modCount;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 数组扩容阈值。即：HashMap数组总容量 * 加载因子。当前容量大于或等于该值时会执行扩容** resize() **。</span><br><span class="line">     * 扩容的容量为当前 * HashMap 总容量的两倍。比如，当前 HashMap 的总容量为 16 ，那么扩容之后为 32 。</span><br><span class="line">     */需要调整大小的阈值。容量*加载因子</span><br><span class="line">    int threshold;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载因子</span><br><span class="line">     */</span><br><span class="line">    final float loadFactor;</span><br><span class="line"></span><br><span class="line">    /* ---------------- Public operations -------------- */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法是map作为参数的构造方法里面调用(clone方法也有调用)</span><br><span class="line">     */</span><br><span class="line">    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">        // 传入的Map的元素个数</span><br><span class="line">        int s = m.size();</span><br><span class="line">        // 元素个数大于0，我们开始执行下面的操作</span><br><span class="line">        if (s &gt; 0) &#123;</span><br><span class="line">            // 如果Hash桶的数组为null</span><br><span class="line">            if (table == null) &#123; // pre-size</span><br><span class="line">                float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">                if (t &gt; threshold)</span><br><span class="line">                    threshold = tableSizeFor(t);</span><br><span class="line">            &#125;</span><br><span class="line">            else if (s &gt; threshold)</span><br><span class="line">                resize();</span><br><span class="line">            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">                K key = e.getKey();</span><br><span class="line">                V value = e.getValue();</span><br><span class="line">                putVal(hash(key), key, value, false, evict);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of key-value mappings in this map.</span><br><span class="line">     *</span><br><span class="line">     * @return the number of key-value mappings in this map</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span><br><span class="line">     *</span><br><span class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 我们根据key来获取Node的节点数据</span><br><span class="line">     */</span><br><span class="line">    public V get(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        // 根据key来计算对应的Hash值，通过key的hash值和key来获取对应的Value</span><br><span class="line">        // 下面我们来看getNode方法</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取HashMap的Node节点</span><br><span class="line">     */</span><br><span class="line">    final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;</span><br><span class="line">        //tab：内部数组  first: 索引位首节点 n: 数组长度 k: 索引位首节点的key</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</span><br><span class="line">        </span><br><span class="line">        //数组不为null 数组长度大于0 定位到数组中的索引处。并判断索引位首节点不为null</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">           </span><br><span class="line">            // i = (n - 1) &amp; hash ，n是数组长度，hash就是通过hash()方法进行高低位异或运算得出来的hash值。 //这个表达式就是hash值的取模运算，上面已经说过当除数为2的次方时，可以用与运算提高性能。</span><br><span class="line">            // 所以这里也就是解决了我们为什么要将数组长度取2的N次方</span><br><span class="line">            </span><br><span class="line">            (first = tab[(n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            </span><br><span class="line">            // 如果索引位首节点的hash==key的hash 或者 key和索引位首节点的k相同</span><br><span class="line">            if (first.hash == hash &amp;&amp; // always check first node</span><br><span class="line">                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                 // 返回索引位首节点(值对象)</span><br><span class="line">                return first;</span><br><span class="line">            //  </span><br><span class="line">            if ((e = first.next) != null) &#123;</span><br><span class="line">                if (first instanceof TreeNode)</span><br><span class="line">                    // 如果是红黑色则到红黑树中查找.</span><br><span class="line">                    // getNode的方法比较简单，下面我们就来看getTreeNode的方法实现</span><br><span class="line">                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                // 否则就在链表中进行遍历朝朝。找到就返回e    </span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        return e;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the</span><br><span class="line">     * specified key.</span><br><span class="line">     *</span><br><span class="line">     * @param   key   The key whose presence in this map is to be tested</span><br><span class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this map contains a mapping for the specified</span><br><span class="line">     * key.</span><br><span class="line">     */</span><br><span class="line">    public boolean containsKey(Object key) &#123;</span><br><span class="line">        return getNode(hash(key), key) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个是非常重要的方法！！！</span><br><span class="line">     * 所以我们着重分析一下</span><br><span class="line">     * 这个方法是将对应的value与对应的key进行关联，存放到Map中</span><br><span class="line">     * 如果原来Map中有对应key的value.那么便会更新为入参value</span><br><span class="line">     */</span><br><span class="line">    public V put(K key, V value) &#123;</span><br><span class="line">        // 这个方法调用了putVal()。入参的时候调用hash(key)这个方法代码中有讲解</span><br><span class="line">        return putVal(hash(key), key, value, false, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 从上面我们可以看到put()方法调用了这个方法。</span><br><span class="line">     * onlyIfAbsent：当存入键值对时，如果该key已存在，是否覆盖它的value。false为覆盖，true为不覆盖 *参考putIfAbsent()方法。</span><br><span class="line">     * evict：用于子类LinkedHashMap。 也就是说在hashmap是没有用的</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     * 下面我们简单介绍一下这个方法：</span><br><span class="line">     *          1.检查数组是否为空，执行resize()扩充；</span><br><span class="line">     *          2.通过hash值计算数组索引，获取该索引位的首节点。 </span><br><span class="line">     *          3.如果首节点为null（没发生碰撞） ，</span><br><span class="line">     *          直接添加节点到该索引位 (bucket) 。 </span><br><span class="line">     *          4.如果首节点不为null （发生碰撞） ，</span><br><span class="line">     *          那么有3种情况 ：</span><br><span class="line">     *              ① key和首节点的key相同，覆盖old value （保证key的唯一性） ；</span><br><span class="line">     *          否则执行②或③ </span><br><span class="line">     *              ② 如果首节点是红黑树节点（TreeNode），将键值对添加到红黑树。 </span><br><span class="line">     *              ③ 如果首节点是链表，将键值对添加到链表。添加之后会判断链表长度是否到达TREEIFY_THRESHOLD - 1这个阈值，“尝试”将链表转换成红黑树。 </span><br><span class="line">     *          5.最后判断当前元素个数是否大于threshold，扩充数组。</span><br><span class="line">     */</span><br><span class="line">    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                   boolean evict) &#123;</span><br><span class="line">        // 声明hash桶的内部数组临时变量tab     </span><br><span class="line">        // p：hash对应的索引位中的首节点 </span><br><span class="line">        // n：内部数组的长度    i：hash对应的索引位</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">        // 条件一:table为null 或者table数组长度为0。</span><br><span class="line">        if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;  // 执行扩容操作，并计算数组长度</span><br><span class="line">            // i = (n-1)&amp;hash 计算index值。所以当我们取值的时候，也是从这个Index</span><br><span class="line">            // 如果为null 那么通过newNode来构建hash桶的这个节点</span><br><span class="line">        if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">            // 创建一个新的节点</span><br><span class="line">            tab[i] = newNode(hash, key, value, null);</span><br><span class="line">        else &#123;</span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">             //节点key存在，直接覆盖value</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            // 如果判断当前链是红黑树    </span><br><span class="line">            else if (p instanceof TreeNode)</span><br><span class="line">                // 则执行红黑树的插入值的相关操作</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">             // 此时首节点为链表，如果链表中存在该键值对，直接覆盖value。</span><br><span class="line">            // 如果不存在，则在末端插入键值对。然后判断链表是否大于等于7，尝试转换成红黑树。</span><br><span class="line">             // 注意此处使用“尝试”，因为在treeifyBin方法中还会判断当前数组容量是否到达64，</span><br><span class="line">            // 否则会放弃次此转换，优先扩充数组容量。    </span><br><span class="line">            else &#123;</span><br><span class="line">            // 如果p节点不是为空，也不是为红黑树，那就是普通的链表</span><br><span class="line">            // 走到这里，hash碰撞了。检查链表中是否包含key，或将键值对添加到链表末尾</span><br><span class="line">                for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                // p.next == null，到达链表末尾，添加新节点，如果长度足够，转换成树结构。</span><br><span class="line">                    if ((e = p.next) == null) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, null);</span><br><span class="line">                         //链表长度大于7转换为红黑树进行处理（大于等于7）</span><br><span class="line">                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 如果对应的Key已经存在则直接覆盖Value即可</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                        break;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (e != null) &#123; // existing mapping for key</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        // 如果超过最大的扩容林接着，则进行扩容</span><br><span class="line">        if (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">final HashMap.Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">    int oldThr = threshold;</span><br><span class="line">    int newCap, newThr = 0;</span><br><span class="line">    if (oldCap &gt; 0) &#123;</span><br><span class="line">        // 如果数组已经是最大长度，不进行扩充。</span><br><span class="line">        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            return oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        // 否则数组容量扩充一倍。（2的N次方）</span><br><span class="line">        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果数组还没创建，但是已经指定了threshold（这种情况是带参构造创建的对象），threshold的值为数组长度</span><br><span class="line">    // 在 &quot;构造函数&quot; 那块内容进行过说明。</span><br><span class="line">    else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    // 这种情况是通过无参构造创建的对象</span><br><span class="line">    else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    // 可能是上面newThr = oldThr &lt;&lt; 1时，最高位被移除了，变为0。</span><br><span class="line">    if (newThr == 0) &#123;</span><br><span class="line">        float ft = (float)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">                (int)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">  </span><br><span class="line">    // 到了这里，新的数组长度已经被计算出来，创建一个新的数组。</span><br><span class="line">    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">    HashMap.Node&lt;K,V&gt;[] newTab = (HashMap.Node&lt;K,V&gt;[])new HashMap.Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    </span><br><span class="line">    // 下面代码是将原来数组的元素转移到新数组中。问题在于，数组长度发生变化。 </span><br><span class="line">    // 那么通过hash%数组长度计算的索引也将和原来的不同。</span><br><span class="line">    // jdk 1.7中是通过重新计算每个元素的索引，重新存入新的数组，称为rehash操作。</span><br><span class="line">    // 这也是hashMap无序性的原因之一。而现在jdk 1.8对此做了优化，非常的巧妙。</span><br><span class="line">    if (oldTab != null) &#123;</span><br><span class="line">        </span><br><span class="line">        // 遍历原数组</span><br><span class="line">        for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            // 取出首节点</span><br><span class="line">            HashMap.Node&lt;K,V&gt; e;</span><br><span class="line">            if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">                oldTab[j] = null;</span><br><span class="line">                // 如果链表只有一个节点，那么直接重新计算索引存入新数组。</span><br><span class="line">                if (e.next == null)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">                // 如果该节点是红黑树，执行split方法，和链表类似的处理。</span><br><span class="line">                else if (e instanceof HashMap.TreeNode)</span><br><span class="line">                    ((HashMap.TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">                </span><br><span class="line">                // 此时节点是链表</span><br><span class="line">                else &#123; // preserve order</span><br><span class="line">                    // loHead，loTail为原链表的节点，索引不变。</span><br><span class="line">                    HashMap.Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                    // hiHeadm, hiTail为新链表节点，原索引 + 原数组长度。</span><br><span class="line">                    HashMap.Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                    HashMap.Node&lt;K,V&gt; next;</span><br><span class="line">                    </span><br><span class="line">                   // 遍历链表</span><br><span class="line">                    do &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        // 新增bit为0的节点，存入原链表。</span><br><span class="line">                        if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                            if (loTail == null)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 新增bit为1的节点，存入新链表。</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (hiTail == null)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            else</span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; while ((e = next) != null);</span><br><span class="line">                    // 原链表存回原索引位</span><br><span class="line">                    if (loTail != null) &#123;</span><br><span class="line">                        loTail.next = null;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 新链表存到：原索引位 + 原数组长度</span><br><span class="line">                    if (hiTail != null) &#123;</span><br><span class="line">                        hiTail.next = null;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 这个方法是将链表转化为红黑树</span><br><span class="line">     *      如果当前数组容量太小（小于64），放弃转换，扩充数组。</span><br><span class="line">     */</span><br><span class="line">    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;</span><br><span class="line">        int n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        // 如果当前数组容量太小（小于64），放弃转换，扩充数组。</span><br><span class="line">        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            // 将链表转化为红黑树</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">            do &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);</span><br><span class="line">                if (tl == null)</span><br><span class="line">                    hd = p;</span><br><span class="line">                else &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; while ((e = e.next) != null);</span><br><span class="line">            if ((tab[index] = hd) != null)</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Copies all of the mappings from the specified map to this map.</span><br><span class="line">     * These mappings will replace any mappings that this map had for</span><br><span class="line">     * any of the keys currently in the specified map.</span><br><span class="line">     *</span><br><span class="line">     * @param m mappings to be stored in this map</span><br><span class="line">     * @throws NullPointerException if the specified map is null</span><br><span class="line">     */</span><br><span class="line">    public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">        putMapEntries(m, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Removes the mapping for the specified key from this map if present.</span><br><span class="line">     *</span><br><span class="line">     * @param  key key whose mapping is to be removed from the map</span><br><span class="line">     * @return the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span><br><span class="line">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span><br><span class="line">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span><br><span class="line">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span><br><span class="line">     */</span><br><span class="line">    public V remove(Object key) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = removeNode(hash(key), key, null, false, true)) == null ?</span><br><span class="line">            null : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Implements Map.remove and related methods</span><br><span class="line">     *</span><br><span class="line">     * @param hash hash for key</span><br><span class="line">     * @param key the key</span><br><span class="line">     * @param value the value to match if matchValue, else ignored</span><br><span class="line">     * @param matchValue if true only remove if value is equal</span><br><span class="line">     * @param movable if false do not move other nodes while removing</span><br><span class="line">     * @return the node, or null if none</span><br><span class="line">     */</span><br><span class="line">    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</span><br><span class="line">                               boolean matchValue, boolean movable) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</span><br><span class="line">            (p = tab[index = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            Node&lt;K,V&gt; node = null, e; K k; V v;</span><br><span class="line">            if (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                node = p;</span><br><span class="line">            else if ((e = p.next) != null) &#123;</span><br><span class="line">                if (p instanceof TreeNode)</span><br><span class="line">                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">                else &#123;</span><br><span class="line">                    do &#123;</span><br><span class="line">                        if (e.hash == hash &amp;&amp;</span><br><span class="line">                            ((k = e.key) == key ||</span><br><span class="line">                             (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                            node = e;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = e;</span><br><span class="line">                    &#125; while ((e = e.next) != null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                                 (value != null &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">                if (node instanceof TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</span><br><span class="line">                else if (node == p)</span><br><span class="line">                    tab[index] = node.next;</span><br><span class="line">                else</span><br><span class="line">                    p.next = node.next;</span><br><span class="line">                ++modCount;</span><br><span class="line">                --size;</span><br><span class="line">                afterNodeRemoval(node);</span><br><span class="line">                return node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Removes all of the mappings from this map.</span><br><span class="line">     * The map will be empty after this call returns.</span><br><span class="line">     */</span><br><span class="line">    public void clear() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        modCount++;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">            size = 0;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i)</span><br><span class="line">                tab[i] = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><br><span class="line">     * specified value.</span><br><span class="line">     *</span><br><span class="line">     * @param value value whose presence in this map is to be tested</span><br><span class="line">     * @return &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span><br><span class="line">     *         specified value</span><br><span class="line">     */</span><br><span class="line">    public boolean containsValue(Object value) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; V v;</span><br><span class="line">        if ((tab = table) != null &amp;&amp; size &gt; 0) &#123;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">                    if ((v = e.value) == value ||</span><br><span class="line">                        (value != null &amp;&amp; value.equals(v)))</span><br><span class="line">                        return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a &#123;@link Set&#125; view of the keys contained in this map.</span><br><span class="line">     * The set is backed by the map, so changes to the map are</span><br><span class="line">     * reflected in the set, and vice-versa.  If the map is modified</span><br><span class="line">     * while an iteration over the set is in progress (except through</span><br><span class="line">     * the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</span><br><span class="line">     * the iteration are undefined.  The set supports element removal,</span><br><span class="line">     * which removes the corresponding mapping from the map, via the</span><br><span class="line">     * &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</span><br><span class="line">     * &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</span><br><span class="line">     * operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</span><br><span class="line">     * operations.</span><br><span class="line">     *</span><br><span class="line">     * @return a set view of the keys contained in this map</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;K&gt; keySet() &#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        if (ks == null) &#123;</span><br><span class="line">            ks = new KeySet();</span><br><span class="line">            keySet = ks;</span><br><span class="line">        &#125;</span><br><span class="line">        return ks;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final class KeySet extends AbstractSet&lt;K&gt; &#123;</span><br><span class="line">        public final int size()                 &#123; return size; &#125;</span><br><span class="line">        public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">        public final Iterator&lt;K&gt; iterator()     &#123; return new KeyIterator(); &#125;</span><br><span class="line">        public final boolean contains(Object o) &#123; return containsKey(o); &#125;</span><br><span class="line">        public final boolean remove(Object key) &#123;</span><br><span class="line">            return removeNode(hash(key), key, null, false, true) != null;</span><br><span class="line">        &#125;</span><br><span class="line">        public final Spliterator&lt;K&gt; spliterator() &#123;</span><br><span class="line">            return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        public final void forEach(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">                int mc = modCount;</span><br><span class="line">                for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                        action.accept(e.key);</span><br><span class="line">                &#125;</span><br><span class="line">                if (modCount != mc)</span><br><span class="line">                    throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a &#123;@link Collection&#125; view of the values contained in this map.</span><br><span class="line">     * The collection is backed by the map, so changes to the map are</span><br><span class="line">     * reflected in the collection, and vice-versa.  If the map is</span><br><span class="line">     * modified while an iteration over the collection is in progress</span><br><span class="line">     * (except through the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation),</span><br><span class="line">     * the results of the iteration are undefined.  The collection</span><br><span class="line">     * supports element removal, which removes the corresponding</span><br><span class="line">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span><br><span class="line">     * &lt;tt&gt;Collection.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;,</span><br><span class="line">     * &lt;tt&gt;retainAll&lt;/tt&gt; and &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not</span><br><span class="line">     * support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span><br><span class="line">     *</span><br><span class="line">     * @return a view of the values contained in this map</span><br><span class="line">     */</span><br><span class="line">    public Collection&lt;V&gt; values() &#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        if (vs == null) &#123;</span><br><span class="line">            vs = new Values();</span><br><span class="line">            values = vs;</span><br><span class="line">        &#125;</span><br><span class="line">        return vs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final class Values extends AbstractCollection&lt;V&gt; &#123;</span><br><span class="line">        public final int size()                 &#123; return size; &#125;</span><br><span class="line">        public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">        public final Iterator&lt;V&gt; iterator()     &#123; return new ValueIterator(); &#125;</span><br><span class="line">        public final boolean contains(Object o) &#123; return containsValue(o); &#125;</span><br><span class="line">        public final Spliterator&lt;V&gt; spliterator() &#123;</span><br><span class="line">            return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        public final void forEach(Consumer&lt;? super V&gt; action) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">                int mc = modCount;</span><br><span class="line">                for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                        action.accept(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">                if (modCount != mc)</span><br><span class="line">                    throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a &#123;@link Set&#125; view of the mappings contained in this map.</span><br><span class="line">     * The set is backed by the map, so changes to the map are</span><br><span class="line">     * reflected in the set, and vice-versa.  If the map is modified</span><br><span class="line">     * while an iteration over the set is in progress (except through</span><br><span class="line">     * the iterator&apos;s own &lt;tt&gt;remove&lt;/tt&gt; operation, or through the</span><br><span class="line">     * &lt;tt&gt;setValue&lt;/tt&gt; operation on a map entry returned by the</span><br><span class="line">     * iterator) the results of the iteration are undefined.  The set</span><br><span class="line">     * supports element removal, which removes the corresponding</span><br><span class="line">     * mapping from the map, via the &lt;tt&gt;Iterator.remove&lt;/tt&gt;,</span><br><span class="line">     * &lt;tt&gt;Set.remove&lt;/tt&gt;, &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt; and</span><br><span class="line">     * &lt;tt&gt;clear&lt;/tt&gt; operations.  It does not support the</span><br><span class="line">     * &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt; operations.</span><br><span class="line">     *</span><br><span class="line">     * @return a set view of the mappings contained in this map</span><br><span class="line">     */</span><br><span class="line">    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        public final int size()                 &#123; return size; &#125;</span><br><span class="line">        public final void clear()               &#123; HashMap.this.clear(); &#125;</span><br><span class="line">        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            return new EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        public final boolean contains(Object o) &#123;</span><br><span class="line">            if (!(o instanceof Map.Entry))</span><br><span class="line">                return false;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">            Object key = e.getKey();</span><br><span class="line">            Node&lt;K,V&gt; candidate = getNode(hash(key), key);</span><br><span class="line">            return candidate != null &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        public final boolean remove(Object o) &#123;</span><br><span class="line">            if (o instanceof Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</span><br><span class="line">                Object key = e.getKey();</span><br><span class="line">                Object value = e.getValue();</span><br><span class="line">                return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        public final Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() &#123;</span><br><span class="line">            return new EntrySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        public final void forEach(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">                int mc = modCount;</span><br><span class="line">                for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                    for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                &#125;</span><br><span class="line">                if (modCount != mc)</span><br><span class="line">                    throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Overrides of JDK8 Map extension methods</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V getOrDefault(Object key, V defaultValue) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V putIfAbsent(K key, V value) &#123;</span><br><span class="line">        return putVal(hash(key), key, value, true, true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean remove(Object key, Object value) &#123;</span><br><span class="line">        return removeNode(hash(key), key, value, true, true) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean replace(K key, V oldValue, V newValue) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; V v;</span><br><span class="line">        if ((e = getNode(hash(key), key)) != null &amp;&amp;</span><br><span class="line">            ((v = e.value) == oldValue || (v != null &amp;&amp; v.equals(oldValue)))) &#123;</span><br><span class="line">            e.value = newValue;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V replace(K key, V value) &#123;</span><br><span class="line">        Node&lt;K,V&gt; e;</span><br><span class="line">        if ((e = getNode(hash(key), key)) != null) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            return oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V computeIfAbsent(K key,</span><br><span class="line">                             Function&lt;? super K, ? extends V&gt; mappingFunction) &#123;</span><br><span class="line">        if (mappingFunction == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;</span><br><span class="line">        int binCount = 0;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = null;</span><br><span class="line">        Node&lt;K,V&gt; old = null;</span><br><span class="line">        if (size &gt; threshold || (tab = table) == null ||</span><br><span class="line">            (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">            V oldValue;</span><br><span class="line">            if (old != null &amp;&amp; (oldValue = old.value) != null) &#123;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">                return oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V v = mappingFunction.apply(key);</span><br><span class="line">        if (v == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125; else if (old != null) &#123;</span><br><span class="line">            old.value = v;</span><br><span class="line">            afterNodeAccess(old);</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (t != null)</span><br><span class="line">            t.putTreeVal(this, tab, hash, key, v);</span><br><span class="line">        else &#123;</span><br><span class="line">            tab[i] = newNode(hash, key, v, first);</span><br><span class="line">            if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br><span class="line">                treeifyBin(tab, hash);</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        ++size;</span><br><span class="line">        afterNodeInsertion(true);</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public V computeIfPresent(K key,</span><br><span class="line">                              BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">        if (remappingFunction == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        Node&lt;K,V&gt; e; V oldValue;</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        if ((e = getNode(hash, key)) != null &amp;&amp;</span><br><span class="line">            (oldValue = e.value) != null) &#123;</span><br><span class="line">            V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">            if (v != null) &#123;</span><br><span class="line">                e.value = v;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                return v;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                removeNode(hash, key, null, false, true);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V compute(K key,</span><br><span class="line">                     BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">        if (remappingFunction == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;</span><br><span class="line">        int binCount = 0;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = null;</span><br><span class="line">        Node&lt;K,V&gt; old = null;</span><br><span class="line">        if (size &gt; threshold || (tab = table) == null ||</span><br><span class="line">            (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        V oldValue = (old == null) ? null : old.value;</span><br><span class="line">        V v = remappingFunction.apply(key, oldValue);</span><br><span class="line">        if (old != null) &#123;</span><br><span class="line">            if (v != null) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                removeNode(hash, key, null, false, true);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (v != null) &#123;</span><br><span class="line">            if (t != null)</span><br><span class="line">                t.putTreeVal(this, tab, hash, key, v);</span><br><span class="line">            else &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, v, first);</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public V merge(K key, V value,</span><br><span class="line">                   BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123;</span><br><span class="line">        if (value == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (remappingFunction == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        int hash = hash(key);</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first; int n, i;</span><br><span class="line">        int binCount = 0;</span><br><span class="line">        TreeNode&lt;K,V&gt; t = null;</span><br><span class="line">        Node&lt;K,V&gt; old = null;</span><br><span class="line">        if (size &gt; threshold || (tab = table) == null ||</span><br><span class="line">            (n = tab.length) == 0)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        if ((first = tab[i = (n - 1) &amp; hash]) != null) &#123;</span><br><span class="line">            if (first instanceof TreeNode)</span><br><span class="line">                old = (t = (TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            else &#123;</span><br><span class="line">                Node&lt;K,V&gt; e = first; K k;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        old = e;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++binCount;</span><br><span class="line">                &#125; while ((e = e.next) != null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (old != null) &#123;</span><br><span class="line">            V v;</span><br><span class="line">            if (old.value != null)</span><br><span class="line">                v = remappingFunction.apply(old.value, value);</span><br><span class="line">            else</span><br><span class="line">                v = value;</span><br><span class="line">            if (v != null) &#123;</span><br><span class="line">                old.value = v;</span><br><span class="line">                afterNodeAccess(old);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                removeNode(hash, key, null, false, true);</span><br><span class="line">            return v;</span><br><span class="line">        &#125;</span><br><span class="line">        if (value != null) &#123;</span><br><span class="line">            if (t != null)</span><br><span class="line">                t.putTreeVal(this, tab, hash, key, value);</span><br><span class="line">            else &#123;</span><br><span class="line">                tab[i] = newNode(hash, key, value, first);</span><br><span class="line">                if (binCount &gt;= TREEIFY_THRESHOLD - 1)</span><br><span class="line">                    treeifyBin(tab, hash);</span><br><span class="line">            &#125;</span><br><span class="line">            ++modCount;</span><br><span class="line">            ++size;</span><br><span class="line">            afterNodeInsertion(true);</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (action == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">            int mc = modCount;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</span><br><span class="line">                    action.accept(e.key, e.value);</span><br><span class="line">            &#125;</span><br><span class="line">            if (modCount != mc)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (function == null)</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">            int mc = modCount;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">                    e.value = function.apply(e.key, e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (modCount != mc)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ------------------------------------------------------------ */</span><br><span class="line">    // Cloning and serialization</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a shallow copy of this &lt;tt&gt;HashMap&lt;/tt&gt; instance: the keys and</span><br><span class="line">     * values themselves are not cloned.</span><br><span class="line">     *</span><br><span class="line">     * @return a shallow copy of this map</span><br><span class="line">     */</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public Object clone() &#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result;</span><br><span class="line">        try &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)super.clone();</span><br><span class="line">        &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">            // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">            throw new InternalError(e);</span><br><span class="line">        &#125;</span><br><span class="line">        result.reinitialize();</span><br><span class="line">        result.putMapEntries(this, false);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // These methods are also used when serializing HashSets</span><br><span class="line">    final float loadFactor() &#123; return loadFactor; &#125;</span><br><span class="line">    final int capacity() &#123;</span><br><span class="line">        return (table != null) ? table.length :</span><br><span class="line">            (threshold &gt; 0) ? threshold :</span><br><span class="line">            DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Save the state of the &lt;tt&gt;HashMap&lt;/tt&gt; instance to a stream (i.e.,</span><br><span class="line">     * serialize it).</span><br><span class="line">     *</span><br><span class="line">     * @serialData The &lt;i&gt;capacity&lt;/i&gt; of the HashMap (the length of the</span><br><span class="line">     *             bucket array) is emitted (int), followed by the</span><br><span class="line">     *             &lt;i&gt;size&lt;/i&gt; (an int, the number of key-value</span><br><span class="line">     *             mappings), followed by the key (Object) and value (Object)</span><br><span class="line">     *             for each key-value mapping.  The key-value mappings are</span><br><span class="line">     *             emitted in no particular order.</span><br><span class="line">     */</span><br><span class="line">    private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">        throws IOException &#123;</span><br><span class="line">        int buckets = capacity();</span><br><span class="line">        // Write out the threshold, loadfactor, and any hidden stuff</span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line">        s.writeInt(buckets);</span><br><span class="line">        s.writeInt(size);</span><br><span class="line">        internalWriteEntries(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reconstitute the &#123;@code HashMap&#125; instance from a stream (i.e.,</span><br><span class="line">     * deserialize it).</span><br><span class="line">     */</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s)</span><br><span class="line">        throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        // Read in the threshold (ignored), loadfactor, and any hidden stuff</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        reinitialize();</span><br><span class="line">        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">            throw new InvalidObjectException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                                             loadFactor);</span><br><span class="line">        s.readInt();                // Read and ignore number of buckets</span><br><span class="line">        int mappings = s.readInt(); // Read number of mappings (size)</span><br><span class="line">        if (mappings &lt; 0)</span><br><span class="line">            throw new InvalidObjectException(&quot;Illegal mappings count: &quot; +</span><br><span class="line">                                             mappings);</span><br><span class="line">        else if (mappings &gt; 0) &#123; // (if zero, use defaults)</span><br><span class="line">            // Size the table using given load factor only if within</span><br><span class="line">            // range of 0.25...4.0</span><br><span class="line">            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);</span><br><span class="line">            float fc = (float)mappings / lf + 1.0f;</span><br><span class="line">            int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ?</span><br><span class="line">                       DEFAULT_INITIAL_CAPACITY :</span><br><span class="line">                       (fc &gt;= MAXIMUM_CAPACITY) ?</span><br><span class="line">                       MAXIMUM_CAPACITY :</span><br><span class="line">                       tableSizeFor((int)fc));</span><br><span class="line">            float ft = (float)cap * lf;</span><br><span class="line">            threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ?</span><br><span class="line">                         (int)ft : Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">            // Check Map.Entry[].class since it&apos;s the nearest public type to</span><br><span class="line">            // what we&apos;re actually creating.</span><br><span class="line">            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);</span><br><span class="line">            @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap];</span><br><span class="line">            table = tab;</span><br><span class="line"></span><br><span class="line">            // Read the keys and values, and put the mappings in the HashMap</span><br><span class="line">            for (int i = 0; i &lt; mappings; i++) &#123;</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    K key = (K) s.readObject();</span><br><span class="line">                @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">                    V value = (V) s.readObject();</span><br><span class="line">                putVal(hash(key), key, value, false, false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ------------------------------------------------------------ */</span><br><span class="line">    // iterators</span><br><span class="line"></span><br><span class="line">    abstract class HashIterator &#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        // next entry to return</span><br><span class="line">        Node&lt;K,V&gt; current;     // current entry</span><br><span class="line">        int expectedModCount;  // for fast-fail</span><br><span class="line">        int index;             // current slot</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            Node&lt;K,V&gt;[] t = table;</span><br><span class="line">            current = next = null;</span><br><span class="line">            index = 0;</span><br><span class="line">            if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry</span><br><span class="line">                do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final boolean hasNext() &#123;</span><br><span class="line">            return next != null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final Node&lt;K,V&gt; nextNode() &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] t;</span><br><span class="line">            Node&lt;K,V&gt; e = next;</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            if (e == null)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123;</span><br><span class="line">                do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</span><br><span class="line">            &#125;</span><br><span class="line">            return e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final void remove() &#123;</span><br><span class="line">            Node&lt;K,V&gt; p = current;</span><br><span class="line">            if (p == null)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            if (modCount != expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            current = null;</span><br><span class="line">            K key = p.key;</span><br><span class="line">            removeNode(hash(key), key, null, false, false);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final class KeyIterator extends HashIterator</span><br><span class="line">        implements Iterator&lt;K&gt; &#123;</span><br><span class="line">        public final K next() &#123; return nextNode().key; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final class ValueIterator extends HashIterator</span><br><span class="line">        implements Iterator&lt;V&gt; &#123;</span><br><span class="line">        public final V next() &#123; return nextNode().value; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final class EntryIterator extends HashIterator</span><br><span class="line">        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ------------------------------------------------------------ */</span><br><span class="line">    // spliterators</span><br><span class="line"></span><br><span class="line">    static class HashMapSpliterator&lt;K,V&gt; &#123;</span><br><span class="line">        final HashMap&lt;K,V&gt; map;</span><br><span class="line">        Node&lt;K,V&gt; current;          // current node</span><br><span class="line">        int index;                  // current index, modified on advance/split</span><br><span class="line">        int fence;                  // one past last index</span><br><span class="line">        int est;                    // size estimate</span><br><span class="line">        int expectedModCount;       // for comodification checks</span><br><span class="line"></span><br><span class="line">        HashMapSpliterator(HashMap&lt;K,V&gt; m, int origin,</span><br><span class="line">                           int fence, int est,</span><br><span class="line">                           int expectedModCount) &#123;</span><br><span class="line">            this.map = m;</span><br><span class="line">            this.index = origin;</span><br><span class="line">            this.fence = fence;</span><br><span class="line">            this.est = est;</span><br><span class="line">            this.expectedModCount = expectedModCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int getFence() &#123; // initialize fence and size on first use</span><br><span class="line">            int hi;</span><br><span class="line">            if ((hi = fence) &lt; 0) &#123;</span><br><span class="line">                HashMap&lt;K,V&gt; m = map;</span><br><span class="line">                est = m.size;</span><br><span class="line">                expectedModCount = m.modCount;</span><br><span class="line">                Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">                hi = fence = (tab == null) ? 0 : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            return hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public final long estimateSize() &#123;</span><br><span class="line">            getFence(); // force init</span><br><span class="line">            return (long) est;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class KeySpliterator&lt;K,V&gt;</span><br><span class="line">        extends HashMapSpliterator&lt;K,V&gt;</span><br><span class="line">        implements Spliterator&lt;K&gt; &#123;</span><br><span class="line">        KeySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,</span><br><span class="line">                       int expectedModCount) &#123;</span><br><span class="line">            super(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public KeySpliterator&lt;K,V&gt; trySplit() &#123;</span><br><span class="line">            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">            return (lo &gt;= mid || current != null) ? null :</span><br><span class="line">                new KeySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,</span><br><span class="line">                                        expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">            int i, hi, mc;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            if ((hi = fence) &lt; 0) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == null) ? 0 : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = null;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (p == null)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    else &#123;</span><br><span class="line">                        action.accept(p.key);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while (p != null || i &lt; hi);</span><br><span class="line">                if (m.modCount != mc)</span><br><span class="line">                    throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryAdvance(Consumer&lt;? super K&gt; action) &#123;</span><br><span class="line">            int hi;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123;</span><br><span class="line">                while (current != null || index &lt; hi) &#123;</span><br><span class="line">                    if (current == null)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    else &#123;</span><br><span class="line">                        K k = current.key;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(k);</span><br><span class="line">                        if (map.modCount != expectedModCount)</span><br><span class="line">                            throw new ConcurrentModificationException();</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int characteristics() &#123;</span><br><span class="line">            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class ValueSpliterator&lt;K,V&gt;</span><br><span class="line">        extends HashMapSpliterator&lt;K,V&gt;</span><br><span class="line">        implements Spliterator&lt;V&gt; &#123;</span><br><span class="line">        ValueSpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,</span><br><span class="line">                         int expectedModCount) &#123;</span><br><span class="line">            super(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public ValueSpliterator&lt;K,V&gt; trySplit() &#123;</span><br><span class="line">            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">            return (lo &gt;= mid || current != null) ? null :</span><br><span class="line">                new ValueSpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super V&gt; action) &#123;</span><br><span class="line">            int i, hi, mc;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            if ((hi = fence) &lt; 0) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == null) ? 0 : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = null;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (p == null)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    else &#123;</span><br><span class="line">                        action.accept(p.value);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while (p != null || i &lt; hi);</span><br><span class="line">                if (m.modCount != mc)</span><br><span class="line">                    throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryAdvance(Consumer&lt;? super V&gt; action) &#123;</span><br><span class="line">            int hi;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123;</span><br><span class="line">                while (current != null || index &lt; hi) &#123;</span><br><span class="line">                    if (current == null)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    else &#123;</span><br><span class="line">                        V v = current.value;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(v);</span><br><span class="line">                        if (map.modCount != expectedModCount)</span><br><span class="line">                            throw new ConcurrentModificationException();</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int characteristics() &#123;</span><br><span class="line">            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static final class EntrySpliterator&lt;K,V&gt;</span><br><span class="line">        extends HashMapSpliterator&lt;K,V&gt;</span><br><span class="line">        implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123;</span><br><span class="line">        EntrySpliterator(HashMap&lt;K,V&gt; m, int origin, int fence, int est,</span><br><span class="line">                         int expectedModCount) &#123;</span><br><span class="line">            super(m, origin, fence, est, expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public EntrySpliterator&lt;K,V&gt; trySplit() &#123;</span><br><span class="line">            int hi = getFence(), lo = index, mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">            return (lo &gt;= mid || current != null) ? null :</span><br><span class="line">                new EntrySpliterator&lt;&gt;(map, lo, index = mid, est &gt;&gt;&gt;= 1,</span><br><span class="line">                                          expectedModCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class="line">            int i, hi, mc;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            HashMap&lt;K,V&gt; m = map;</span><br><span class="line">            Node&lt;K,V&gt;[] tab = m.table;</span><br><span class="line">            if ((hi = fence) &lt; 0) &#123;</span><br><span class="line">                mc = expectedModCount = m.modCount;</span><br><span class="line">                hi = fence = (tab == null) ? 0 : tab.length;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                mc = expectedModCount;</span><br><span class="line">            if (tab != null &amp;&amp; tab.length &gt;= hi &amp;&amp;</span><br><span class="line">                (i = index) &gt;= 0 &amp;&amp; (i &lt; (index = hi) || current != null)) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = current;</span><br><span class="line">                current = null;</span><br><span class="line">                do &#123;</span><br><span class="line">                    if (p == null)</span><br><span class="line">                        p = tab[i++];</span><br><span class="line">                    else &#123;</span><br><span class="line">                        action.accept(p);</span><br><span class="line">                        p = p.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; while (p != null || i &lt; hi);</span><br><span class="line">                if (m.modCount != mc)</span><br><span class="line">                    throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) &#123;</span><br><span class="line">            int hi;</span><br><span class="line">            if (action == null)</span><br><span class="line">                throw new NullPointerException();</span><br><span class="line">            Node&lt;K,V&gt;[] tab = map.table;</span><br><span class="line">            if (tab != null &amp;&amp; tab.length &gt;= (hi = getFence()) &amp;&amp; index &gt;= 0) &#123;</span><br><span class="line">                while (current != null || index &lt; hi) &#123;</span><br><span class="line">                    if (current == null)</span><br><span class="line">                        current = tab[index++];</span><br><span class="line">                    else &#123;</span><br><span class="line">                        Node&lt;K,V&gt; e = current;</span><br><span class="line">                        current = current.next;</span><br><span class="line">                        action.accept(e);</span><br><span class="line">                        if (map.modCount != expectedModCount)</span><br><span class="line">                            throw new ConcurrentModificationException();</span><br><span class="line">                        return true;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int characteristics() &#123;</span><br><span class="line">            return (fence &lt; 0 || est == map.size ? Spliterator.SIZED : 0) |</span><br><span class="line">                Spliterator.DISTINCT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ------------------------------------------------------------ */</span><br><span class="line">    // LinkedHashMap support</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * The following package-protected methods are designed to be</span><br><span class="line">     * overridden by LinkedHashMap, but not by any other subclass.</span><br><span class="line">     * Nearly all other internal methods are also package-protected</span><br><span class="line">     * but are declared final, so can be used by LinkedHashMap, view</span><br><span class="line">     * classes, and HashSet.</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    // Create a regular (non-tree) node</span><br><span class="line">    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new Node&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For conversion from TreeNodes to plain nodes</span><br><span class="line">    Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new Node&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Create a tree bin node</span><br><span class="line">    TreeNode&lt;K,V&gt; newTreeNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new TreeNode&lt;&gt;(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // For treeifyBin</span><br><span class="line">    TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reset to initial default state.  Called by clone and readObject.</span><br><span class="line">     */</span><br><span class="line">    void reinitialize() &#123;</span><br><span class="line">        table = null;</span><br><span class="line">        entrySet = null;</span><br><span class="line">        keySet = null;</span><br><span class="line">        values = null;</span><br><span class="line">        modCount = 0;</span><br><span class="line">        threshold = 0;</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Callbacks to allow LinkedHashMap post-actions</span><br><span class="line">    void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line">    void afterNodeInsertion(boolean evict) &#123; &#125;</span><br><span class="line">    void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</span><br><span class="line"></span><br><span class="line">    // Called only from writeObject, to ensure compatible ordering.</span><br><span class="line">    void internalWriteEntries(java.io.ObjectOutputStream s) throws IOException &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab;</span><br><span class="line">        if (size &gt; 0 &amp;&amp; (tab = table) != null) &#123;</span><br><span class="line">            for (int i = 0; i &lt; tab.length; ++i) &#123;</span><br><span class="line">                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123;</span><br><span class="line">                    s.writeObject(e.key);</span><br><span class="line">                    s.writeObject(e.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* ------------------------------------------------------------ */</span><br><span class="line">    // Tree bins</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Entry for Tree bins. Extends LinkedHashMap.Entry (which in turn</span><br><span class="line">     * extends Node) so can be used as extension of either regular or</span><br><span class="line">     * linked node.</span><br><span class="line">     */</span><br><span class="line">    static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">        boolean red;</span><br><span class="line">        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Returns root of tree containing this node.</span><br><span class="line">         */</span><br><span class="line">        final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;</span><br><span class="line">                if ((p = r.parent) == null)</span><br><span class="line">                    return r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Ensures that the given root is the first node of its bin.</span><br><span class="line">         */</span><br><span class="line">        static &lt;K,V&gt; void moveRootToFront(Node&lt;K,V&gt;[] tab, TreeNode&lt;K,V&gt; root) &#123;</span><br><span class="line">            int n;</span><br><span class="line">            if (root != null &amp;&amp; tab != null &amp;&amp; (n = tab.length) &gt; 0) &#123;</span><br><span class="line">                int index = (n - 1) &amp; root.hash;</span><br><span class="line">                TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index];</span><br><span class="line">                if (root != first) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; rn;</span><br><span class="line">                    tab[index] = root;</span><br><span class="line">                    TreeNode&lt;K,V&gt; rp = root.prev;</span><br><span class="line">                    if ((rn = root.next) != null)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)rn).prev = rp;</span><br><span class="line">                    if (rp != null)</span><br><span class="line">                        rp.next = rn;</span><br><span class="line">                    if (first != null)</span><br><span class="line">                        first.prev = root;</span><br><span class="line">                    root.next = first;</span><br><span class="line">                    root.prev = null;</span><br><span class="line">                &#125;</span><br><span class="line">                assert checkInvariants(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * 进行红黑树的遍历</span><br><span class="line">         */</span><br><span class="line">        final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;</span><br><span class="line">            // 获取当前的节点</span><br><span class="line">            TreeNode&lt;K,V&gt; p = this;</span><br><span class="line">            do &#123;</span><br><span class="line">                // 定义节点hash值、节点key值</span><br><span class="line">                int ph, dir; K pk;</span><br><span class="line">                // 获取左右子节点</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</span><br><span class="line">                // 获取节点hash值 若是大于传入的hash值。则</span><br><span class="line">                if ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if (pl == null)</span><br><span class="line">                    p = pr;</span><br><span class="line">                else if (pr == null)</span><br><span class="line">                    p = pl;</span><br><span class="line">                else if ((kc != null ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != null) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != 0)</span><br><span class="line">                    p = (dir &lt; 0) ? pl : pr;</span><br><span class="line">                else if ((q = pr.find(h, k, kc)) != null)</span><br><span class="line">                    return q;</span><br><span class="line">                else</span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; while (p != null);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Calls find for root node.</span><br><span class="line">         * 这个就是进行红黑树遍历的逻辑。</span><br><span class="line">         */</span><br><span class="line">        final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;</span><br><span class="line">            // 如果parent不为null.调用获取root  若是根节点直接遍历</span><br><span class="line">            return ((parent != null) ? root() : this).find(h, k, null);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Tie-breaking utility for ordering insertions when equal</span><br><span class="line">         * hashCodes and non-comparable. We don&apos;t require a total</span><br><span class="line">         * order, just a consistent insertion rule to maintain</span><br><span class="line">         * equivalence across rebalancings. Tie-breaking further than</span><br><span class="line">         * necessary simplifies testing a bit.</span><br><span class="line">         */</span><br><span class="line">        static int tieBreakOrder(Object a, Object b) &#123;</span><br><span class="line">            int d;</span><br><span class="line">            if (a == null || b == null ||</span><br><span class="line">                (d = a.getClass().getName().</span><br><span class="line">                 compareTo(b.getClass().getName())) == 0)</span><br><span class="line">                d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</span><br><span class="line">                     -1 : 1);</span><br><span class="line">            return d;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Forms tree of the nodes linked from this node.</span><br><span class="line">         * @return root of tree</span><br><span class="line">         */</span><br><span class="line">        final void treeify(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; root = null;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                x.left = x.right = null;</span><br><span class="line">                if (root == null) &#123;</span><br><span class="line">                    x.parent = null;</span><br><span class="line">                    x.red = false;</span><br><span class="line">                    root = x;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    K k = x.key;</span><br><span class="line">                    int h = x.hash;</span><br><span class="line">                    Class&lt;?&gt; kc = null;</span><br><span class="line">                    for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                        int dir, ph;</span><br><span class="line">                        K pk = p.key;</span><br><span class="line">                        if ((ph = p.hash) &gt; h)</span><br><span class="line">                            dir = -1;</span><br><span class="line">                        else if (ph &lt; h)</span><br><span class="line">                            dir = 1;</span><br><span class="line">                        else if ((kc == null &amp;&amp;</span><br><span class="line">                                  (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                                 (dir = compareComparables(kc, k, pk)) == 0)</span><br><span class="line">                            dir = tieBreakOrder(k, pk);</span><br><span class="line"></span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                            x.parent = xp;</span><br><span class="line">                            if (dir &lt;= 0)</span><br><span class="line">                                xp.left = x;</span><br><span class="line">                            else</span><br><span class="line">                                xp.right = x;</span><br><span class="line">                            root = balanceInsertion(root, x);</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            moveRootToFront(tab, root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Returns a list of non-TreeNodes replacing those linked from</span><br><span class="line">         * this node.</span><br><span class="line">         */</span><br><span class="line">        final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) &#123;</span><br><span class="line">            Node&lt;K,V&gt; hd = null, tl = null;</span><br><span class="line">            for (Node&lt;K,V&gt; q = this; q != null; q = q.next) &#123;</span><br><span class="line">                Node&lt;K,V&gt; p = map.replacementNode(q, null);</span><br><span class="line">                if (tl == null)</span><br><span class="line">                    hd = p;</span><br><span class="line">                else</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125;</span><br><span class="line">            return hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Tree version of putVal.</span><br><span class="line">         * 如果该节点是红黑树，往红黑树插入数据</span><br><span class="line">         * 参数：当前的hashMap hash桶数组。hash key value</span><br><span class="line">         */</span><br><span class="line">        final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                                       int h, K k, V v) &#123;</span><br><span class="line">            Class&lt;?&gt; kc = null;</span><br><span class="line">            boolean searched = false;</span><br><span class="line">            // 获取根节点</span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this;</span><br><span class="line">            </span><br><span class="line">            for (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                int dir, ph; K pk;</span><br><span class="line">                // 计算根节点的hash值</span><br><span class="line">                if ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -1;</span><br><span class="line">                else if (ph &lt; h)</span><br><span class="line">                    dir = 1;</span><br><span class="line">                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))</span><br><span class="line">                    return p;</span><br><span class="line">                else if ((kc == null &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == null) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == 0) &#123;</span><br><span class="line">                    if (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = true;</span><br><span class="line">                        if (((ch = p.left) != null &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != null) ||</span><br><span class="line">                            ((ch = p.right) != null &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != null))</span><br><span class="line">                            return q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    if (dir &lt;= 0)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    else</span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    if (xpn != null)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    return null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Removes the given node, that must be present before this call.</span><br><span class="line">         * This is messier than typical red-black deletion code because we</span><br><span class="line">         * cannot swap the contents of an interior node with a leaf</span><br><span class="line">         * successor that is pinned by &quot;next&quot; pointers that are accessible</span><br><span class="line">         * independently during traversal. So instead we swap the tree</span><br><span class="line">         * linkages. If the current tree appears to have too few nodes,</span><br><span class="line">         * the bin is converted back to a plain bin. (The test triggers</span><br><span class="line">         * somewhere between 2 and 6 nodes, depending on tree structure).</span><br><span class="line">         */</span><br><span class="line">        final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span><br><span class="line">                                  boolean movable) &#123;</span><br><span class="line">            int n;</span><br><span class="line">            if (tab == null || (n = tab.length) == 0)</span><br><span class="line">                return;</span><br><span class="line">            int index = (n - 1) &amp; hash;</span><br><span class="line">            TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl;</span><br><span class="line">            TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev;</span><br><span class="line">            if (pred == null)</span><br><span class="line">                tab[index] = first = succ;</span><br><span class="line">            else</span><br><span class="line">                pred.next = succ;</span><br><span class="line">            if (succ != null)</span><br><span class="line">                succ.prev = pred;</span><br><span class="line">            if (first == null)</span><br><span class="line">                return;</span><br><span class="line">            if (root.parent != null)</span><br><span class="line">                root = root.root();</span><br><span class="line">            if (root == null || root.right == null ||</span><br><span class="line">                (rl = root.left) == null || rl.left == null) &#123;</span><br><span class="line">                tab[index] = first.untreeify(map);  // too small</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement;</span><br><span class="line">            if (pl != null &amp;&amp; pr != null) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; s = pr, sl;</span><br><span class="line">                while ((sl = s.left) != null) // find successor</span><br><span class="line">                    s = sl;</span><br><span class="line">                boolean c = s.red; s.red = p.red; p.red = c; // swap colors</span><br><span class="line">                TreeNode&lt;K,V&gt; sr = s.right;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                if (s == pr) &#123; // p was s&apos;s direct parent</span><br><span class="line">                    p.parent = s;</span><br><span class="line">                    s.right = p;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; sp = s.parent;</span><br><span class="line">                    if ((p.parent = sp) != null) &#123;</span><br><span class="line">                        if (s == sp.left)</span><br><span class="line">                            sp.left = p;</span><br><span class="line">                        else</span><br><span class="line">                            sp.right = p;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if ((s.right = pr) != null)</span><br><span class="line">                        pr.parent = s;</span><br><span class="line">                &#125;</span><br><span class="line">                p.left = null;</span><br><span class="line">                if ((p.right = sr) != null)</span><br><span class="line">                    sr.parent = p;</span><br><span class="line">                if ((s.left = pl) != null)</span><br><span class="line">                    pl.parent = s;</span><br><span class="line">                if ((s.parent = pp) == null)</span><br><span class="line">                    root = s;</span><br><span class="line">                else if (p == pp.left)</span><br><span class="line">                    pp.left = s;</span><br><span class="line">                else</span><br><span class="line">                    pp.right = s;</span><br><span class="line">                if (sr != null)</span><br><span class="line">                    replacement = sr;</span><br><span class="line">                else</span><br><span class="line">                    replacement = p;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (pl != null)</span><br><span class="line">                replacement = pl;</span><br><span class="line">            else if (pr != null)</span><br><span class="line">                replacement = pr;</span><br><span class="line">            else</span><br><span class="line">                replacement = p;</span><br><span class="line">            if (replacement != p) &#123;</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent;</span><br><span class="line">                if (pp == null)</span><br><span class="line">                    root = replacement;</span><br><span class="line">                else if (p == pp.left)</span><br><span class="line">                    pp.left = replacement;</span><br><span class="line">                else</span><br><span class="line">                    pp.right = replacement;</span><br><span class="line">                p.left = p.right = p.parent = null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement);</span><br><span class="line"></span><br><span class="line">            if (replacement == p) &#123;  // detach</span><br><span class="line">                TreeNode&lt;K,V&gt; pp = p.parent;</span><br><span class="line">                p.parent = null;</span><br><span class="line">                if (pp != null) &#123;</span><br><span class="line">                    if (p == pp.left)</span><br><span class="line">                        pp.left = null;</span><br><span class="line">                    else if (p == pp.right)</span><br><span class="line">                        pp.right = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (movable)</span><br><span class="line">                moveRootToFront(tab, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Splits nodes in a tree bin into lower and upper tree bins,</span><br><span class="line">         * or untreeifies if now too small. Called only from resize;</span><br><span class="line">         * see above discussion about split bits and indices.</span><br><span class="line">         *</span><br><span class="line">         * @param map the map</span><br><span class="line">         * @param tab the table for recording bin heads</span><br><span class="line">         * @param index the index of the table being split</span><br><span class="line">         * @param bit the bit of hash to split on</span><br><span class="line">         */</span><br><span class="line">        final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = this;</span><br><span class="line">            // Relink into lo and hi lists, preserving order</span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">            int lc = 0, hc = 0;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = null;</span><br><span class="line">                if ((e.hash &amp; bit) == 0) &#123;</span><br><span class="line">                    if ((e.prev = loTail) == null)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    else</span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if ((e.prev = hiTail) == null)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    else</span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (loHead != null) &#123;</span><br><span class="line">                if (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                else &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    if (hiHead != null) // (else is already treeified)</span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (hiHead != null) &#123;</span><br><span class="line">                if (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                else &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    if (loHead != null)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* ------------------------------------------------------------ */</span><br><span class="line">        // Red-black tree methods, all adapted from CLR</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateLeft(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                              TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; r, pp, rl;</span><br><span class="line">            if (p != null &amp;&amp; (r = p.right) != null) &#123;</span><br><span class="line">                if ((rl = p.right = r.left) != null)</span><br><span class="line">                    rl.parent = p;</span><br><span class="line">                if ((pp = r.parent = p.parent) == null)</span><br><span class="line">                    (root = r).red = false;</span><br><span class="line">                else if (pp.left == p)</span><br><span class="line">                    pp.left = r;</span><br><span class="line">                else</span><br><span class="line">                    pp.right = r;</span><br><span class="line">                r.left = p;</span><br><span class="line">                p.parent = r;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; rotateRight(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                               TreeNode&lt;K,V&gt; p) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; l, pp, lr;</span><br><span class="line">            if (p != null &amp;&amp; (l = p.left) != null) &#123;</span><br><span class="line">                if ((lr = p.left = l.right) != null)</span><br><span class="line">                    lr.parent = p;</span><br><span class="line">                if ((pp = l.parent = p.parent) == null)</span><br><span class="line">                    (root = l).red = false;</span><br><span class="line">                else if (pp.right == p)</span><br><span class="line">                    pp.right = l;</span><br><span class="line">                else</span><br><span class="line">                    pp.left = l;</span><br><span class="line">                l.right = p;</span><br><span class="line">                p.parent = l;</span><br><span class="line">            &#125;</span><br><span class="line">            return root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                    TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">            x.red = true;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</span><br><span class="line">                if ((xp = x.parent) == null) &#123;</span><br><span class="line">                    x.red = false;</span><br><span class="line">                    return x;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (!xp.red || (xpp = xp.parent) == null)</span><br><span class="line">                    return root;</span><br><span class="line">                if (xp == (xppl = xpp.left)) &#123;</span><br><span class="line">                    if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123;</span><br><span class="line">                        xppr.red = false;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        xpp.red = true;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (x == xp.right) &#123;</span><br><span class="line">                            root = rotateLeft(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp != null) &#123;</span><br><span class="line">                            xp.red = false;</span><br><span class="line">                            if (xpp != null) &#123;</span><br><span class="line">                                xpp.red = true;</span><br><span class="line">                                root = rotateRight(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    if (xppl != null &amp;&amp; xppl.red) &#123;</span><br><span class="line">                        xppl.red = false;</span><br><span class="line">                        xp.red = false;</span><br><span class="line">                        xpp.red = true;</span><br><span class="line">                        x = xpp;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        if (x == xp.left) &#123;</span><br><span class="line">                            root = rotateRight(root, x = xp);</span><br><span class="line">                            xpp = (xp = x.parent) == null ? null : xp.parent;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (xp != null) &#123;</span><br><span class="line">                            xp.red = false;</span><br><span class="line">                            if (xpp != null) &#123;</span><br><span class="line">                                xpp.red = true;</span><br><span class="line">                                root = rotateLeft(root, xpp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root,</span><br><span class="line">                                                   TreeNode&lt;K,V&gt; x) &#123;</span><br><span class="line">            for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</span><br><span class="line">                if (x == null || x == root)</span><br><span class="line">                    return root;</span><br><span class="line">                else if ((xp = x.parent) == null) &#123;</span><br><span class="line">                    x.red = false;</span><br><span class="line">                    return x;</span><br><span class="line">                &#125;</span><br><span class="line">                else if (x.red) &#123;</span><br><span class="line">                    x.red = false;</span><br><span class="line">                    return root;</span><br><span class="line">                &#125;</span><br><span class="line">                else if ((xpl = xp.left) == x) &#123;</span><br><span class="line">                    if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</span><br><span class="line">                        xpr.red = false;</span><br><span class="line">                        xp.red = true;</span><br><span class="line">                        root = rotateLeft(root, xp);</span><br><span class="line">                        xpr = (xp = x.parent) == null ? null : xp.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xpr == null)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</span><br><span class="line">                        if ((sr == null || !sr.red) &amp;&amp;</span><br><span class="line">                            (sl == null || !sl.red)) &#123;</span><br><span class="line">                            xpr.red = true;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (sr == null || !sr.red) &#123;</span><br><span class="line">                                if (sl != null)</span><br><span class="line">                                    sl.red = false;</span><br><span class="line">                                xpr.red = true;</span><br><span class="line">                                root = rotateRight(root, xpr);</span><br><span class="line">                                xpr = (xp = x.parent) == null ?</span><br><span class="line">                                    null : xp.right;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xpr != null) &#123;</span><br><span class="line">                                xpr.red = (xp == null) ? false : xp.red;</span><br><span class="line">                                if ((sr = xpr.right) != null)</span><br><span class="line">                                    sr.red = false;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xp != null) &#123;</span><br><span class="line">                                xp.red = false;</span><br><span class="line">                                root = rotateLeft(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123; // symmetric</span><br><span class="line">                    if (xpl != null &amp;&amp; xpl.red) &#123;</span><br><span class="line">                        xpl.red = false;</span><br><span class="line">                        xp.red = true;</span><br><span class="line">                        root = rotateRight(root, xp);</span><br><span class="line">                        xpl = (xp = x.parent) == null ? null : xp.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (xpl == null)</span><br><span class="line">                        x = xp;</span><br><span class="line">                    else &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; sl = xpl.left, sr = xpl.right;</span><br><span class="line">                        if ((sl == null || !sl.red) &amp;&amp;</span><br><span class="line">                            (sr == null || !sr.red)) &#123;</span><br><span class="line">                            xpl.red = true;</span><br><span class="line">                            x = xp;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            if (sl == null || !sl.red) &#123;</span><br><span class="line">                                if (sr != null)</span><br><span class="line">                                    sr.red = false;</span><br><span class="line">                                xpl.red = true;</span><br><span class="line">                                root = rotateLeft(root, xpl);</span><br><span class="line">                                xpl = (xp = x.parent) == null ?</span><br><span class="line">                                    null : xp.left;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xpl != null) &#123;</span><br><span class="line">                                xpl.red = (xp == null) ? false : xp.red;</span><br><span class="line">                                if ((sl = xpl.left) != null)</span><br><span class="line">                                    sl.red = false;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (xp != null) &#123;</span><br><span class="line">                                xp.red = false;</span><br><span class="line">                                root = rotateRight(root, xp);</span><br><span class="line">                            &#125;</span><br><span class="line">                            x = root;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Recursive invariant check</span><br><span class="line">         */</span><br><span class="line">        static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</span><br><span class="line">                tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</span><br><span class="line">            if (tb != null &amp;&amp; tb.next != t)</span><br><span class="line">                return false;</span><br><span class="line">            if (tn != null &amp;&amp; tn.prev != t)</span><br><span class="line">                return false;</span><br><span class="line">            if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</span><br><span class="line">                return false;</span><br><span class="line">            if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</span><br><span class="line">                return false;</span><br><span class="line">            if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</span><br><span class="line">                return false;</span><br><span class="line">            if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)</span><br><span class="line">                return false;</span><br><span class="line">            if (tl != null &amp;&amp; !checkInvariants(tl))</span><br><span class="line">                return false;</span><br><span class="line">            if (tr != null &amp;&amp; !checkInvariants(tr))</span><br><span class="line">                return false;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面，我们已经分析完了HashMap的源码，所以我们来解答一下上面提出的几个问题：</p><p><strong>提问一</strong>：通过HashMap的扩容方法resize()方法。我们发现为什么扩容一直2倍扩容。而HashMap的默认初始容量也是16(2的4次幂)？？</p><p>分析：肯定是为了性能撒！！！数组的初始容量为16，而容量是以2的次方扩充的，一是为了提高性能使用足够大的数组，二是为了能使用位运算代替取模预算(据说提升了5~8倍)。数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。这个0.75就是默认的负载因子，可由构造传入。我们也可以设置大于1的负载因子，这样数组就不会扩充，牺牲性能，节省内存。</p><p><strong>提问二</strong>：JDK8中HashMap为什么引入了红黑树？？引入红黑树有什么作用？？</p><p>分析:肯定实为了性能撒！！！即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。<br>当插入新元素时，对于红黑树的判断如下：<br>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向下面；<br>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p><strong>提问三</strong>：为什么当桶中链表长度大于等于8之后，才转化为红黑树。为什么当长度小于等于6之后转化成为链表</p><p>分析：肯定是为了性能撒！！！！<br>红黑树的平均查找长度是log(n)，长度为8，查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。<br>以6和8来作为平衡点是因为，中间有个差值7可以防止链表和树之间频繁的转换。假设，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><p>对于第三点补充说明，检查链表长度转换成红黑树之前，还会先检测当前数组数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。所以上面也说了链表长度的阈值是7或8，因为会有一次放弃转换的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收机制的学习</title>
      <link href="/2019/01/13/Java%E5%AD%A6%E4%B9%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/01/13/Java%E5%AD%A6%E4%B9%A0%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>文章参考：<a href="https://blog.csdn.net/pi9nc/article/details/12374049" target="_blank" rel="noopener">https://blog.csdn.net/pi9nc/article/details/12374049</a></p><h3 id="1-垃圾回收的意义"><a href="#1-垃圾回收的意义" class="headerlink" title="1. 垃圾回收的意义"></a>1. 垃圾回收的意义</h3><p>在C++中，对象所占的内存在程序结束运行之前一直被占用，在明确释放之前不能分配给其它对象；而在Java中，当没有对象引用指向原先分配给某个对象的内存时，该内存便成为垃圾。JVM的一个系统级线程会自动释放该内存块。垃圾回收意味着程序不再需要的对象是”无用信息”，这些信息将被丢弃。当一个对象不再被引用的时候，内存回收它占领的空间，以便空间被后来的新对象使用。事实上，除了释放没用的对象，垃圾回收也可以清除内存记录碎片。由于创建对象和垃圾回收器释放丢弃对象所占的内存空间，内存会出现碎片。碎片是分配给对象的内存块之间的空闲内存洞。碎片整理将所占用的堆内存移到堆的一端，JVM将整理出的内存分配给新的对象。</p><p>垃圾回收能自动释放内存空间，减轻编程的负担。这使Java虚拟机具有一些优点。</p><p>首先，它能使编程效率提高。在没有垃圾回收机制的时候，可能要花许多时间来解决一个难懂的存储器问题。在用Java语言编程的时候，靠垃圾回收机制可大大缩短时间。</p><p>其次是它保护程序的完整性， 垃圾回收是Java语言安全性策略的一个重要部份。垃圾回收的一个潜在的缺点是它的开销影响程序性能。Java虚拟机必须追踪运行程序中有用的对象，而且最终释放没用的对象。这一个过程需要花费处理器的时间。其次垃圾回收算法的不完备性，早先采用的某些垃圾回收算法就不能保证100%收集到所有的废弃内存。当然随着垃圾回收算法的不断改进以及软硬件运行效率的不断提升，这些问题都可以迎刃而解。</p><h3 id="2-垃圾收集的算法分析"><a href="#2-垃圾收集的算法分析" class="headerlink" title="2. 垃圾收集的算法分析"></a>2. 垃圾收集的算法分析</h3><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：</p><ul><li>（1）发现无用信息对象；</li><li>（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。</li></ul><h3 id="3、垃圾是否回收的依据算法"><a href="#3、垃圾是否回收的依据算法" class="headerlink" title="3、垃圾是否回收的依据算法"></a>3、垃圾是否回收的依据算法</h3><h4 id="3-1-引用计数法-Reference-Counting-Collector"><a href="#3-1-引用计数法-Reference-Counting-Collector" class="headerlink" title="3.1. 引用计数法(Reference Counting Collector)"></a>3.1. 引用计数法(Reference Counting Collector)</h4><p>引用计数法是唯一没有使用根集的垃圾回收的法，该算法使用引用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。</p><p>基于引用计数器的垃圾收集器运行较快，不会长时间中断程序执行，适宜地必须实时运行的程序。但引用计数器增加了程序执行的开销，因为每次对象赋给新的变量，计数器加1，而每次现有对象出了作用域，计数器减1。 </p><p>但这种方法有一个问题，比方说有两个对象 A 和 B，A 引用了 B，B 又引用了 A，除此之外没有别的对象引用 A 和 B，那么 A 和 B 在我们看来已经是垃圾对象，需要被回收，但它们的引用计数不为 0，没有达到回收的条件。正因为这个循环引用的问题，Java 并没有采用引用计数法。</p><p>引用计数法优点：实现简单，判定效率也很高；</p><p>引用计数法缺点：难以解决对象之间相互循环引用导致计数器值不等于0的问题。</p><h4 id="3-2-可达性分析法-Reference-Counting-Collector"><a href="#3-2-可达性分析法-Reference-Counting-Collector" class="headerlink" title="3.2. 可达性分析法(Reference Counting Collector)"></a>3.2. 可达性分析法(Reference Counting Collector)</h4><p>大多数垃圾回收算法使用了根集(root set)这个概念；所谓根集就是正在执行的Java程序可以访问的引用变量的集合(包括局部变量、参数、类变量)，程序可以使用引用变量访问对象的属性和调用对象的方法。可达性分析法首先需要确定从根开始哪些是可达的和哪些是不可达的，从根集可达的对象都是活动对象，它们不能作为垃圾被回收，这也包括从根集间接可达的对象。而根集通过任意路径不可达的对象符合垃圾收集的条件，应该被回收。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731153706.png"  alt></p><p>从图中我们可以看出：通过可达性分析法，从GC Roots开发进行对象可达性分析，可以看出obj5、obj6、obj7的对象都是不可达的，尽管他们之间存在引用关系（这种情况使用引用计数法就会存在问题）</p><h3 id="4-垃圾回收的算法分析"><a href="#4-垃圾回收的算法分析" class="headerlink" title="4. 垃圾回收的算法分析"></a>4. 垃圾回收的算法分析</h3><h4 id="4-1-tracing算法-Tracing-Collector-跟踪收集器"><a href="#4-1-tracing算法-Tracing-Collector-跟踪收集器" class="headerlink" title="4.1 tracing算法(Tracing Collector 跟踪收集器)"></a>4.1 tracing算法(Tracing Collector 跟踪收集器)</h4><p>tracing(跟踪算法)算法是为了解决引用计数法的问题而提出，它使用了根集的概念。基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象，例如对每个可达对象设置一个或多个位。<br>在扫描识别过程中，基于tracing算法的垃圾收集也称为标记和清除(mark-and-sweep)垃圾收集器.<br>标记清除算法： 顾名思义分为两步，标记和清除。首先标记到需要回收的垃圾对象，然后回收掉这些垃圾对象。</p><p>下面这张图是从网上抠的。大家可以看一下。<br><img src="/img/loading.gif" class="lazyload" data-src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731153750.png"  alt><br>标记清除算法的缺点：</p><ul><li>1、空间问题：清除垃圾对象后会造成内存的碎片化，导致会产生大量的不连续的内存碎片。</li><li>2、效率问题：标记和清除两个过程的效率都不高。</li></ul><h4 id="4-2-compacting算法-Compacting-Collector-压缩算法，较常用是基于压缩算法的整理标记算法"><a href="#4-2-compacting算法-Compacting-Collector-压缩算法，较常用是基于压缩算法的整理标记算法" class="headerlink" title="4.2 compacting算法(Compacting Collector 压缩算法，较常用是基于压缩算法的整理标记算法)"></a>4.2 compacting算法(Compacting Collector 压缩算法，较常用是基于压缩算法的整理标记算法)</h4><p>为了解决堆碎片问题，==基于压缩算法的标记整理算法==。主要是分为两步：先标记后整理。首先标记可以回收的垃圾对象。然后进行压缩。基于tracing的垃圾回收吸收了Compacting算法的思想，在清除的过程中，算法将所有的对象移到堆的一端，堆的另一端就变成了一个相邻的空闲内存区，收集器会对它移动的所有对象的所有引用进行更新，使得这些引用在新的位置能识别原来的对象。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731202739.png"  alt></p><p>基于compacting算法的标记整理算法的优点：</p><ul><li>1、避免了内存碎片；</li><li>2、避免了“复制”算法50%的空间浪费；</li><li>3、主要针对对象存活率高的老年代。</li></ul><h4 id="4-3-copying算法-Coping-Collector-复制算法"><a href="#4-3-copying算法-Coping-Collector-复制算法" class="headerlink" title="4.3 copying算法(Coping Collector 复制算法)"></a>4.3 copying算法(Coping Collector 复制算法)</h4><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成一个对象区和多个空闲区，程序从对象区为对象分配空间，当对象满了，基于coping算法的垃圾回收就从根集中扫描活动对象，并将每个活动对象复制到空闲区(使得活动对象所占的内存之间没有空闲间隔)，这样空闲区变成了对象区，原来的对象区变成了空闲区，程序会在新的对象区中分配内存。</p><p>一种典型的基于coping算法(复制算法)的垃圾回收是stop-and-copy算法，它将堆内存按容量划分为大小相等的两块：对象区和空闲区域区，每次只使用其中的一块，当这一块内存将用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次清理掉。在对象区与空闲区域的切换过程中，程序暂停执行。 </p><p><img src="/img/loading.gif" class="lazyload" data-src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/20190731203019.png"  alt></p><p>复制算法的优点</p><ul><li>1、可以有效避免内存的碎片化问题，实现简单，运行高效；每次都是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等情况，只要移动堆顶指针，按顺序分配内存即可；</li></ul><p>复制算法缺点：</p><ul><li>1、因为需要将提前预留出空闲区。他需要两倍的内存，造成内存浪费。</li><li>2、stop-and-copy算法就是复制算法收集器要复制所有的活动对象，增加了程序等待时间，算法效率很低。</li></ul><h4 id="4-4-generation算法-Generational-Collector-分代算法"><a href="#4-4-generation算法-Generational-Collector-分代算法" class="headerlink" title="4.4 generation算法(Generational Collector 分代算法)"></a>4.4 generation算法(Generational Collector 分代算法)</h4><p>stop-and-copy垃圾收集器的一个缺陷是收集器必须复制所有的活动对象，这增加了程序等待时间，这是coping算法低效的原因。在程序设计中有这样的规律：多数对象存在的时间比较短，少数的存在时间比较长。因此，generation算法将堆分成两个或多个，每个子堆作为对象的一代 (generation)。由于多数对象存在的时间比较短，随着程序丢弃不使用的对象，垃圾收集器将从最年轻的子堆中收集这些对象。在分代式的垃圾收集器运行后，上次运行存活下来的对象移到下一最高代的子堆中，由于老一代的子堆不会经常被回收，因而节省了时间。</p><p>新生代对象分为三个区域：Eden 区和两个 Survivor 区。新创建的对象都放在 Eden区，当 Eden区的内存达到阈值之后会触发 Minor GC，这时会将存活的对象复制到一个 Survivor 区中，这些存活对象的生命存活计数会加一。这时 Eden 区会闲置，当再一次达到阈值触发 Minor GC 时，会将Eden区和之前一个 Survivor 区中存活的对象复制到另一个 Survivor 区中，采用的是我之前提到的复制算法，同时它们的生命存活计数也会加一。</p><p>这个过程会持续很多遍，直到对象的存活计数达到一定的阈值后会触发一个叫做晋升的现象：新生代的这个对象会被放置到老年代中。</p><p>老年代中的对象都是经过多次 GC 依然存活的生命周期很长的 Java 对象。当老年代的内存达到阈值后会触发 Major GC，采用的是标记整理算法。</p><h4 id="4-5-adaptive算法-Adaptive-Collector-自适应算法"><a href="#4-5-adaptive算法-Adaptive-Collector-自适应算法" class="headerlink" title="4.5 adaptive算法(Adaptive Collector 自适应算法)"></a>4.5 adaptive算法(Adaptive Collector 自适应算法)</h4><p>　　在特定的情况下，一些垃圾收集算法会优于其它算法。基于Adaptive算法的垃圾收集器就是监控当前堆的使用情况，并将选择适当算法的垃圾收集器。</p><p>　　</p><h3 id="5-System-gc-方法"><a href="#5-System-gc-方法" class="headerlink" title="5. System.gc()方法"></a>5. System.gc()方法</h3><p>命令行参数透视垃圾收集器的运行<br>使用System.gc()可以不管JVM使用的是哪一种垃圾回收的算法，都可以请求Java的垃圾回收。在命令行中有一个参数-verbosegc可以查看Java使用的堆内存的情况，它的格式如下：　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -verbosegc classfile</span><br></pre></td></tr></table></figure><p>可以看个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TestGC  </span><br><span class="line">&#123;  </span><br><span class="line">    public static void main(String[] args)  </span><br><span class="line">    &#123;  </span><br><span class="line">　　    new TestGC();  </span><br><span class="line">　　    System.gc();  </span><br><span class="line">　　    System.runFinalization();  </span><br><span class="line">　　 &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，一个新的对象被创建，由于它没有使用，所以该对象迅速地变为不可达，程序编译后，执行命令：<br>java -verbosegc TestGC 后结果为：　</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 168K-&gt;97K(1984K)， 0.0253873 secs]</span><br></pre></td></tr></table></figure><p>需要注意的是，调用System.gc()也仅仅是一个请求(建议)。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。</p><h3 id="6-finalize-方法"><a href="#6-finalize-方法" class="headerlink" title="6. finalize()方法"></a>6. finalize()方法</h3><p>在JVM垃圾回收器收集一个对象之前，一般要求程序调用适当的方法释放资源，但在没有明确释放资源的情况下，Java提供了缺省机制来终止该对象心释放资源，这个方法就是finalize（）。finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。<br>它的原型为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protected void finalize() throws Throwable</span><br></pre></td></tr></table></figure><p>在finalize()方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。之所以要使用finalize()，是存在着垃圾回收器不能处理的特殊情况。</p><p>finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</p><p>另外，假定你的对象（并非使用new方法）获得了一块“特殊”的内存区域，由于垃圾回收器只知道那些显示地经由new分配的内存空间，所以它不知道该如何释放这块“特殊”的内存区域，那么这个时候java允许在类中定义一个由finalize()方法。</p><p>特殊的区域例如：</p><h5 id="1）由于在分配内存的时候可能采用了类似-C语言的做法，而非JAVA的通常new做法。"><a href="#1）由于在分配内存的时候可能采用了类似-C语言的做法，而非JAVA的通常new做法。" class="headerlink" title="1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。"></a>1）由于在分配内存的时候可能采用了类似 C语言的做法，而非JAVA的通常new做法。</h5><p>这种情况主要发生在native method中，比如native method调用了C/C++方法malloc()函数系列来分配存储空间，但是除非调用free()函数，否则这些内存空间将不会得到释放，那么这个时候就可能造成内存泄漏。但是由于free()方法是在C/C++中的函数，所以finalize()中可以用本地方法来调用它。以释放这些“特殊”的内存空间。</p><h5 id="2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。"><a href="#2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。" class="headerlink" title="2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。"></a>2）又或者打开的文件资源，这些资源不属于垃圾回收器的回收范围。</h5><p>换言之，finalize()的主要用途是释放一些其他做法开辟的内存空间，以及做一些清理工作。因为在JAVA中并没有提够像“析构”函数或者类似概念的函数，要做一些类似清理工作的时候，必须自己动手创建一个执行清理工作的普通方法，也就是override Object这个类中的finalize()方法。例如，假设某一个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦出，它可能永远都不会被清理。如果在finalize()加入某一种擦除功能，当GC工作时，finalize()得到了调用，图像就会被擦除。要是GC没有发生，那么这个图像就会<br>被一直保存下来。</p><p>所以，我们建议finalize()用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。</p><h4 id="6-1、finalize的执行过程-生命周期"><a href="#6-1、finalize的执行过程-生命周期" class="headerlink" title="6.1、finalize的执行过程(生命周期)"></a>6.1、finalize的执行过程(生命周期)</h4><p>1、首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p><p>2、具体的finalize流程：</p><p>对象存在两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：</p><ul><li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li><li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li><li>finalized: 表示GC已经对该对象执行过finalize方法</li><li>reachable: 表示GC Roots引用可达</li><li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li><li>unreachable：对象不可通过上面两种途径可达</li></ul><p>具体的状态切换看下面的图：</p><p><img src="/img/loading.gif" class="lazyload" data-src="https://raw.githubusercontent.com/FrewenWong/PicUploader/master/finalize.png"  alt></p><p>变迁说明：<br>1、新建对象首先处于[reachable, unfinalized]状态(A)</p><p>2、随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</p><p>3、若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</p><p>4、在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</p><p>5、处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</p><p>6、程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</p><p>7、若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</p><p>8、若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 垃圾回收、JVM、GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写在2019的开始</title>
      <link href="/2019/01/11/%E5%86%99%E5%9C%A82019%E7%9A%84%E5%BC%80%E5%A7%8B/"/>
      <url>/2019/01/11/%E5%86%99%E5%9C%A82019%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      
        <content type="html"><![CDATA[<p>新的一年，日志继续开始写起！！！！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多叉树的相关算法的学习与实现</title>
      <link href="/2018/11/21/%E5%A4%9A%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/11/21/%E5%A4%9A%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="多叉树的相关算法的学习与实现"><a href="#多叉树的相关算法的学习与实现" class="headerlink" title="多叉树的相关算法的学习与实现"></a>多叉树的相关算法的学习与实现</h1><p>在我们的编程的算法的中经常会用到多叉树，很简单，比如Android上的View布局就是一个最典型的View多叉树。我们通过下面这项相关算法我们可以更好的理解多叉树的设计与实现，对于Android中很多的View操作可以有更加深入的认识。</p><p>多叉树的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.frewen.algorithm.demo.tree;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 多叉树的节点</span><br><span class="line"> */</span><br><span class="line">public class MultiTreeNode&lt;Value&gt; &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 多叉树的父节点的ID</span><br><span class="line">     */</span><br><span class="line">    private int parentId;</span><br><span class="line">    /**</span><br><span class="line">     * 多叉树的节点的ID</span><br><span class="line">     */</span><br><span class="line">    private int selfId;</span><br><span class="line">    /**</span><br><span class="line">     * 多叉树节点的名字</span><br><span class="line">     */</span><br><span class="line">    protected String nodeName;</span><br><span class="line">    /**</span><br><span class="line">     * 节点对象</span><br><span class="line">     */</span><br><span class="line">    protected Value obj;</span><br><span class="line">    /**</span><br><span class="line">     * 子节点的列表</span><br><span class="line">     */</span><br><span class="line">    protected List&lt;MultiTreeNode&gt; childList = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public MultiTreeNode(Value value) &#123;</span><br><span class="line">        this.obj = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addChild(MultiTreeNode node) &#123;</span><br><span class="line">        this.childList.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化多叉树的子节点</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static MultiTreeNode&lt;String&gt; initChildList() &#123;</span><br><span class="line">        MultiTreeNode&lt;String&gt; H = new MultiTreeNode(&quot;H&quot;);</span><br><span class="line">        MultiTreeNode&lt;String&gt; I = new MultiTreeNode(&quot;I&quot;);</span><br><span class="line">        MultiTreeNode&lt;String&gt; J = new MultiTreeNode(&quot;J&quot;);</span><br><span class="line">        MultiTreeNode&lt;String&gt; E = new MultiTreeNode(&quot;E&quot;);</span><br><span class="line">        E.addChild(H);</span><br><span class="line">        E.addChild(I);</span><br><span class="line">        E.addChild(J);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MultiTreeNode&lt;String&gt; F = new MultiTreeNode(&quot;F&quot;);</span><br><span class="line">        MultiTreeNode&lt;String&gt; G = new MultiTreeNode(&quot;G&quot;);</span><br><span class="line"></span><br><span class="line">        MultiTreeNode&lt;String&gt; B = new MultiTreeNode(&quot;B&quot;);</span><br><span class="line">        MultiTreeNode&lt;String&gt; C = new MultiTreeNode(&quot;C&quot;);</span><br><span class="line">        MultiTreeNode&lt;String&gt; D = new MultiTreeNode(&quot;D&quot;);</span><br><span class="line"></span><br><span class="line">        B.addChild(E);</span><br><span class="line">        B.addChild(F);</span><br><span class="line">        D.addChild(G);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MultiTreeNode&lt;String&gt; A = new MultiTreeNode(&quot;A&quot;);</span><br><span class="line">        A.addChild(B);</span><br><span class="line">        A.addChild(C);</span><br><span class="line">        A.addChild(D);</span><br><span class="line"></span><br><span class="line">        return A;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;MultiTreeNode&gt; getChildren() &#123;</span><br><span class="line">        return this.childList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多叉树的遍历"><a href="#多叉树的遍历" class="headerlink" title="多叉树的遍历"></a>多叉树的遍历</h3><p>我们知道树的遍历，我们就绕不开两种遍历方式：递归遍历、非递归遍历。</p><p>下面我们先看一下递归遍历：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 多叉树的递归遍历。</span><br><span class="line">    * 多叉树的递归遍历：先打印根节点的值，然后依次遍历所有的子节点。持续递归。</span><br><span class="line">    *</span><br><span class="line">    * 我们可以思考一个问题：</span><br><span class="line">    * 使用递归遍历的优点：</span><br><span class="line">    * 1、递归遍历代码实现比较简单</span><br><span class="line">    *</span><br><span class="line">    * 使用递归遍历的缺点：</span><br><span class="line">    * 1、递归遍历实现不太便于理解。</span><br><span class="line">    * 2、递归遍历需要递归入栈，如果树的结构特别复杂，特别深。那么我们递归的算法递归</span><br><span class="line">    *      就会在当前线程的栈中不断的入栈,入的多了就爆了,就会抛出java.lang.StackOverflowError</span><br><span class="line">    *      这种情况在尤其在我们误入递归死循环之后肯定会出现，相信大家都遇到过。</span><br><span class="line">    * @param root</span><br><span class="line">    */</span><br><span class="line">   private static void recursionTraversal(MultiTreeNode&lt;String&gt; root) &#123;</span><br><span class="line">       if (null == root) &#123;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.print(root.obj + &quot;、&quot;);</span><br><span class="line">       for (MultiTreeNode treeNode : root.getChildren()) &#123;</span><br><span class="line">           recursionTraversal(treeNode);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>非递归遍历。非递归遍历中，我们又可以使用广度优先算法、或者是深度优先算法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 多叉树的广度优先算法（非递归方式的遍历）</span><br><span class="line">    * @param root</span><br><span class="line">    */</span><br><span class="line">   private static void breadthFirstTraversal(MultiTreeNode&lt;String&gt; root) &#123;</span><br><span class="line">       // 广度优先需要构建一个先进先出的队列</span><br><span class="line">       Deque&lt;MultiTreeNode&gt; nodeDeque = new LinkedList&lt;&gt;();</span><br><span class="line">       // 构建一个多叉树的引用，指向多叉树的Root</span><br><span class="line">       MultiTreeNode&lt;String&gt; node = root;</span><br><span class="line">       // 让根节点入队列</span><br><span class="line">       nodeDeque.push(node);</span><br><span class="line">       // 判断队列不为空，进行出队列的管理。所有广度遍历的节点依次入队列。</span><br><span class="line">       // 待队列中所有元素均出队列之后，那么也表明多叉树的遍历结束</span><br><span class="line">       while (!nodeDeque.isEmpty()) &#123;</span><br><span class="line">           // 判断出队列的node节点。第一个出来的Node节点的是根节点。</span><br><span class="line">           node = nodeDeque.pop();</span><br><span class="line">           System.out.print(node.obj + &quot;、&quot;);</span><br><span class="line">           // 因为是广度优先，所以先遍历根节点的所有的元素，然后将所有元素依次入队列</span><br><span class="line">           // 然后这样，相当于一次广度遍历</span><br><span class="line">           for (MultiTreeNode treeNode : node.getChildren()) &#123;</span><br><span class="line">               nodeDeque.addLast(treeNode);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 多叉树的深度优先算法（非递归方式的遍历）</span><br><span class="line">     * 深度优先需要构建一个后进先出的栈,</span><br><span class="line">     * @param root</span><br><span class="line">     */</span><br><span class="line">    private static void depthFirstTraversal(MultiTreeNode&lt;String&gt; root) &#123;</span><br><span class="line">        // 深度优先需要构建一个后进先出的栈,</span><br><span class="line">        Stack&lt;MultiTreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        // 构建一个多叉树的引用，指向多叉树的Root</span><br><span class="line">        MultiTreeNode&lt;String&gt; node = root;</span><br><span class="line"></span><br><span class="line">        // 让根节点入栈</span><br><span class="line">        stack.push(node);</span><br><span class="line">        // 判断栈是否为空，然后执行出栈的操作。</span><br><span class="line">        while (!stack.isEmpty()) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            System.out.print(node.obj + &quot;、&quot;);</span><br><span class="line">            // 因为是深度优先遍历，所以我们要先出栈根节点，然后，遍历根节点的所有子节点</span><br><span class="line">            // 将子节点依次入栈。这样我们就可以将最终的叶子节点位于栈顶。</span><br><span class="line">            // 然后我们依次执行出栈遍历的操作</span><br><span class="line">            List&lt;MultiTreeNode&gt; children = node.getChildren();</span><br><span class="line">            if (children != null &amp;&amp; children.size() &gt; 0) &#123;</span><br><span class="line">                // 这个我们故意从最后节点开始遍历，比较符合咱们的遍历习惯</span><br><span class="line">                for (int i = children.size() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                    stack.push(children.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>有时候，我们也需要计算多叉树的深度，多叉树的深度，通常我们是使用递归算法，具体实现见下方：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 计算多叉树的深度</span><br><span class="line">     * 树（多叉树、二叉树）的深度计算一般都是用递归计算</span><br><span class="line">     * 具体可以看多叉树的递归遍历算法</span><br><span class="line">     * @param root</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private static int maxDepth(MultiTreeNode&lt;String&gt; root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (root.getChildren() == null || root.getChildren().isEmpty()) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        int maxDepth = 0;</span><br><span class="line">        // 我们这个可以很好理解：</span><br><span class="line">        // 每当我们遍历一层子节点，我们的树的深度就会增加1。</span><br><span class="line">        // 直到递归遍历到最后的子节点位置。我们取这个子节点的最大的深度</span><br><span class="line">        // 我们就取这个子节点中最大的深度位置</span><br><span class="line">        for (MultiTreeNode node : root.getChildren()) &#123;</span><br><span class="line">            int depth = maxDepth(node) + 1;</span><br><span class="line">            if (maxDepth &lt; depth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxDepth;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Android中有很多多叉树的应用，最明显的就是Activity中的findViewById.顺便我们来学习一下这个方法，看他是使用咱们上面的哪个算法来计算View的查找的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Nullable</span><br><span class="line">   public &lt;T extends View&gt; T findViewById(@IdRes int id) &#123;</span><br><span class="line">       return getWindow().findViewById(id);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 我们通过查看可以发现，其实所有的findViewById的方法，归根结底都是调用的View中findViewById</span><br><span class="line">     * @param id</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Nullable</span><br><span class="line">    public final &lt;T extends View&gt; T findViewById(@IdRes int id) &#123;</span><br><span class="line">        if (id == NO_ID) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return findViewTraversal(id);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么很显然，我们来查看一下：findViewTraversal(id)这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 如果ID等于VIew本身的ID。则返回VIew本身。否则返回null</span><br><span class="line">     * @param id</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    protected &lt;T extends View&gt; T findViewTraversal(@IdRes int id) &#123;</span><br><span class="line">        if (id == mID) &#123;</span><br><span class="line">            return (T) this;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>额，郁闷了。说好的树查找呢！！！</p><p>别着急，我们在树的遍历中，既然需要查找。那么一般就是在VIewGroup中进行子View(树的子节点)的查找。我们来看一下ViewGroup中的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected &lt;T extends View&gt; T findViewTraversal(@IdRes int id) &#123;</span><br><span class="line">        // 如果ID等于当前ViewGroup的ID。则直接返回此ViewGroup</span><br><span class="line">        if (id == mID) &#123;</span><br><span class="line">            return (T) this;</span><br><span class="line">        &#125;</span><br><span class="line">        // 获取当前ViewGroup的所有子View(此节点下的所有子节点)</span><br><span class="line">        final View[] where = mChildren;</span><br><span class="line">        final int len = mChildrenCount;</span><br><span class="line">        // 进行子VIew的遍历</span><br><span class="line">        for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">            View v = where[i];</span><br><span class="line">            // 然后执行ViewGroup的中的子View的ID。</span><br><span class="line">            // 我们可以分析如果这个ViewGroup的都是View的话。则直接判断ID即可。</span><br><span class="line">            // 如果是ViewGroup的话，则我们在递归子ViewGroup的子View.依次类推。知道找到对应View</span><br><span class="line">            // 从这里面我们可以看出findViewById是一个深度优先的递归查找算法</span><br><span class="line">            if ((v.mPrivateFlags &amp; PFLAG_IS_ROOT_NAMESPACE) == 0) &#123;</span><br><span class="line">                v = v.findViewById(id);</span><br><span class="line"></span><br><span class="line">                if (v != null) &#123;</span><br><span class="line">                    return (T) v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们在VIewGroup中执行查找ViewGroup中的子View的ID。我们可以分析如果这个ViewGroup的都是View的话。则直接判断ID即可。如果是ViewGroup的话，则我们在递归子ViewGroup的子View.依次类推。知道找到对应View，从这里面我们可以看出findViewById是一个深度优先的递归查找算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> 多叉树;算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
