<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ReactNative的启动流程精讲(基于ReactNative0.61.5) | 麦溪·在路上</title><meta name="description" content="ReactNative的启动流程精讲(基于ReactNative0.61.5)"><meta name="keywords" content="ReactNative；Android；"><meta name="author" content="Frewen Wong"><meta name="copyright" content="Frewen Wong"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="ReactNative的启动流程精讲(基于ReactNative0.61.5)"><meta name="twitter:description" content="ReactNative的启动流程精讲(基于ReactNative0.61.5)"><meta property="og:type" content="article"><meta property="og:title" content="ReactNative的启动流程精讲(基于ReactNative0.61.5)"><meta property="og:url" content="http://www.frewen.wang/2020/03/13/ReactNative的启动流程精讲(基于ReactNative0.61.5)/"><meta property="og:site_name" content="麦溪·在路上"><meta property="og:description" content="ReactNative的启动流程精讲(基于ReactNative0.61.5)"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://www.frewen.wang/2020/03/13/ReactNative的启动流程精讲(基于ReactNative0.61.5)/"><link rel="prev" title="ReactNative的渲染流程(基于ReacNative0.61.5)" href="http://www.frewen.wang/2020/04/07/ReactNative的渲染流程(基于ReacNative0.61.5)/"><link rel="next" title="创建型模式-单例模式（Singleton Pattern）" href="http://www.frewen.wang/2019/06/13/创建型模式-单例模式（Singleton Pattern）/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Frewen Wong","link":"链接: ","source":"来源: 麦溪·在路上","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">8</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 文章分类</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/tech/"><i class="fa-fw fa fa-music"></i><span> 技术体系</span></a></li><li><a class="site-page" href="/memory/"><i class="fa-fw fa fa-film"></i><span> 时空记忆</span></a></li><li><a class="site-page" href="/media/"><i class="fa-fw fa fa-film"></i><span> 个人随笔</span></a></li><li><a class="site-page" href="/media/"><i class="fa-fw fa fa-music"></i><span> 影音娱乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ReactNative的启动流程精讲-基于ReactNative0-61-5"><span class="toc-number">1.</span> <span class="toc-text">ReactNative的启动流程精讲(基于ReactNative0.61.5)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建ReactNativeHost"><span class="toc-number">1.0.1.</span> <span class="toc-text">创建ReactNativeHost</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化ReactActivityDelegate："><span class="toc-number">1.0.2.</span> <span class="toc-text">实例化ReactActivityDelegate：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化ReactDelegate"><span class="toc-number">1.0.3.</span> <span class="toc-text">实例化ReactDelegate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化ReactInstanceManager"><span class="toc-number">1.0.4.</span> <span class="toc-text">实例化ReactInstanceManager</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#startReactApplication"><span class="toc-number">1.0.5.</span> <span class="toc-text">startReactApplication</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例化CatalystInstanceImpl"><span class="toc-number">1.0.6.</span> <span class="toc-text">实例化CatalystInstanceImpl</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">麦溪·在路上</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 文章分类</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/tech/"><i class="fa-fw fa fa-music"></i><span> 技术体系</span></a></li><li><a class="site-page" href="/memory/"><i class="fa-fw fa fa-film"></i><span> 时空记忆</span></a></li><li><a class="site-page" href="/media/"><i class="fa-fw fa fa-film"></i><span> 个人随笔</span></a></li><li><a class="site-page" href="/media/"><i class="fa-fw fa fa-music"></i><span> 影音娱乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 文章目录</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">ReactNative的启动流程精讲(基于ReactNative0.61.5)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-13 21:00:02"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-03-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-04 23:57:30"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-04</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="ReactNative的启动流程精讲-基于ReactNative0-61-5"><a href="#ReactNative的启动流程精讲-基于ReactNative0-61-5" class="headerlink" title="ReactNative的启动流程精讲(基于ReactNative0.61.5)"></a>ReactNative的启动流程精讲(基于ReactNative0.61.5)</h1><p>文章参考：<a href="https://github.com/sucese/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/3ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.md" target="_blank" rel="noopener">https://github.com/sucese/react-native/blob/master/doc/ReactNative%E6%BA%90%E7%A0%81%E7%AF%87/3ReactNative%E6%BA%90%E7%A0%81%E7%AF%87%EF%BC%9A%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.md</a></p>
<p>文章参考：<a href="https://www.jianshu.com/p/baff68f85d41" target="_blank" rel="noopener">https://www.jianshu.com/p/baff68f85d41</a></p>
<h3 id="创建ReactNativeHost"><a href="#创建ReactNativeHost" class="headerlink" title="创建ReactNativeHost"></a>创建ReactNativeHost</h3><p>ReactNative的启动流程，我们首先看Application中的代码，实例化ReactNativeHost。ReactNativeHost主要的工作就是创建了ReactInstanceManager，它将一些信息传递给了ReactInstanceManager。同时，我们看一下ReactNativeHost的提供的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ReactNativeHost &#123;</span><br><span class="line">   </span><br><span class="line">      protected ReactInstanceManager createReactInstanceManager() &#123;</span><br><span class="line">        ReactInstanceManagerBuilder builder = ReactInstanceManager.builder()</span><br><span class="line">          //应用上下文</span><br><span class="line">          .setApplication(mApplication)</span><br><span class="line">          //JSMainModuleP相当于应用首页的js Bundle，可以传递url从服务器拉取js Bundle</span><br><span class="line">          //当然这个只在dev模式下可以使用</span><br><span class="line">          .setJSMainModulePath(getJSMainModuleName())</span><br><span class="line">          //是否开启dev模式</span><br><span class="line">          .setUseDeveloperSupport(getUseDeveloperSupport())</span><br><span class="line">          //红盒的回调</span><br><span class="line">          .setRedBoxHandler(getRedBoxHandler())</span><br><span class="line">          //自定义UI实现机制，这个我们一般用不到</span><br><span class="line">          .setUIImplementationProvider(getUIImplementationProvider())</span><br><span class="line">          .setInitialLifecycleState(LifecycleState.BEFORE_CREATE);</span><br><span class="line">    </span><br><span class="line">        //添加ReactPackage</span><br><span class="line">        for (ReactPackage reactPackage : getPackages()) &#123;</span><br><span class="line">          builder.addPackage(reactPackage);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        //获取js Bundle的加载路径</span><br><span class="line">        String jsBundleFile = getJSBundleFile();</span><br><span class="line">        if (jsBundleFile != null) &#123;</span><br><span class="line">          builder.setJSBundleFile(jsBundleFile);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          builder.setBundleAssetName(Assertions.assertNotNull(getBundleAssetName()));</span><br><span class="line">        &#125;</span><br><span class="line">        return builder.build();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是ReactNativeHost提供的一些方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected @Nullable RedBoxHandler getRedBoxHandler();</span><br><span class="line">protected @Nullable JavaScriptExecutorFactory getJavaScriptExecutorFactory();</span><br><span class="line">protected final Application getApplication();</span><br><span class="line">protected UIImplementationProvider getUIImplementationProvider();</span><br></pre></td></tr></table></figure>

<h3 id="实例化ReactActivityDelegate："><a href="#实例化ReactActivityDelegate：" class="headerlink" title="实例化ReactActivityDelegate："></a>实例化ReactActivityDelegate：</h3><p>启动ReactActivity的子类实例，在这个Activty的启动流程中，正式开始我们ReactNative启动和加载流程。<br>我们先来分析一下ReactActivityDelegate。我么可以看到ReactActivityDelegate的一些提供的方法。就知道这个类的一些职责。他主要就是Activity的宿主的一些生命周期的委托调用。也就是所有ReactNative和宿主Activity的关联都是通过这个类类简历联系的。</p>
<p>当然我们也看到。其实所有的生命周期的方法。这个类要么委托给ReactDelegate。要么就是直接ReactInstanceManager进行处理。所以这个类的职责也是非常简单的。</p>
<p>可以说ReactNative和她的宿主Activity达到了很好的解耦。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ReactActivity extends AppCompatActivity</span><br><span class="line">    implements DefaultHardwareBackBtnHandler, PermissionAwareActivity &#123;</span><br><span class="line"></span><br><span class="line">  private final ReactActivityDelegate mDelegate;</span><br><span class="line"></span><br><span class="line">  protected ReactActivity() &#123;</span><br><span class="line">    mDelegate = createReactActivityDelegate();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Returns the name of the main component registered from JavaScript. This is used to schedule</span><br><span class="line">   * rendering of the component. e.g. &quot;MoviesApp&quot;</span><br><span class="line">   */</span><br><span class="line">  protected @Nullable String getMainComponentName() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Called at construction time, override if you have a custom delegate implementation. */</span><br><span class="line">  protected ReactActivityDelegate createReactActivityDelegate() &#123;</span><br><span class="line">    return new ReactActivityDelegate(this, getMainComponentName());</span><br><span class="line">  &#125;</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类很简单，就是实例化的一个Activity的委托对象。然后所有的生命周期调用全部使用ReactActivityDelegate的代理对象完成。</p>
<p>那么下面，我们看一下这个类的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public ReactActivityDelegate(ReactActivity activity, @Nullable String mainComponentName) &#123;</span><br><span class="line">    Log.d(TAG, &quot;第二步：FMsg: 实例化ReactActivityDelegate called with: activity = [&quot; + activity + &quot;], mainComponentName = [&quot; + mainComponentName + &quot;]&quot;);</span><br><span class="line">    mActivity = activity;</span><br><span class="line">    mMainComponentName = mainComponentName;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们看一下。Activity的onCreate的方法的代理实现。</p>
<h3 id="实例化ReactDelegate"><a href="#实例化ReactDelegate" class="headerlink" title="实例化ReactDelegate"></a>实例化ReactDelegate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    String mainComponentName = getMainComponentName();</span><br><span class="line">    mReactDelegate =</span><br><span class="line">        new ReactDelegate(</span><br><span class="line">            getPlainActivity(), getReactNativeHost(), mainComponentName, getLaunchOptions()) &#123;</span><br><span class="line">          @Override</span><br><span class="line">          protected ReactRootView createRootView() &#123;</span><br><span class="line">            return ReactActivityDelegate.this.createRootView();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    //mMainComponentName就是上面ReactActivity.getMainComponentName()返回的组件名    </span><br><span class="line">    if (mMainComponentName != null) &#123;</span><br><span class="line">      //载入app页面</span><br><span class="line">      loadApp(mainComponentName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一个，实例化ReactDelegate对象。二是调用loadApp的方法。</p>
<p>我们来看一下ReactDelegate的这个对象。他的职责到底是什么呢？？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">protected void loadApp(String appKey) &#123;</span><br><span class="line">    mReactDelegate.loadApp(appKey);</span><br><span class="line">    getPlainActivity().setContentView(mReactDelegate.getReactRootView());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个方法很简单。还是调用了ReactDelegate的loadApp方法。至此位置ReactActivityDelegate的启动流程中的职责也就告一段落。下面我们看一下ReactDelegate里面的loadApp</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void loadApp(String appKey) &#123;</span><br><span class="line">  if (mReactRootView != null) &#123;</span><br><span class="line">    throw new IllegalStateException(&quot;Cannot loadApp while app is already running.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  //创建ReactRootView作为根视图,它本质上是一个FrameLayout</span><br><span class="line">  mReactRootView = createRootView();、</span><br><span class="line">  //启动RN应用.这个地方我们要注意下。ReactInstanceManager就是从这个地方开始实例化的。</span><br><span class="line">  mReactRootView.startReactApplication(</span><br><span class="line">      getReactNativeHost().getReactInstanceManager(), appKey, mLaunchOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终这个方法是调用到ReactRootView。这个View我们知道，其实就是我们通过setContentView设置给Activity宿主的FameLayout</p>
<h3 id="实例化ReactInstanceManager"><a href="#实例化ReactInstanceManager" class="headerlink" title="实例化ReactInstanceManager"></a>实例化ReactInstanceManager</h3><p>我们可以从代码中看到，在startReactApplication的时候，我们通过ReactNativeHost的实例化对象来获取ReactInstanceManager</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">/** Get the current &#123;@link ReactInstanceManager&#125; instance, or create one. */</span><br><span class="line"> public ReactInstanceManager getReactInstanceManager() &#123;</span><br><span class="line">   if (mReactInstanceManager == null) &#123;</span><br><span class="line">     ReactMarker.logMarker(ReactMarkerConstants.GET_REACT_INSTANCE_MANAGER_START);</span><br><span class="line">     mReactInstanceManager = createReactInstanceManager();</span><br><span class="line">     ReactMarker.logMarker(ReactMarkerConstants.GET_REACT_INSTANCE_MANAGER_END);</span><br><span class="line">   &#125;</span><br><span class="line">   return mReactInstanceManager;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> protected ReactInstanceManager createReactInstanceManager() &#123;</span><br><span class="line">   ReactMarker.logMarker(ReactMarkerConstants.BUILD_REACT_INSTANCE_MANAGER_START);</span><br><span class="line">   Log.d(TAG, &quot;FMsg:第五步：createReactInstanceManager() called&quot;);</span><br><span class="line">   ReactInstanceManagerBuilder builder =</span><br><span class="line">       ReactInstanceManager.builder()</span><br><span class="line">           .setApplication(mApplication)</span><br><span class="line">            // 设置JSMain的根路径地址。也就是index.js  //&quot;index.android&quot;</span><br><span class="line">           .setJSMainModulePath(getJSMainModuleName())</span><br><span class="line">           .setUseDeveloperSupport(getUseDeveloperSupport())</span><br><span class="line">           //红盒的回调</span><br><span class="line">           .setRedBoxHandler(getRedBoxHandler())</span><br><span class="line">           // 获取JS执行引擎的工作累的方法。默认是JSC。当然我们也可以自定义设置成V8的引擎</span><br><span class="line">           // 如果需要自定义设置，那么Application中重写这个方法</span><br><span class="line">           .setJavaScriptExecutorFactory(getJavaScriptExecutorFactory())</span><br><span class="line">            //自定义UI实现机制，这个我们一般用不到</span><br><span class="line">           .setUIImplementationProvider(getUIImplementationProvider())</span><br><span class="line">           .setJSIModulesPackage(getJSIModulePackage())</span><br><span class="line">           .setInitialLifecycleState(LifecycleState.BEFORE_CREATE);</span><br><span class="line">   // 类实例化的作用就是传递给ReactInstanceManager所有的Packages</span><br><span class="line">   Log.i(TAG, &quot;FMsg:第五步：createReactInstanceManager: addPackage  size = &quot; + getPackages().size());</span><br><span class="line">   // 这个使我们Application实例化的时候，我们提供的ReactPackage</span><br><span class="line">   for (ReactPackage reactPackage : getPackages()) &#123;</span><br><span class="line">     builder.addPackage(reactPackage);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String jsBundleFile = getJSBundleFile();</span><br><span class="line">   Log.i(TAG, &quot;FMsg:第五步：createReactInstanceManager: jsBundleFile = &quot;+jsBundleFile);</span><br><span class="line">   if (jsBundleFile != null) &#123;</span><br><span class="line">     builder.setJSBundleFile(jsBundleFile);</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">     builder.setBundleAssetName(Assertions.assertNotNull(getBundleAssetName()));</span><br><span class="line">   &#125;</span><br><span class="line">   // 这个建造者模式，可以好好分析一下。里面有很多的默认参数</span><br><span class="line">   ReactInstanceManager reactInstanceManager = builder.build();</span><br><span class="line">   ReactMarker.logMarker(ReactMarkerConstants.BUILD_REACT_INSTANCE_MANAGER_END);</span><br><span class="line">   return reactInstanceManager;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其实从这个地方。ReactNativeHost的历史使命就完成了。所有我们复写的他的提供方法都是在这个地方传递给ReactInstance的构造化实例对象。</p>
<p>下面，我们来看一下ReactInstanceManager的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/* package */ ReactInstanceManager(</span><br><span class="line">     Context applicationContext,</span><br><span class="line">     @Nullable Activity currentActivity,</span><br><span class="line">     @Nullable DefaultHardwareBackBtnHandler defaultHardwareBackBtnHandler,</span><br><span class="line">     JavaScriptExecutorFactory javaScriptExecutorFactory,</span><br><span class="line">     @Nullable JSBundleLoader bundleLoader,</span><br><span class="line">     @Nullable String jsMainModulePath,</span><br><span class="line">     List&lt;ReactPackage&gt; packages,</span><br><span class="line">     boolean useDeveloperSupport,</span><br><span class="line">     @Nullable NotThreadSafeBridgeIdleDebugListener bridgeIdleDebugListener,</span><br><span class="line">     LifecycleState initialLifecycleState,</span><br><span class="line">     @Nullable UIImplementationProvider mUIImplementationProvider,</span><br><span class="line">     NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler,</span><br><span class="line">     @Nullable RedBoxHandler redBoxHandler,</span><br><span class="line">     boolean lazyViewManagersEnabled,</span><br><span class="line">     @Nullable DevBundleDownloadListener devBundleDownloadListener,</span><br><span class="line">     int minNumShakes,</span><br><span class="line">     // 这个参数也比较重要，这个参数就是ReactNative的刷新帧的频率。默认-1.表示直接使用Android的刷新帧频率</span><br><span class="line">     int minTimeLeftInFrameForNonBatchedOperationMs,</span><br><span class="line">     @Nullable JSIModulePackage jsiModulePackage,</span><br><span class="line">     @Nullable Map&lt;String, RequestHandler&gt; customPackagerCommandHandlers) &#123;</span><br><span class="line">   Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.ctor()&quot;);</span><br><span class="line">   Log.d(TAG, &quot;FMsg:第五步：ReactInstanceManager() called with: currentActivity = [&quot; + currentActivity + &quot;], defaultHardwareBackBtnHandler = [&quot; + defaultHardwareBackBtnHandler + &quot;], javaScriptExecutorFactory = [&quot; + javaScriptExecutorFactory + &quot;], bundleLoader = [&quot; + bundleLoader + &quot;], jsMainModulePath = [&quot; + jsMainModulePath + &quot;], packages = [&quot; + packages + &quot;], useDeveloperSupport = [&quot; + useDeveloperSupport + &quot;], bridgeIdleDebugListener = [&quot; + bridgeIdleDebugListener + &quot;], initialLifecycleState = [&quot; + initialLifecycleState + &quot;], mUIImplementationProvider = [&quot; + mUIImplementationProvider + &quot;], nativeModuleCallExceptionHandler = [&quot; + nativeModuleCallExceptionHandler + &quot;], redBoxHandler = [&quot; + redBoxHandler + &quot;], lazyViewManagersEnabled = [&quot; + lazyViewManagersEnabled + &quot;], devBundleDownloadListener = [&quot; + devBundleDownloadListener + &quot;], minNumShakes = [&quot; + minNumShakes + &quot;], minTimeLeftInFrameForNonBatchedOperationMs = [&quot; + minTimeLeftInFrameForNonBatchedOperationMs + &quot;], jsiModulePackage = [&quot; + jsiModulePackage + &quot;], customPackagerCommandHandlers = [&quot; + customPackagerCommandHandlers + &quot;]&quot;);</span><br><span class="line">   initializeSoLoaderIfNecessary(applicationContext);</span><br><span class="line"></span><br><span class="line">   DisplayMetricsHolder.initDisplayMetricsIfNotInitialized(applicationContext);</span><br><span class="line"></span><br><span class="line">   mApplicationContext = applicationContext;</span><br><span class="line">   mCurrentActivity = currentActivity;</span><br><span class="line">   mDefaultBackButtonImpl = defaultHardwareBackBtnHandler;</span><br><span class="line">   // 其实默认传入的null  如果我们想使用其他JS引擎，比如V8.我们可以在这里面进行传入</span><br><span class="line">   mJavaScriptExecutorFactory = javaScriptExecutorFactory;</span><br><span class="line">   mBundleLoader = bundleLoader;</span><br><span class="line">   mJSMainModulePath = jsMainModulePath;</span><br><span class="line">   mPackages = new ArrayList&lt;&gt;();</span><br><span class="line">   mUseDeveloperSupport = useDeveloperSupport;</span><br><span class="line">   Systrace.beginSection(</span><br><span class="line">       Systrace.TRACE_TAG_REACT_JAVA_BRIDGE, &quot;ReactInstanceManager.initDevSupportManager&quot;);</span><br><span class="line">   mDevSupportManager =</span><br><span class="line">       DevSupportManagerFactory.create(</span><br><span class="line">           applicationContext,</span><br><span class="line">           createDevHelperInterface(),</span><br><span class="line">           mJSMainModulePath,</span><br><span class="line">           useDeveloperSupport,</span><br><span class="line">           redBoxHandler,</span><br><span class="line">           devBundleDownloadListener,</span><br><span class="line">           minNumShakes,</span><br><span class="line">           customPackagerCommandHandlers);</span><br><span class="line">   Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">   mBridgeIdleDebugListener = bridgeIdleDebugListener;</span><br><span class="line">   mLifecycleState = initialLifecycleState;</span><br><span class="line">   mMemoryPressureRouter = new MemoryPressureRouter(applicationContext);</span><br><span class="line">   mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;</span><br><span class="line"></span><br><span class="line">   /// 这个地方就是添加ReactPackage</span><br><span class="line">   synchronized (mPackages) &#123;</span><br><span class="line">     PrinterHolder.getPrinter()</span><br><span class="line">         .logMessage(ReactDebugOverlayTags.RN_CORE, &quot;RNCore: Use Split Packages&quot;);</span><br><span class="line">     // 这个方法很重要，这个方法我们会将系统内置的那些CoreModulesPackage添加进去</span><br><span class="line">     // AndroidInfoModule.class,</span><br><span class="line">     // DeviceEventManagerModule.class,</span><br><span class="line">     // DeviceInfoModule.class,</span><br><span class="line">     // DevSettingsModule.class,</span><br><span class="line">     // ExceptionsManagerModule.class,</span><br><span class="line">     // HeadlessJsTaskSupportModule.class,</span><br><span class="line">     // SourceCodeModule.class,</span><br><span class="line">     // Timing.class,</span><br><span class="line">     // UIManagerModule.class</span><br><span class="line">     mPackages.add(</span><br><span class="line">         new CoreModulesPackage(</span><br><span class="line">             this,</span><br><span class="line">             new DefaultHardwareBackBtnHandler() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               public void invokeDefaultOnBackPressed() &#123;</span><br><span class="line">                 ReactInstanceManager.this.invokeDefaultOnBackPressed();</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;,</span><br><span class="line">             mUIImplementationProvider,</span><br><span class="line">             lazyViewManagersEnabled,</span><br><span class="line">             minTimeLeftInFrameForNonBatchedOperationMs));</span><br><span class="line">     if (mUseDeveloperSupport) &#123;</span><br><span class="line">       mPackages.add(new DebugCorePackage());</span><br><span class="line">     &#125;</span><br><span class="line">     mPackages.addAll(packages);</span><br><span class="line">   &#125;</span><br><span class="line">   mJSIModulePackage = jsiModulePackage;</span><br><span class="line"></span><br><span class="line">   // Instantiate ReactChoreographer in UI thread.</span><br><span class="line">   // 这个就是实例化Android的序列帧的监听对象</span><br><span class="line">   ReactChoreographer.initialize();</span><br><span class="line">   if (mUseDeveloperSupport) &#123;</span><br><span class="line">     mDevSupportManager.startInspector();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>从ReactInstanceManager的构造函数，我们可以看到。所有ReactNative的启动的初始化资源基本都已经准备完毕。所以startReactApplication的方法。我们必须要传入ReactInstanceManager实例化对象。</p>
<p>其实通过查看ReactInstance的类的内容，我们可以看到这个类的方法其实也是比较简单的。他的关于启动流程最大的一个作用就是创建ReactContext。那么这个创建ReactContext是什么开始的呢？</p>
<p>我们来继续看ReactRootView的startReactApplication方法。</p>
<h3 id="startReactApplication"><a href="#startReactApplication" class="headerlink" title="startReactApplication"></a>startReactApplication</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@ThreadConfined(UI)</span><br><span class="line">public void startReactApplication(</span><br><span class="line">    ReactInstanceManager reactInstanceManager,</span><br><span class="line">    String moduleName,</span><br><span class="line">    @Nullable Bundle initialProperties,</span><br><span class="line">    @Nullable String initialUITemplate) &#123;</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;startReactApplication&quot;);</span><br><span class="line">  try &#123;</span><br><span class="line">    // 线程检查</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line"></span><br><span class="line">    // TODO(6788889): Use POJO instead of bundle here, apparently we can&apos;t just use WritableMap</span><br><span class="line">    // here as it may be deallocated in native after passing via JNI bridge, but we want to reuse</span><br><span class="line">    // it in the case of re-creating the catalyst instance</span><br><span class="line">    Assertions.assertCondition(</span><br><span class="line">        mReactInstanceManager == null,</span><br><span class="line">        &quot;This root view has already been attached to a catalyst instance manager&quot;);</span><br><span class="line"></span><br><span class="line">    mReactInstanceManager = reactInstanceManager;</span><br><span class="line">    mJSModuleName = moduleName;</span><br><span class="line">    mAppProperties = initialProperties;</span><br><span class="line">    mInitialUITemplate = initialUITemplate;</span><br><span class="line"></span><br><span class="line">    if (mUseSurface) &#123;</span><br><span class="line">      // TODO initialize surface here</span><br><span class="line">    &#125;</span><br><span class="line">    //创建RN上下文上下文对象</span><br><span class="line">    mReactInstanceManager.createReactContextInBackground();</span><br><span class="line">    //attachToReactInstanceManager 调用的是mReactInstanceManager.attachRootView(this)</span><br><span class="line">    attachToReactInstanceManager();</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法比较深，我们可以一步步往下看。进入到这个方法，就进入到ReactInstance的核心功能。也是ReactNative启动的核心流程。也是最重要的流程中。createReactContext的创建流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line">@ThreadConfined(UI)</span><br><span class="line">  public void createReactContextInBackground() &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.createReactContextInBackground()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：ReactRootView开始创建ReactContext createReactContextInBackground() called&quot;);</span><br><span class="line">    UiThreadUtil</span><br><span class="line">        .assertOnUiThread(); // Assert before setting mHasStartedCreatingInitialContext = true</span><br><span class="line">    if (!mHasStartedCreatingInitialContext) &#123;</span><br><span class="line">      mHasStartedCreatingInitialContext = true;</span><br><span class="line">      recreateReactContextInBackgroundInner();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   @ThreadConfined(UI)</span><br><span class="line">  private void recreateReactContextInBackgroundInner() &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.recreateReactContextInBackgroundInner()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：调用内部方法recreateReactContextInBackgroundInner() called&quot;);</span><br><span class="line">    PrinterHolder.getPrinter()</span><br><span class="line">        .logMessage(ReactDebugOverlayTags.RN_CORE, &quot;RNCore: recreateReactContextInBackground&quot;);</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line">    // 调试相关的逻辑，咱们暂时忽略</span><br><span class="line">    if (mUseDeveloperSupport &amp;&amp; mJSMainModulePath != null) &#123;</span><br><span class="line">      final DeveloperSettings devSettings = mDevSupportManager.getDevSettings();</span><br><span class="line"></span><br><span class="line">      if (!Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;</span><br><span class="line">        if (mBundleLoader == null) &#123;</span><br><span class="line">          mDevSupportManager.handleReloadJS();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          mDevSupportManager.isPackagerRunning(</span><br><span class="line">              new PackagerStatusCallback() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onPackagerStatusFetched(final boolean packagerIsRunning) &#123;</span><br><span class="line">                  UiThreadUtil.runOnUiThread(</span><br><span class="line">                      new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                          if (packagerIsRunning) &#123;</span><br><span class="line">                            mDevSupportManager.handleReloadJS();</span><br><span class="line">                          &#125; else if (mDevSupportManager.hasUpToDateJSBundleInCache()</span><br><span class="line">                              &amp;&amp; !devSettings.isRemoteJSDebugEnabled()) &#123;</span><br><span class="line">                            // If there is a up-to-date bundle downloaded from server,</span><br><span class="line">                            // with remote JS debugging disabled, always use that.</span><br><span class="line">                            onJSBundleLoadedFromServer(null);</span><br><span class="line">                          &#125; else &#123;</span><br><span class="line">                            // If dev server is down, disable the remote JS debugging.</span><br><span class="line">                            devSettings.setRemoteJSDebugEnabled(false);</span><br><span class="line">                            recreateReactContextInBackgroundFromBundleLoader();</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    recreateReactContextInBackgroundFromBundleLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">   @ThreadConfined(UI)</span><br><span class="line">  private void recreateReactContextInBackgroundFromBundleLoader() &#123;</span><br><span class="line">    Log.d(</span><br><span class="line">        ReactConstants.TAG,</span><br><span class="line">        &quot;ReactInstanceManager.recreateReactContextInBackgroundFromBundleLoader()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：线上环境来将会使用后台任务创建ReactContext recreateReactContextInBackgroundFromBundleLoader() called&quot;);</span><br><span class="line">    PrinterHolder.getPrinter()</span><br><span class="line">        .logMessage(ReactDebugOverlayTags.RN_CORE, &quot;RNCore: load from BundleLoader&quot;);</span><br><span class="line">    recreateReactContextInBackground(mJavaScriptExecutorFactory, mBundleLoader);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    @ThreadConfined(UI)</span><br><span class="line">  private void runCreateReactContextOnNewThread(final ReactContextInitParams initParams) &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.runCreateReactContextOnNewThread()&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第六步：runCreateReactContextOnNewThread() called with: initParams = [&quot; + initParams + &quot;]&quot;);</span><br><span class="line">    UiThreadUtil.assertOnUiThread();</span><br><span class="line">    synchronized (mAttachedReactRoots) &#123;</span><br><span class="line">      synchronized (mReactContextLock) &#123;</span><br><span class="line">        // 生命周期的回收，主要是针对可能会造成的多次初始化RN环境的</span><br><span class="line">        if (mCurrentReactContext != null) &#123;</span><br><span class="line">          tearDownReactContext(mCurrentReactContext);</span><br><span class="line">          mCurrentReactContext = null;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCreateReactContextThread =</span><br><span class="line">        new Thread(</span><br><span class="line">            null,</span><br><span class="line">            new Runnable() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void run() &#123;</span><br><span class="line">                ReactMarker.logMarker(REACT_CONTEXT_THREAD_END);</span><br><span class="line">                synchronized (ReactInstanceManager.this.mHasStartedDestroying) &#123;</span><br><span class="line">                  while (ReactInstanceManager.this.mHasStartedDestroying) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                      ReactInstanceManager.this.mHasStartedDestroying.wait();</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                      continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // As destroy() may have run and set this to false, ensure that it is true before we</span><br><span class="line">                // create</span><br><span class="line">                mHasStartedCreatingInitialContext = true;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                  Process.setThreadPriority(Process.THREAD_PRIORITY_DISPLAY);</span><br><span class="line">                  ReactMarker.logMarker(VM_INIT);</span><br><span class="line">                  Log.i(TAG, &quot;FMsg:第六步：runCreateReactContextOnNewThread run: &quot; + Thread.currentThread().getName());</span><br><span class="line">                  final ReactApplicationContext reactApplicationContext =</span><br><span class="line">                      createReactContext(</span><br><span class="line">                          initParams.getJsExecutorFactory().create(),</span><br><span class="line">                          initParams.getJsBundleLoader());</span><br><span class="line"></span><br><span class="line">                  mCreateReactContextThread = null;</span><br><span class="line">                  ReactMarker.logMarker(PRE_SETUP_REACT_CONTEXT_START);</span><br><span class="line"></span><br><span class="line">                  // 这个地方也是一个保护机制，我们暂时不需要关注</span><br><span class="line">                  final Runnable maybeRecreateReactContextRunnable =</span><br><span class="line">                      new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                          if (mPendingReactContextInitParams != null) &#123;</span><br><span class="line">                            runCreateReactContextOnNewThread(mPendingReactContextInitParams);</span><br><span class="line">                            mPendingReactContextInitParams = null;</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;;</span><br><span class="line">                  Runnable setupReactContextRunnable =</span><br><span class="line">                      new Runnable() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                          try &#123;</span><br><span class="line">                            setupReactContext(reactApplicationContext);</span><br><span class="line">                          &#125; catch (Exception e) &#123;</span><br><span class="line">                            mDevSupportManager.handleException(e);</span><br><span class="line">                          &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                      &#125;;</span><br><span class="line"></span><br><span class="line">                  reactApplicationContext.runOnNativeModulesQueueThread(setupReactContextRunnable);</span><br><span class="line">                  UiThreadUtil.runOnUiThread(maybeRecreateReactContextRunnable);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                  mDevSupportManager.handleException(e);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;create_react_context&quot;);</span><br><span class="line">    ReactMarker.logMarker(REACT_CONTEXT_THREAD_START);</span><br><span class="line">    mCreateReactContextThread.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这个地方就是我们比较重要的创建ReactContext对象的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"> /** @return instance of &#123;@link ReactContext&#125; configured a &#123;@link CatalystInstance&#125; set */</span><br><span class="line">private ReactApplicationContext createReactContext(</span><br><span class="line">    JavaScriptExecutor jsExecutor, JSBundleLoader jsBundleLoader) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第六步：ReactInstanceManager.createReactContext &quot; + Thread.currentThread().getName());</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第六步：createReactContext() called with: jsExecutor = [&quot; + jsExecutor + &quot;], jsBundleLoader = [&quot; + jsBundleLoader + &quot;]&quot;);</span><br><span class="line">  ReactMarker.logMarker(CREATE_REACT_CONTEXT_START, jsExecutor.getName());</span><br><span class="line">  // 这个地方就进行了实例化reactContext</span><br><span class="line">  // ReactApplicationContext extends ReactContext extends ContextWrapper</span><br><span class="line">  // 构造函数传入的是Context。 eactApplicationContext是ReactContext的包装类。</span><br><span class="line">  final ReactApplicationContext reactContext = new ReactApplicationContext(mApplicationContext);</span><br><span class="line"></span><br><span class="line">  // 这个就是NativeModuleCallExceptionHandler.异常捕获器</span><br><span class="line">  NativeModuleCallExceptionHandler exceptionHandler =</span><br><span class="line">      mNativeModuleCallExceptionHandler != null</span><br><span class="line">          ? mNativeModuleCallExceptionHandler</span><br><span class="line">          : mDevSupportManager;</span><br><span class="line">  reactContext.setNativeModuleCallExceptionHandler(exceptionHandler);</span><br><span class="line"></span><br><span class="line">  // 创建JavaModule注册表Builder，用来创建JavaModule注册表，JavaModule注册表将所有的JavaModule注册到CatalystInstance中。</span><br><span class="line">  NativeModuleRegistry nativeModuleRegistry = processPackages(reactContext, mPackages, false);</span><br><span class="line">  // 最最重要的一个对象，催化器实例对象</span><br><span class="line">  // jsExecutor、nativeModuleRegistry、nativeModuleRegistry等各种参数处理好之后，开始构建CatalystInstanceImpl实例。</span><br><span class="line">  CatalystInstanceImpl.Builder catalystInstanceBuilder =</span><br><span class="line">      new CatalystInstanceImpl.Builder()</span><br><span class="line">              // 设置ReactNative的消息队列的配置数据</span><br><span class="line">          .setReactQueueConfigurationSpec(ReactQueueConfigurationSpec.createDefault())</span><br><span class="line">              // 通过JS执行器工厂实例化的JS线程执行器</span><br><span class="line">          .setJSExecutor(jsExecutor)</span><br><span class="line">          .setRegistry(nativeModuleRegistry)</span><br><span class="line">          .setJSBundleLoader(jsBundleLoader)</span><br><span class="line">          .setNativeModuleCallExceptionHandler(exceptionHandler);</span><br><span class="line"></span><br><span class="line">  ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_START);</span><br><span class="line">  // CREATE_CATALYST_INSTANCE_END is in JSCExecutor.cpp</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;createCatalystInstance&quot;);</span><br><span class="line">  final CatalystInstance catalystInstance;</span><br><span class="line">  try &#123;</span><br><span class="line">    // 没什么好说的。空值判断。但是催化器的构造函数我们需要研究一下。</span><br><span class="line">    // 里面针对消息队列的线程进行初始化</span><br><span class="line">    catalystInstance = catalystInstanceBuilder.build();</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">    ReactMarker.logMarker(CREATE_CATALYST_INSTANCE_END);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 关联ReacContext与CatalystInstance实例化</span><br><span class="line">  // 解析上面实例化的是三个线程封装对象</span><br><span class="line">  reactContext.initializeWithInstance(catalystInstance);</span><br><span class="line"></span><br><span class="line">  if (mJSIModulePackage != null) &#123;</span><br><span class="line">    // 这个默认是为null的。这个数据最初是在ReactNativeHost里面传入的</span><br><span class="line">    catalystInstance.addJSIModules(</span><br><span class="line">        mJSIModulePackage.getJSIModules(</span><br><span class="line">            reactContext, catalystInstance.getJavaScriptContextHolder()));</span><br><span class="line">    // 这个地方没太看懂</span><br><span class="line">    if (ReactFeatureFlags.useTurboModules) &#123;</span><br><span class="line">      catalystInstance.setTurboModuleManager(</span><br><span class="line">          catalystInstance.getJSIModule(JSIModuleType.TurboModuleManager));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (mBridgeIdleDebugListener != null) &#123;</span><br><span class="line">    catalystInstance.addBridgeIdleDebugListener(mBridgeIdleDebugListener);</span><br><span class="line">  &#125;</span><br><span class="line">  if (Systrace.isTracing(TRACE_TAG_REACT_APPS | TRACE_TAG_REACT_JS_VM_CALLS)) &#123;</span><br><span class="line">    catalystInstance.setGlobalVariable(&quot;__RCTProfileIsProfiling&quot;, &quot;true&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  ReactMarker.logMarker(ReactMarkerConstants.PRE_RUN_JS_BUNDLE_START);</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;runJSBundle&quot;);</span><br><span class="line">  // 加载JSBundle的数据</span><br><span class="line">  catalystInstance.runJSBundle();</span><br><span class="line">  Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line"></span><br><span class="line">  return reactContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是非常重要的方法，我们需要一点点来分析一下。</p>
<p>1、首先他将Application的对象用ReactApplicationContext进行包装，生成ReactApplication对象。这个没什么好说的。简单的包装而已。</p>
<p>2、创建JavaModule的注册表</p>
<p>3、进行CatalystInstanceImpl实例化</p>
<p>4、关联ReacContext与CatalystInstance实例化 解析上面实例化的是三个线程封装对象。这个地方。</p>
<p> 我们主要作用是让reactContext来持有catalystInstance对象 两个作用：1、获取这个实力上面传入ReactQueueConfigurationSpec实例，或者三个消息队列线程封装的对象        2、主要是通过催化器实例获取JSModule、NativeModule</p>
<p>其次，ReacContext还有就是一些生命周期的管理</p>
<h3 id="实例化CatalystInstanceImpl"><a href="#实例化CatalystInstanceImpl" class="headerlink" title="实例化CatalystInstanceImpl"></a>实例化CatalystInstanceImpl</h3><p>下面就是最重要的催化剂实例的构造方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private CatalystInstanceImpl(</span><br><span class="line">      final ReactQueueConfigurationSpec reactQueueConfigurationSpec,</span><br><span class="line">      final JavaScriptExecutor jsExecutor,</span><br><span class="line">      final NativeModuleRegistry nativeModuleRegistry,</span><br><span class="line">      final JSBundleLoader jsBundleLoader,</span><br><span class="line">      NativeModuleCallExceptionHandler nativeModuleCallExceptionHandler) &#123;</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;Initializing React Xplat Bridge.&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第七步：CatalystInstanceImpl() called with: reactQueueConfigurationSpec = [&quot; + reactQueueConfigurationSpec + &quot;], jsExecutor = [&quot; + jsExecutor + &quot;], nativeModuleRegistry = [&quot; + nativeModuleRegistry + &quot;], jsBundleLoader = [&quot; + jsBundleLoader + &quot;], nativeModuleCallExceptionHandler = [&quot; + nativeModuleCallExceptionHandler + &quot;]&quot;);</span><br><span class="line">    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;createCatalystInstanceImpl&quot;);</span><br><span class="line"></span><br><span class="line">    // 重点关注一下这一方法。这是一个Native方法。这样我们就调用到Native层</span><br><span class="line">    mHybridData = initHybrid();</span><br><span class="line">    // ReactNative的消息队列相关的实例化</span><br><span class="line">    // TODO 这个地方要重点看一下</span><br><span class="line">    // 这个主要是分别在对应的线程中创建消息任务队列的Handler(搬运工)</span><br><span class="line">    // 当然还创建了两个线程(主线程不用创建)</span><br><span class="line">    mReactQueueConfiguration =</span><br><span class="line">        ReactQueueConfigurationImpl.create(</span><br><span class="line">            reactQueueConfigurationSpec, new NativeExceptionHandler());</span><br><span class="line">    mBridgeIdleListeners = new CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    // NativeModules注入器</span><br><span class="line">    mNativeModuleRegistry = nativeModuleRegistry;</span><br><span class="line">    mJSModuleRegistry = new JavaScriptModuleRegistry();</span><br><span class="line">    // JSBundlerLoader</span><br><span class="line">    mJSBundleLoader = jsBundleLoader;</span><br><span class="line">    mNativeModuleCallExceptionHandler = nativeModuleCallExceptionHandler;</span><br><span class="line">    mNativeModulesQueueThread = mReactQueueConfiguration.getNativeModulesQueueThread();</span><br><span class="line">    mTraceListener = new JSProfilerTraceListener(this);</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line"></span><br><span class="line">    Log.d(TAG, &quot;FMsg: 第七步：CatalystInstanceImpl() called Initializing React Xplat Bridge before initializeBridge&quot;);</span><br><span class="line">    Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;initializeCxxBridge&quot;);</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第七步：CatalystInstanceImpl() called with: initializeCxxBridge&quot;);</span><br><span class="line"></span><br><span class="line">    // TODO 这个地方要重点看一下. 又一个非常重要的方法。</span><br><span class="line">    // 初始化Java和Native之间的Bridge桥。这个是一个Native方法</span><br><span class="line">    initializeBridge(</span><br><span class="line">        //</span><br><span class="line">        new BridgeCallback(this),</span><br><span class="line">        // JSCore的JS引擎</span><br><span class="line">        jsExecutor,</span><br><span class="line">        // JS消息队列线程封装对象</span><br><span class="line">        mReactQueueConfiguration.getJSQueueThread(),</span><br><span class="line">            // Native消息队列线程封装对象</span><br><span class="line">        mNativeModulesQueueThread,</span><br><span class="line">        // 非C++的Modules就是JavaModule.也就是我们在Application里面封装的Modules</span><br><span class="line">        // 这些NativeModules都会被封装成JavaModuleWrapper对象送给Native层</span><br><span class="line">        mNativeModuleRegistry.getJavaModules(this),</span><br><span class="line">        // 获取我们所有的Module中的C++的modules。这个是通过注解来标记那个NativeModule是C++</span><br><span class="line">        // 但是我们翻了一下源码，没看到哪个NativeModule是C++</span><br><span class="line">        mNativeModuleRegistry.getCxxModules());</span><br><span class="line">    Log.d(ReactConstants.TAG, &quot;第七步：实例化Initializing React Xplat Bridge after initializeBridge&quot;);</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line"></span><br><span class="line">    mJavaScriptContextHolder = new JavaScriptContextHolder(getJavaScriptContext());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们看一下Native层的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jni::local_ref&lt;CatalystInstanceImpl::jhybriddata&gt; CatalystInstanceImpl::initHybrid(</span><br><span class="line">    jni::alias_ref&lt;jclass&gt;) &#123;</span><br><span class="line">   cout&lt;&lt;&quot;===========FMsg:CatalystInstanceImpl initHybrid  called===============&quot;&lt;&lt;endl;</span><br><span class="line">  return makeCxxInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void CatalystInstanceImpl::initializeBridge(</span><br><span class="line">    jni::alias_ref&lt;ReactCallback::javaobject&gt; callback,</span><br><span class="line">    // This executor is actually a factory holder.</span><br><span class="line">    JavaScriptExecutorHolder* jseh,</span><br><span class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; jsQueue,</span><br><span class="line">    jni::alias_ref&lt;JavaMessageQueueThread::javaobject&gt; nativeModulesQueue,</span><br><span class="line">    jni::alias_ref&lt;jni::JCollection&lt;JavaModuleWrapper::javaobject&gt;::javaobject&gt; javaModules,</span><br><span class="line">    jni::alias_ref&lt;jni::JCollection&lt;ModuleHolder::javaobject&gt;::javaobject&gt; cxxModules) &#123;</span><br><span class="line">    LOG(INFO) &lt;&lt;&quot;===========FMsg:CatalystInstanceImpl initializeBridge===============&quot;&lt;&lt;endl;</span><br><span class="line">    // .............省略部分代码</span><br><span class="line"></span><br><span class="line">  moduleRegistry_ = std::make_shared&lt;ModuleRegistry&gt;(</span><br><span class="line">    buildNativeModuleList(</span><br><span class="line">       std::weak_ptr&lt;Instance&gt;(instance_),</span><br><span class="line">       javaModules,</span><br><span class="line">       cxxModules,</span><br><span class="line">       moduleMessageQueue_));</span><br><span class="line"></span><br><span class="line">  instance_-&gt;initializeBridge(</span><br><span class="line">    std::make_unique&lt;JInstanceCallback&gt;(</span><br><span class="line">    callback,</span><br><span class="line">    moduleMessageQueue_),</span><br><span class="line">    jseh-&gt;getExecutorFactory(),</span><br><span class="line">    folly::make_unique&lt;JMessageQueueThread&gt;(jsQueue),</span><br><span class="line">    moduleRegistry_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，Java层的代码执行完毕。我们彻底就进入Native层的代码逻辑了。上面Jni代码中，调用的instance_-&gt;initializeBridge()。 这个逻辑层，我们要到Native层去查找逻辑实现了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Instance::initializeBridge(</span><br><span class="line">    std::unique_ptr&lt;InstanceCallback&gt; callback,</span><br><span class="line">    std::shared_ptr&lt;JSExecutorFactory&gt; jsef,</span><br><span class="line">    std::shared_ptr&lt;MessageQueueThread&gt; jsQueue,</span><br><span class="line">    std::shared_ptr&lt;ModuleRegistry&gt; moduleRegistry) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:Instance initializeBridge===============&quot;&lt;&lt;endl;</span><br><span class="line">  callback_ = std::move(callback);</span><br><span class="line">  moduleRegistry_ = std::move(moduleRegistry);</span><br><span class="line">  jsQueue-&gt;runOnQueueSync([this, &amp;jsef, jsQueue]() mutable &#123;</span><br><span class="line">    nativeToJsBridge_ = folly::make_unique&lt;NativeToJsBridge&gt;(</span><br><span class="line">        jsef.get(), moduleRegistry_, jsQueue, callback_);</span><br><span class="line"></span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(m_syncMutex);</span><br><span class="line">    m_syncReady = true;</span><br><span class="line">    m_syncCV.notify_all();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  CHECK(nativeToJsBridge_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上线的代码中。催化器对象在启动的流程中的主要作用就完成了。主要就是将催化器初始化的一些Java、Native、JS层的一些通信对象准备好。</p>
<p>我们在回过头去，看catalystInstance.runJSBundle()方法的调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void runJSBundle() &#123;</span><br><span class="line">  Log.d(ReactConstants.TAG, &quot;CatalystInstanceImpl.runJSBundle()&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第九步：runJSBundle() called&quot;);</span><br><span class="line">  Assertions.assertCondition(!mJSBundleHasLoaded, &quot;JS bundle was already loaded!&quot;);</span><br><span class="line">  // incrementPendingJSCalls();</span><br><span class="line">  mJSBundleLoader.loadScript(CatalystInstanceImpl.this);</span><br><span class="line"></span><br><span class="line">  synchronized (mJSCallsPendingInitLock) &#123;</span><br><span class="line"></span><br><span class="line">    // Loading the bundle is queued on the JS thread, but may not have</span><br><span class="line">    // run yet.  It&apos;s safe to set this here, though, since any work it</span><br><span class="line">    // gates will be queued on the JS thread behind the load.</span><br><span class="line">    mAcceptCalls = true;</span><br><span class="line"></span><br><span class="line">    for (PendingJSCall function : mJSCallsPendingInit) &#123;</span><br><span class="line">      function.call(this);</span><br><span class="line">    &#125;</span><br><span class="line">    mJSCallsPendingInit.clear();</span><br><span class="line">    mJSBundleHasLoaded = true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // This is registered after JS starts since it makes a JS call</span><br><span class="line">  Systrace.registerListener(mTraceListener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static JSBundleLoader createFileLoader(</span><br><span class="line">    final String fileName, final String assetUrl, final boolean loadSynchronously) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第九步：createFileLoader() called with: fileName = [&quot; + fileName + &quot;], assetUrl = [&quot; + assetUrl + &quot;], loadSynchronously = [&quot; + loadSynchronously + &quot;]&quot;);</span><br><span class="line">  return new JSBundleLoader() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String loadScript(JSBundleLoaderDelegate delegate) &#123;</span><br><span class="line">      delegate.loadScriptFromFile(fileName, assetUrl, loadSynchronously);</span><br><span class="line">      return fileName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void loadScriptFromFile(String fileName, String sourceURL, boolean loadSynchronously) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第九步：loadScriptFromFile() called with: fileName = [&quot; + fileName + &quot;], sourceURL = [&quot; + sourceURL + &quot;], loadSynchronously = [&quot; + loadSynchronously + &quot;]&quot;);</span><br><span class="line">  mSourceURL = sourceURL;</span><br><span class="line">  jniLoadScriptFromFile(fileName, sourceURL, loadSynchronously);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个jniLoadScriptFromFile也是一个Native的方法，我们可以看到他会调用到CatalystInstanceImpl.cpp的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void CatalystInstanceImpl::jniLoadScriptFromFile(const std::string&amp; fileName,</span><br><span class="line">                                                 const std::string&amp; sourceURL,</span><br><span class="line">                                                 bool loadSynchronously) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:CatalystInstanceImpl jniLoadScriptFromFile===============&quot;&lt;&lt;endl;</span><br><span class="line">  if (Instance::isIndexedRAMBundle(fileName.c_str())) &#123;</span><br><span class="line">    instance_-&gt;loadRAMBundleFromFile(fileName, sourceURL, loadSynchronously);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    std::unique_ptr&lt;const JSBigFileString&gt; script;</span><br><span class="line">    RecoverableError::runRethrowingAsRecoverable&lt;std::system_error&gt;(</span><br><span class="line">      [&amp;fileName, &amp;script]() &#123;</span><br><span class="line">        script = JSBigFileString::fromPath(fileName);</span><br><span class="line">      &#125;);</span><br><span class="line">    instance_-&gt;loadScriptFromString(std::move(script), sourceURL, loadSynchronously);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用到Instancee.cpp的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void Instance::loadScriptFromString(std::unique_ptr&lt;const JSBigString&gt; string,</span><br><span class="line">                                    std::string sourceURL,</span><br><span class="line">                                    bool loadSynchronously) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:Instance loadScriptFromString===============&quot;&lt;&lt;endl;</span><br><span class="line">  SystraceSection s(&quot;Instance::loadScriptFromString&quot;, &quot;sourceURL&quot;,</span><br><span class="line">                    sourceURL);</span><br><span class="line">  if (loadSynchronously) &#123;</span><br><span class="line">    loadApplicationSync(nullptr, std::move(string), std::move(sourceURL));</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    loadApplication(nullptr, std::move(string), std::move(sourceURL));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Instance::loadApplication(std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">                               std::unique_ptr&lt;const JSBigString&gt; string,</span><br><span class="line">                               std::string sourceURL) &#123;</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:Instance loadApplication=========string======&quot;&lt;&lt;endl;</span><br><span class="line">  callback_-&gt;incrementPendingJSCalls();</span><br><span class="line">  SystraceSection s(&quot;Instance::loadApplication&quot;, &quot;sourceURL&quot;,</span><br><span class="line">                    sourceURL);</span><br><span class="line">  nativeToJsBridge_-&gt;loadApplication(std::move(bundleRegistry), std::move(string),</span><br><span class="line">                                     std::move(sourceURL));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面有调用到了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void NativeToJsBridge::loadApplication(</span><br><span class="line">    std::unique_ptr&lt;RAMBundleRegistry&gt; bundleRegistry,</span><br><span class="line">    std::unique_ptr&lt;const JSBigString&gt; startupScript,</span><br><span class="line">    std::string startupScriptSourceURL) &#123;</span><br><span class="line">   LOG(INFO) &lt;&lt;&quot;===========FMsg:NativeToJsBridge loadApplication===============&quot;&lt;&lt;endl;</span><br><span class="line">  runOnExecutorQueue(</span><br><span class="line">      [this,</span><br><span class="line">       bundleRegistryWrap=folly::makeMoveWrapper(std::move(bundleRegistry)),</span><br><span class="line">       startupScript=folly::makeMoveWrapper(std::move(startupScript)),</span><br><span class="line">       startupScriptSourceURL=std::move(startupScriptSourceURL)]</span><br><span class="line">        (JSExecutor* executor) mutable &#123;</span><br><span class="line">    auto bundleRegistry = bundleRegistryWrap.move();</span><br><span class="line">    if (bundleRegistry) &#123;</span><br><span class="line">      executor-&gt;setBundleRegistry(std::move(bundleRegistry));</span><br><span class="line">    &#125;</span><br><span class="line">     //executor从runOnExecutorQueue()返回的map中取得，与OnLoad中的JSCJavaScriptExecutorHolder对应，也与</span><br><span class="line">     //Java中的JSCJavaScriptExecutor对应。它的实例在JSExecutor.cpp中实现。</span><br><span class="line">    try &#123;</span><br><span class="line">      LOG(INFO) &lt;&lt;&quot;===========FMsg:NativeToJsBridge executor  loadApplicationScript======&quot; &lt;&lt; startupScriptSourceURL &lt;&lt; &quot;。&quot;&lt;&lt;endl;</span><br><span class="line">      executor-&gt;loadApplicationScript(std::move(*startupScript),</span><br><span class="line">                                      std::move(startupScriptSourceURL));</span><br><span class="line">    &#125; catch (...) &#123;</span><br><span class="line">      m_applicationScriptHasFailure = true;</span><br><span class="line">      throw;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">void NativeToJsBridge::runOnExecutorQueue(std::function&lt;void(JSExecutor*)&gt; task) &#123;</span><br><span class="line">  if (*m_destroyed) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  std::shared_ptr&lt;bool&gt; isDestroyed = m_destroyed;</span><br><span class="line">  m_executorMessageQueueThread-&gt;runOnQueue([this, isDestroyed, task=std::move(task)] &#123;</span><br><span class="line">    if (*isDestroyed) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // The executor is guaranteed to be valid for the duration of the task because:</span><br><span class="line">    // 1. the executor is only destroyed after it is unregistered</span><br><span class="line">    // 2. the executor is unregistered on this queue</span><br><span class="line">    // 3. we just confirmed that the executor hasn&apos;t been unregistered above</span><br><span class="line">    task(m_executor.get());</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，我们看到他调用了JSIExecutor的loadApplicationScript。下面我们来看一下这个方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">void JSIExecutor::loadApplicationScript(</span><br><span class="line">    std::unique_ptr&lt;const JSBigString&gt; script,</span><br><span class="line">    std::string sourceURL) &#123;</span><br><span class="line">  SystraceSection s(&quot;JSIExecutor::loadApplicationScript&quot;);</span><br><span class="line">  LOG(INFO) &lt;&lt;&quot;===========FMsg:JSIExecutor loadApplicationScript===============sourceURL = &quot; &lt;&lt; sourceURL &lt;&lt; &quot;。&quot; &lt;&lt;endl;</span><br><span class="line">  // TODO: check for and use precompiled HBC</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;nativeModuleProxy&quot;,</span><br><span class="line">      Object::createFromHostObject(</span><br><span class="line">          *runtime_, std::make_shared&lt;NativeModuleProxy&gt;(*this)));</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;nativeFlushQueueImmediate&quot;,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, &quot;nativeFlushQueueImmediate&quot;),</span><br><span class="line">          1,</span><br><span class="line">          [this](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              const jsi::Value &amp;,</span><br><span class="line">              const jsi::Value *args,</span><br><span class="line">              size_t count) &#123;</span><br><span class="line">            if (count != 1) &#123;</span><br><span class="line">              throw std::invalid_argument(</span><br><span class="line">                  &quot;nativeFlushQueueImmediate arg count must be 1&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            // 应该是JSIExecutor⾥里里⾯面callNativeModules中的delegate_-&gt;callNativeModules</span><br><span class="line">            LOG(INFO) &lt;&lt;&quot;===========FMsg:JSIExecutor loadApplicationScript======callNativeModules=======&quot;&lt;&lt;endl;</span><br><span class="line">            callNativeModules(args[0], false);</span><br><span class="line">            return Value::undefined();</span><br><span class="line">          &#125;));</span><br><span class="line"></span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;nativeCallSyncHook&quot;,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, &quot;nativeCallSyncHook&quot;),</span><br><span class="line">          1,</span><br><span class="line">          [this](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              const jsi::Value &amp;,</span><br><span class="line">              const jsi::Value *args,</span><br><span class="line">              size_t count) &#123; return nativeCallSyncHook(args, count); &#125;));</span><br><span class="line"></span><br><span class="line">#if DEBUG</span><br><span class="line">  runtime_-&gt;global().setProperty(</span><br><span class="line">      *runtime_,</span><br><span class="line">      &quot;globalEvalWithSourceUrl&quot;,</span><br><span class="line">      Function::createFromHostFunction(</span><br><span class="line">          *runtime_,</span><br><span class="line">          PropNameID::forAscii(*runtime_, &quot;globalEvalWithSourceUrl&quot;),</span><br><span class="line">          1,</span><br><span class="line">          [this](</span><br><span class="line">              jsi::Runtime &amp;,</span><br><span class="line">              const jsi::Value &amp;,</span><br><span class="line">              const jsi::Value *args,</span><br><span class="line">              size_t count) &#123; return globalEvalWithSourceUrl(args, count); &#125;));</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  if (runtimeInstaller_) &#123;</span><br><span class="line">    runtimeInstaller_(*runtime_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bool hasLogger(ReactMarker::logTaggedMarker);</span><br><span class="line">  std::string scriptName = simpleBasename(sourceURL);</span><br><span class="line">  if (hasLogger) &#123;</span><br><span class="line">    ReactMarker::logTaggedMarker(</span><br><span class="line">        ReactMarker::RUN_JS_BUNDLE_START, scriptName.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  //使用Webkit JSC去解释执行JS</span><br><span class="line">  runtime_-&gt;evaluateJavaScript(</span><br><span class="line">      std::make_unique&lt;BigStringBuffer&gt;(std::move(script)), sourceURL);</span><br><span class="line">  flush();</span><br><span class="line">  if (hasLogger) &#123;</span><br><span class="line">    ReactMarker::logMarker(ReactMarker::CREATE_REACT_CONTEXT_STOP);</span><br><span class="line">    ReactMarker::logTaggedMarker(</span><br><span class="line">        ReactMarker::RUN_JS_BUNDLE_STOP, scriptName.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后代码调用到evaluateJavaScript方法中。这个方法的实现JSCRuntime.cpp中。我们简简单看一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jsi::Value JSCRuntime::evaluateJavaScript(</span><br><span class="line">    const std::shared_ptr&lt;const jsi::Buffer&gt; &amp;buffer,</span><br><span class="line">    const std::string&amp; sourceURL) &#123;</span><br><span class="line">  // LOG(INFO) &lt;&lt;&quot;===========FMsg:JSCRuntime evaluateJavaScript===============sourceURL = &quot; &lt;&lt; sourceURL &lt;&lt; &quot;。&quot; &lt;&lt;endl;</span><br><span class="line">  std::string tmp(</span><br><span class="line">      reinterpret_cast&lt;const char*&gt;(buffer-&gt;data()), buffer-&gt;size());</span><br><span class="line">  JSStringRef sourceRef = JSStringCreateWithUTF8CString(tmp.c_str());</span><br><span class="line">  JSStringRef sourceURLRef = nullptr;</span><br><span class="line">  if (!sourceURL.empty()) &#123;</span><br><span class="line">    sourceURLRef = JSStringCreateWithUTF8CString(sourceURL.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  JSValueRef exc = nullptr;</span><br><span class="line">  JSValueRef res =</span><br><span class="line">      JSEvaluateScript(ctx_, sourceRef, nullptr, sourceURLRef, 0, &amp;exc);</span><br><span class="line">  JSStringRelease(sourceRef);</span><br><span class="line">  if (sourceURLRef) &#123;</span><br><span class="line">    JSStringRelease(sourceURLRef);</span><br><span class="line">  &#125;</span><br><span class="line">  checkException(res, exc);</span><br><span class="line">  return createValue(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中，我们我们开始加载JSBundle的逻辑已经执行完毕。但是这个时候其实ReactNative并没有启动起来。</p>
<p>我们下面来看一下启动流程的最后一步：</p>
<p>我们来回到ReactRootView的startReactApplication这个方法中的最后一步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void attachToReactInstanceManager() &#123;</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;attachToReactInstanceManager&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:attachToReactInstanceManager() called&quot;);</span><br><span class="line">  try &#123;</span><br><span class="line">    if (mIsAttachedToInstance) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsAttachedToInstance = true;</span><br><span class="line">      // ReactInstanceManager绑定到当前的RootView</span><br><span class="line">    Assertions.assertNotNull(mReactInstanceManager).attachRootView(this);</span><br><span class="line">    getViewTreeObserver().addOnGlobalLayoutListener(getCustomGlobalLayoutListener());</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很简单，我们来看attachRootView的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void attachRootView(ReactRoot reactRoot) &#123;</span><br><span class="line">  Log.d(TAG, &quot;FMsg:attachRootView() called with: reactRoot = [&quot; + reactRoot + &quot;]&quot;);</span><br><span class="line">  UiThreadUtil.assertOnUiThread();</span><br><span class="line">  // ReactInstanceManager 是支持多 RootView 的.其实这个地方大家可以猜想，其实我们的ReactNative的页面，可以作为一个小的页面View</span><br><span class="line">  // 附着到宿主Activity上。</span><br><span class="line">  mAttachedReactRoots.add(reactRoot);</span><br><span class="line"></span><br><span class="line">  // Reset reactRoot content as it&apos;s going to be populated by the application content from JS.</span><br><span class="line">  clearReactRoot(reactRoot);</span><br><span class="line"></span><br><span class="line">  // If react context is being created in the background, JS application will be started</span><br><span class="line">  // automatically when creation completes, as reactRoot reactRoot is part of the attached</span><br><span class="line">  // reactRoot reactRoot list.</span><br><span class="line">  ReactContext currentContext = getCurrentReactContext();</span><br><span class="line">  if (mCreateReactContextThread == null &amp;&amp; currentContext != null) &#123;</span><br><span class="line">    // 最后，取出 ReactContext，让 ReactRootView 与 CatalystInstance 相关联：</span><br><span class="line">    attachRootViewToInstance(reactRoot);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">private void attachRootViewToInstance(final ReactRoot reactRoot) &#123;</span><br><span class="line">  Log.d(ReactConstants.TAG, &quot;ReactInstanceManager.attachRootViewToInstance()&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第十步：attachRootViewToInstance() called with: reactRoot = [&quot; + reactRoot + &quot;]&quot;);</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;attachRootViewToInstance&quot;);</span><br><span class="line"></span><br><span class="line">  // 首先通过 UIManagerHelper 拿到 UIManager：</span><br><span class="line">  // UIManager 是什么呢？它有两个实现类：FabricUIManager、UIManagerModule</span><br><span class="line">  // 我们来看后者，它的注释中说：这是一个原生模块，允许JS创建和更新原生视图。其实这个就是我们后来看RN的渲染流程中非常重要的类</span><br><span class="line">  UIManager uiManager =</span><br><span class="line">      UIManagerHelper.getUIManager(mCurrentReactContext, reactRoot.getUIManagerType());</span><br><span class="line"></span><br><span class="line">  @Nullable Bundle initialProperties = reactRoot.getAppProperties();</span><br><span class="line"></span><br><span class="line">  final int rootTag =</span><br><span class="line">      uiManager.addRootView(</span><br><span class="line">          reactRoot.getRootViewGroup(),</span><br><span class="line">          initialProperties == null</span><br><span class="line">              ? new WritableNativeMap()</span><br><span class="line">              : Arguments.fromBundle(initialProperties),</span><br><span class="line">          reactRoot.getInitialUITemplate());</span><br><span class="line">  reactRoot.setRootViewTag(rootTag);</span><br><span class="line">  if (reactRoot.getUIManagerType() == FABRIC) &#123;</span><br><span class="line">    // Fabric requires to call updateRootLayoutSpecs before starting JS Application,</span><br><span class="line">    // this ensures the root will hace the correct pointScaleFactor.</span><br><span class="line">    uiManager.updateRootLayoutSpecs(</span><br><span class="line">        rootTag, reactRoot.getWidthMeasureSpec(), reactRoot.getHeightMeasureSpec());</span><br><span class="line">    reactRoot.setShouldLogContentAppeared(true);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    Log.d(TAG, &quot;FMsg:第十步：attachRootViewToInstance() called with: reactRoot = [&quot; + reactRoot + &quot;]&quot;);</span><br><span class="line">    // 这个方法就是我们真的去调用JS的相关代码，我们可以看看这个代码</span><br><span class="line">    reactRoot.runApplication();</span><br><span class="line">  &#125;</span><br><span class="line">  Systrace.beginAsyncSection(</span><br><span class="line">      TRACE_TAG_REACT_JAVA_BRIDGE, &quot;pre_rootView.onAttachedToReactInstance&quot;, rootTag);</span><br><span class="line">  // 这个地方其实，我们有疑问：</span><br><span class="line">  // 为什么使用UiThreadUtil.runOnUiThread。而不是</span><br><span class="line">  //  mCurrentReactContext.runOnUiQueueThread();???</span><br><span class="line">  UiThreadUtil.runOnUiThread(</span><br><span class="line">      new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">          Systrace.endAsyncSection(</span><br><span class="line">              TRACE_TAG_REACT_JAVA_BRIDGE, &quot;pre_rootView.onAttachedToReactInstance&quot;, rootTag);</span><br><span class="line">          reactRoot.onStage(ReactStage.ON_ATTACH_TO_INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法的最后一步，我们就可以看到reactRoot.runApplication()  这个方法很明显，就是运行起来JS的相关代码逻辑。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void runApplication() &#123;</span><br><span class="line">  Systrace.beginSection(TRACE_TAG_REACT_JAVA_BRIDGE, &quot;ReactRootView.runApplication&quot;);</span><br><span class="line">  Log.d(TAG, &quot;FMsg:第十一步：ReactRootView runApplication() called&quot;);</span><br><span class="line">  try &#123;</span><br><span class="line">    if (mReactInstanceManager == null || !mIsAttachedToInstance) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ReactContext reactContext = mReactInstanceManager.getCurrentReactContext();</span><br><span class="line">    if (reactContext == null) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CatalystInstance catalystInstance = reactContext.getCatalystInstance();</span><br><span class="line">    String jsAppModuleName = getJSModuleName();</span><br><span class="line"></span><br><span class="line">    if (mUseSurface) &#123;</span><br><span class="line">      // TODO call surface&apos;s runApplication</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (mWasMeasured) &#123;</span><br><span class="line">        updateRootLayoutSpecs(mWidthMeasureSpec, mHeightMeasureSpec);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      WritableNativeMap appParams = new WritableNativeMap();</span><br><span class="line">      appParams.putDouble(&quot;rootTag&quot;, getRootViewTag());</span><br><span class="line">      @Nullable Bundle appProperties = getAppProperties();</span><br><span class="line">      if (appProperties != null) &#123;</span><br><span class="line">        appParams.putMap(&quot;initialProps&quot;, Arguments.fromBundle(appProperties));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mShouldLogContentAppeared = true;</span><br><span class="line">      Log.i(TAG, &quot;FMsg: 第十步：==============runApplication: ==========================&quot; + jsAppModuleName);</span><br><span class="line">      Log.i(TAG, &quot;FMsg: 第十步：==============runApplication: ==========================&quot; + appParams);</span><br><span class="line">      catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    Systrace.endSection(TRACE_TAG_REACT_JAVA_BRIDGE);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法也是比较简单的。通过ReactContext的实例，拿到催化器实例。然后通过催化器实例获取JSModule的runApplication</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public &lt;T extends JavaScriptModule&gt; T getJSModule(Class&lt;T&gt; jsInterface) &#123;</span><br><span class="line">  // Log.d(TAG, &quot;FMsg:getJSModule() called with: jsInterface = [&quot; + jsInterface + &quot;]&quot;);</span><br><span class="line">  // mJSModuleRegistry注入器获取当前的注入器。至于怎么去获取的。我们可以再分析</span><br><span class="line">  return mJSModuleRegistry.getJavaScriptModule(this, jsInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，最终调用的是 catalystInstance.getJSModule(AppRegistry.class).runApplication(jsAppModuleName, appParams) ， AppRegistry.class 是JS层暴露给Java层的接口方法。它的真正实现在 AppRegistry.js 里， AppRegistry.js 是运行所有 RN 应用的 JS 层入口，我们来看看它的实现：在 Libraries/ReactNative 中的 AppRegistry.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Loads the JavaScript bundle and runs the app.</span><br><span class="line"> *</span><br><span class="line"> * See http://facebook.github.io/react-native/docs/appregistry.html#runapplication</span><br><span class="line"> */</span><br><span class="line">runApplication(appKey: string, appParameters: any): void &#123;</span><br><span class="line">  const msg =</span><br><span class="line">    &apos;Running &quot;&apos; + appKey + &apos;&quot; with &apos; + JSON.stringify(appParameters);</span><br><span class="line">  infoLog(msg);</span><br><span class="line">  BugReporting.addSource(</span><br><span class="line">    &apos;AppRegistry.runApplication&apos; + runCount++,</span><br><span class="line">    () =&gt; msg,</span><br><span class="line">  );</span><br><span class="line">  invariant(</span><br><span class="line">    runnables[appKey] &amp;&amp; runnables[appKey].run,</span><br><span class="line">    `&quot;$&#123;appKey&#125;&quot; has not been registered. This can happen if:\n` +</span><br><span class="line">      &apos;* Metro (the local dev server) is run from the wrong folder. &apos; +</span><br><span class="line">      &apos;Check if Metro is running, stop it and restart it in the current project.\n&apos; +</span><br><span class="line">      &quot;* A module failed to load due to an error and `AppRegistry.registerComponent` wasn&apos;t called.&quot;,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  SceneTracker.setActiveScene(&#123;name: appKey&#125;);</span><br><span class="line">  runnables[appKey].run(appParameters);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>到这里就会去调用JS进行渲染，在通过 UIManagerModule 将JS组件转换成Android组件，最终显示在 ReactRootView 上。</p>
<p>最后总结一下，就是先在应用终端启动并创建上下文对象，启动 JS Runtime ，进行布局，将JS端的代码通过C++层， UIManagerMoodule 转化成 Android 组件，再进行渲染，最后将渲染的View添加到 ReactRootView 上，最终呈现在用户面前。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Frewen Wong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.frewen.wang/2020/03/13/ReactNative的启动流程精讲(基于ReactNative0.61.5)/">http://www.frewen.wang/2020/03/13/ReactNative的启动流程精讲(基于ReactNative0.61.5)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.frewen.wang" target="_blank">麦溪·在路上</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ReactNative；Android；/">ReactNative；Android；</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/07/ReactNative的渲染流程(基于ReacNative0.61.5)/"><img class="prev_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ReactNative的渲染流程(基于ReacNative0.61.5)</div></div></a></div><div class="next-post pull_right"><a href="/2019/06/13/创建型模式-单例模式（Singleton Pattern）/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">创建型模式-单例模式（Singleton Pattern）</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/img/post.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Frewen Wong</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async></script><script src="/js/third-party/click_heart.js"></script><script src="/js/search/local-search.js"></script></body></html>